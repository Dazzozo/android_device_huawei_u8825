From 77bf42a5ef555d5cb545660eb8a744cf8489dfca Mon Sep 17 00:00:00 2001
From: Kyle Harrison <khwebmail@gmail.com>
Date: Tue, 28 Jan 2014 00:08:38 +0000
Subject: [PATCH] U8825 uses the same audio HAL as the U8815(G300)

---
 audio/Android.mk             |  132 ++
 audio/AudioHardware.cpp      | 4291 ++++++++++++++++++++++++++++++++++++++++++
 audio/AudioHardware.h        |  639 +++++++
 audio/AudioHardware_cad.cpp  | 3639 +++++++++++++++++++++++++++++++++++
 audio/AudioPolicyManager.cpp | 1541 +++++++++++++++
 audio/AudioPolicyManager.h   |  122 ++
 audio/HardwarePinSwitching.c |  240 +++
 audio/HardwarePinSwitching.h |   42 +
 audio/audio_hw_hal.cpp       |  766 ++++++++
 audio/audio_policy.conf      |   77 +
 audio/audio_policy_hal.cpp   |  516 +++++
 11 files changed, 12005 insertions(+)
 create mode 100644 audio/Android.mk
 create mode 100644 audio/AudioHardware.cpp
 create mode 100644 audio/AudioHardware.h
 create mode 100644 audio/AudioHardware_cad.cpp
 create mode 100644 audio/AudioPolicyManager.cpp
 create mode 100644 audio/AudioPolicyManager.h
 create mode 100644 audio/HardwarePinSwitching.c
 create mode 100644 audio/HardwarePinSwitching.h
 create mode 100644 audio/audio_hw_hal.cpp
 create mode 100644 audio/audio_policy.conf
 create mode 100644 audio/audio_policy_hal.cpp

diff --git a/audio/Android.mk b/audio/Android.mk
new file mode 100644
index 0000000..8467200
--- /dev/null
+++ b/audio/Android.mk
@@ -0,0 +1,132 @@
+# Copyright 2011 The Android Open Source Project
+
+#AUDIO_POLICY_TEST := true
+#ENABLE_AUDIO_DUMP := true
+
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+    AudioHardware.cpp \
+    audio_hw_hal.cpp \
+    HardwarePinSwitching.c
+
+ifeq ($(BOARD_HAVE_BLUETOOTH),true)
+  LOCAL_CFLAGS += -DWITH_A2DP
+endif
+
+ifeq ($(BOARD_HAVE_QCOM_FM),true)
+  LOCAL_CFLAGS += -DWITH_QCOM_FM
+  LOCAL_CFLAGS += -DQCOM_FM_ENABLED
+endif
+
+ifeq ($(call is-android-codename-in-list,ICECREAM_SANDWICH),true)
+  LOCAL_CFLAGS += -DREG_KERNEL_UPDATE
+endif
+
+ifeq ($(strip $(BOARD_USES_SRS_TRUEMEDIA)),true)
+LOCAL_CFLAGS += -DSRS_PROCESSING
+endif
+
+ifeq ($(BOARD_USES_QCOM_AUDIO_LPA),true)
+    LOCAL_CFLAGS += -DQCOM_TUNNEL_LPA_ENABLED
+endif
+
+ifeq ($(BOARD_USES_QCOM_AUDIO_SPEECH),true)
+    LOCAL_CFLAGS += -DWITH_QCOM_SPEECH
+endif
+
+ifeq ($(BOARD_USES_QCOM_AUDIO_VOIPMUTE),true)
+    LOCAL_CFLAGS += -DWITH_QCOM_VOIPMUTE
+endif
+
+ifeq ($(BOARD_USES_QCOM_AUDIO_RESETALL),true)
+    LOCAL_CFLAGS += -DWITH_QCOM_RESETALL
+endif
+
+LOCAL_CFLAGS += -DQCOM_VOIP_ENABLED
+LOCAL_CFLAGS += -DQCOM_TUNNEL_LPA_ENABLED
+
+LOCAL_SHARED_LIBRARIES := \
+    libcutils       \
+    libutils        \
+    libmedia        \
+    libaudioalsa
+
+# hack for prebuilt
+$(shell mkdir -p $(OUT)/obj/SHARED_LIBRARIES/libaudioalsa_intermediates/)
+$(shell touch $(OUT)/obj/SHARED_LIBRARIES/libaudioalsa_intermediates/export_includes)
+
+ifneq ($(TARGET_SIMULATOR),true)
+LOCAL_SHARED_LIBRARIES += libdl
+endif
+
+ifeq ($(BOARD_USES_QCOM_AUDIO_CALIBRATION),true)
+    LOCAL_SHARED_LIBRARIES += libaudcal
+    LOCAL_CFLAGS += -DWITH_QCOM_CALIBRATION
+endif
+
+LOCAL_STATIC_LIBRARIES := \
+    libmedia_helper \
+    libaudiohw_legacy
+
+LOCAL_MODULE := audio.primary.$(TARGET_BOARD_PLATFORM)
+LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
+LOCAL_MODULE_TAGS := optional
+
+LOCAL_CFLAGS += -fno-short-enums
+
+LOCAL_C_INCLUDES := $(TARGET_OUT_HEADERS)/mm-audio/audio-alsa
+ifeq ($(BOARD_USES_QCOM_AUDIO_CALIBRATION),true)
+    LOCAL_C_INCLUDES += $(TARGET_OUT_HEADERS)/mm-audio/audcal
+endif
+LOCAL_C_INCLUDES += hardware/libhardware/include
+LOCAL_C_INCLUDES += hardware/libhardware_legacy/include
+LOCAL_C_INCLUDES += frameworks/base/include
+LOCAL_C_INCLUDES += system/core/include
+
+LOCAL_C_INCLUDES += $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr/include
+LOCAL_ADDITIONAL_DEPENDENCIES := $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr
+
+include $(BUILD_SHARED_LIBRARY)
+
+# The audio policy is implemented on top of legacy policy code
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+    AudioPolicyManager.cpp \
+    audio_policy_hal.cpp
+
+LOCAL_SHARED_LIBRARIES := \
+    libcutils \
+    libutils \
+    libmedia
+
+LOCAL_STATIC_LIBRARIES := \
+    libaudiohw_legacy \
+    libmedia_helper \
+    libaudiopolicy_legacy
+
+LOCAL_MODULE := audio_policy.$(TARGET_BOARD_PLATFORM)
+LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
+LOCAL_MODULE_TAGS := optional
+
+ifeq ($(BOARD_HAVE_BLUETOOTH),true)
+  LOCAL_CFLAGS += -DWITH_A2DP
+endif
+
+LOCAL_C_INCLUDES := hardware/libhardware_legacy/audio
+
+LOCAL_C_INCLUDES += $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr/include
+LOCAL_ADDITIONAL_DEPENDENCIES := $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr
+
+include $(BUILD_SHARED_LIBRARY)
+
+# Load audio_policy.conf to system/etc/
+include $(CLEAR_VARS)
+LOCAL_MODULE       := audio_policy.conf
+LOCAL_MODULE_TAGS  := optional
+LOCAL_MODULE_CLASS := ETC
+LOCAL_MODULE_PATH  := $(TARGET_OUT_ETC)
+LOCAL_SRC_FILES    := audio_policy.conf
+include $(BUILD_PREBUILT)
diff --git a/audio/AudioHardware.cpp b/audio/AudioHardware.cpp
new file mode 100644
index 0000000..9dc0ba5
--- /dev/null
+++ b/audio/AudioHardware.cpp
@@ -0,0 +1,4291 @@
+/*
+** Copyright 2008, The Android Open-Source Project
+** Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#include <math.h>
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "AudioHardwareMSM76XXA"
+#include <utils/Log.h>
+#include <utils/String8.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <dlfcn.h>
+#include <fcntl.h>
+#include <cutils/properties.h> // for property_get
+
+// hardware specific functions
+
+#include "AudioHardware.h"
+#ifdef QCOM_FM_ENABLED
+extern "C" {
+#include "HardwarePinSwitching.h"
+}
+#endif
+//#include <media/AudioRecord.h>
+
+#ifdef WITH_QCOM_VOIP_OVER_MVS
+#include <linux/msm_audio_mvs.h>
+#endif
+
+#define COMBO_DEVICE_SUPPORTED // Headset speaker combo device not supported on this target
+#define DUALMIC_KEY "dualmic_enabled"
+#define TTY_MODE_KEY "tty_mode"
+#define ECHO_SUPRESSION "ec_supported"
+#define VOIPRATE_KEY "voip_rate"
+namespace android_audio_legacy {
+
+#ifdef SRS_PROCESSING
+void*       SRSParamsG = NULL;
+void*       SRSParamsW = NULL;
+void*       SRSParamsC = NULL;
+void*       SRSParamsHP = NULL;
+void*       SRSParamsP = NULL;
+void*       SRSParamsHL = NULL;
+
+#define SRS_PARAMS_G 1
+#define SRS_PARAMS_W 2
+#define SRS_PARAMS_C 4
+#define SRS_PARAMS_HP 8
+#define SRS_PARAMS_P 16
+#define SRS_PARAMS_HL 32
+#define SRS_PARAMS_ALL 0xFF
+
+#endif /*SRS_PROCESSING*/
+
+static int audpre_index, tx_iir_index;
+static void * acoustic;
+const uint32_t AudioHardware::inputSamplingRates[] = {
+        8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000
+};
+
+static int get_audpp_filter(void);
+static int msm72xx_enable_postproc(bool state);
+#ifdef SRS_PROCESSING
+static void msm72xx_enable_srs(int flags, bool state);
+#endif /*SRS_PROCESSING*/
+static int msm72xx_enable_preproc(bool state);
+
+// Post processing paramters
+static struct rx_iir_filter iir_cfg[3];
+static struct adrc_filter adrc_cfg[3];
+static struct mbadrc_filter mbadrc_cfg[3];
+eqalizer equalizer[3];
+static uint16_t adrc_flag[3];
+static uint16_t mbadrc_flag[3];
+static uint16_t eq_flag[3];
+static uint16_t rx_iir_flag[3];
+static uint16_t agc_flag[3];
+static uint16_t ns_flag[3];
+static uint16_t txiir_flag[3];
+static bool audpp_filter_inited = false;
+static bool adrc_filter_exists[3];
+static bool mbadrc_filter_exists[3];
+static int post_proc_feature_mask = 0;
+static int new_post_proc_feature_mask = 0;
+static bool hpcm_playback_in_progress = false;
+#ifdef QCOM_TUNNEL_LPA_ENABLED
+static bool lpa_playback_in_progress = false;
+#endif
+
+//Pre processing parameters
+static struct tx_iir tx_iir_cfg[9];
+static struct ns ns_cfg[9];
+static struct tx_agc tx_agc_cfg[9];
+static int enable_preproc_mask[9];
+
+static int snd_device = -1;
+
+#define PCM_OUT_DEVICE "/dev/msm_pcm_out"
+#define PCM_IN_DEVICE "/dev/msm_pcm_in"
+#define PCM_CTL_DEVICE "/dev/msm_pcm_ctl"
+#define PREPROC_CTL_DEVICE "/dev/msm_preproc_ctl"
+#define VOICE_MEMO_DEVICE "/dev/msm_voicememo"
+#ifdef QCOM_FM_ENABLED
+#define FM_DEVICE  "/dev/msm_fm"
+#endif
+#define BTHEADSET_VGS "bt_headset_vgs"
+#ifdef QCOM_VOIP_ENABLED
+#define MVS_DEVICE "/dev/msm_mvs"
+#endif /*QCOM_VOIP_ENABLED*/
+
+static uint32_t SND_DEVICE_CURRENT=-1;
+static uint32_t SND_DEVICE_HANDSET=-1;
+static uint32_t SND_DEVICE_SPEAKER=-1;
+static uint32_t SND_DEVICE_BT=-1;
+static uint32_t SND_DEVICE_BT_EC_OFF=-1;
+static uint32_t SND_DEVICE_HEADSET=-1;
+static uint32_t SND_DEVICE_STEREO_HEADSET_AND_SPEAKER=-1;
+static uint32_t SND_DEVICE_IN_S_SADC_OUT_HANDSET=-1;
+static uint32_t SND_DEVICE_IN_S_SADC_OUT_SPEAKER_PHONE=-1;
+static uint32_t SND_DEVICE_TTY_HEADSET=-1;
+static uint32_t SND_DEVICE_TTY_HCO=-1;
+static uint32_t SND_DEVICE_TTY_VCO=-1;
+static uint32_t SND_DEVICE_CARKIT=-1;
+static uint32_t SND_DEVICE_FM_SPEAKER=-1;
+static uint32_t SND_DEVICE_FM_HEADSET=-1;
+static uint32_t SND_DEVICE_NO_MIC_HEADSET=-1;
+static uint32_t SND_DEVICE_FM_DIGITAL_STEREO_HEADSET=-1;
+static uint32_t SND_DEVICE_FM_DIGITAL_SPEAKER_PHONE=-1;
+static uint32_t SND_DEVICE_FM_DIGITAL_BT_A2DP_HEADSET=-1;
+static uint32_t SND_DEVICE_FM_ANALOG_STEREO_HEADSET=-1;
+static uint32_t SND_DEVICE_FM_ANALOG_STEREO_HEADSET_CODEC=-1;
+// ----------------------------------------------------------------------------
+
+AudioHardware::AudioHardware() :
+    mInit(false), mMicMute(true), mBluetoothNrec(true), mBluetoothId(0), mTtyMode(TTY_OFF),
+    mOutput(0),mBluetoothVGS(false), mSndEndpoints(NULL), mCurSndDevice(-1), mDualMicEnabled(false)
+#ifdef QCOM_FM_ENABLED
+    ,mFmFd(-1),FmA2dpStatus(-1)
+#endif
+#ifdef QCOM_VOIP_ENABLED
+,mVoipFd(-1), mVoipInActive(false), mVoipOutActive(false), mDirectOutput(0), mVoipBitRate(0),
+mDirectOutrefCnt(0)
+ #endif /*QCOM_VOIP_ENABLED*/
+{
+   if (get_audpp_filter() == 0) {
+           audpp_filter_inited = true;
+   }
+
+    m7xsnddriverfd = open("/dev/msm_snd", O_RDWR);
+    if (m7xsnddriverfd >= 0) {
+        int rc = ioctl(m7xsnddriverfd, SND_GET_NUM_ENDPOINTS, &mNumSndEndpoints);
+        if (rc >= 0) {
+            mSndEndpoints = new msm_snd_endpoint[mNumSndEndpoints];
+            mInit = true;
+            ALOGV("constructed (%d SND endpoints)", rc);
+            struct msm_snd_endpoint *ept = mSndEndpoints;
+            for (int cnt = 0; cnt < mNumSndEndpoints; cnt++, ept++) {
+                ept->id = cnt;
+                ioctl(m7xsnddriverfd, SND_GET_ENDPOINT, ept);
+                ALOGV("cnt = %d ept->name = %s ept->id = %d\n", cnt, ept->name, ept->id);
+#define CHECK_FOR(desc) if (!strcmp(ept->name, #desc)) SND_DEVICE_##desc = ept->id;
+                CHECK_FOR(CURRENT);
+                CHECK_FOR(HANDSET);
+                CHECK_FOR(SPEAKER);
+                CHECK_FOR(BT);
+                CHECK_FOR(BT_EC_OFF);
+                CHECK_FOR(HEADSET);
+                CHECK_FOR(STEREO_HEADSET_AND_SPEAKER);
+                CHECK_FOR(IN_S_SADC_OUT_HANDSET);
+                CHECK_FOR(IN_S_SADC_OUT_SPEAKER_PHONE);
+                CHECK_FOR(TTY_HEADSET);
+                CHECK_FOR(TTY_HCO);
+                CHECK_FOR(TTY_VCO);
+#ifdef QCOM_FM_ENABLED
+                CHECK_FOR(FM_DIGITAL_STEREO_HEADSET);
+                CHECK_FOR(FM_DIGITAL_SPEAKER_PHONE);
+                CHECK_FOR(FM_DIGITAL_BT_A2DP_HEADSET);
+                CHECK_FOR(FM_ANALOG_STEREO_HEADSET);
+                CHECK_FOR(FM_ANALOG_STEREO_HEADSET_CODEC);
+#endif
+#undef CHECK_FOR
+            }
+        }
+        else ALOGE("Could not retrieve number of MSM SND endpoints.");
+
+        int AUTO_VOLUME_ENABLED = 0; // setting disabled as default
+
+        static const char *const path = "/system/etc/AutoVolumeControl.txt";
+        int txtfd;
+        struct stat st;
+        char *read_buf;
+
+        txtfd = open(path, O_RDONLY);
+        if (txtfd < 0) {
+            ALOGE("failed to open AUTO_VOLUME_CONTROL %s: %s (%d)",
+                  path, strerror(errno), errno);
+        }
+        else {
+            if (fstat(txtfd, &st) < 0) {
+                ALOGE("failed to stat %s: %s (%d)",
+                      path, strerror(errno), errno);
+                close(txtfd);
+            }
+
+            read_buf = (char *) mmap(0, st.st_size,
+                        PROT_READ | PROT_WRITE,
+                        MAP_PRIVATE,
+                        txtfd, 0);
+
+            if (read_buf == MAP_FAILED) {
+                ALOGE("failed to mmap parameters file: %s (%d)",
+                      strerror(errno), errno);
+                close(txtfd);
+            }
+
+            if(read_buf[0] =='1')
+               AUTO_VOLUME_ENABLED = 1;
+
+            munmap(read_buf, st.st_size);
+            close(txtfd);
+        }
+        ALOGD("Auto Volume Enabled= %d", AUTO_VOLUME_ENABLED);
+        ioctl(m7xsnddriverfd, SND_AVC_CTL, &AUTO_VOLUME_ENABLED);
+        ioctl(m7xsnddriverfd, SND_AGC_CTL, &AUTO_VOLUME_ENABLED);
+    } else
+        ALOGE("Could not open MSM SND driver.");
+}
+
+AudioHardware::~AudioHardware()
+{
+    for (size_t index = 0; index < mInputs.size(); index++) {
+        closeInputStream((AudioStreamIn*)mInputs[index]);
+    }
+    mInputs.clear();
+#ifdef QCOM_VOIP_ENABLED
+    mVoipInputs.clear();
+#endif
+    closeOutputStream((AudioStreamOut*)mOutput);
+    delete [] mSndEndpoints;
+    if (acoustic) {
+        ::dlclose(acoustic);
+        acoustic = 0;
+    }
+    if (m7xsnddriverfd > 0)
+    {
+      close(m7xsnddriverfd);
+      m7xsnddriverfd = -1;
+    }
+    for (int index = 0; index < 9; index++) {
+        enable_preproc_mask[index] = 0;
+    }
+    mInit = false;
+}
+
+status_t AudioHardware::initCheck()
+{
+    return mInit ? NO_ERROR : NO_INIT;
+}
+
+AudioStreamOut* AudioHardware::openOutputStream(uint32_t devices, int *format, uint32_t *channels, uint32_t *sampleRate, status_t *status)
+{
+    audio_output_flags_t flags = static_cast<audio_output_flags_t> (*status);
+
+    ALOGD("openOutputStream: devices = %u format = %x channels = %u sampleRate = %u flags %x\n",
+         devices, *format, *channels, *sampleRate, flags);
+    { // scope for the lock
+        status_t lStatus;
+        Mutex::Autolock lock(mLock);
+#ifdef QCOM_VOIP_ENABLED
+        // only one output stream allowed
+        if (mOutput && !((flags & AUDIO_OUTPUT_FLAG_DIRECT) && (flags & AUDIO_OUTPUT_FLAG_VOIP_RX))
+                    && !(flags & AUDIO_OUTPUT_FLAG_LPA)) {
+            if (status) {
+                *status = INVALID_OPERATION;
+            }
+            ALOGE(" AudioHardware::openOutputStream Only one output stream allowed \n");
+            return 0;
+        }
+        if ((flags & AUDIO_OUTPUT_FLAG_DIRECT) && (flags & AUDIO_OUTPUT_FLAG_VOIP_RX)) {
+
+            if(mDirectOutput == 0) {
+                // open direct output stream
+                ALOGV(" AudioHardware::openOutputStream Direct output stream \n");
+                AudioStreamOutDirect* out = new AudioStreamOutDirect();
+               lStatus = out->set(this, devices, format, channels, sampleRate);
+                if (status) {
+                    *status = lStatus;
+                }
+                if (lStatus == NO_ERROR) {
+                    mDirectOutput = out;
+                    mDirectOutrefCnt++;
+                    mLock.unlock();
+                    if (mVoipInActive)
+                        setupDeviceforVoipCall(true);
+                    mLock.lock();
+                    ALOGV(" \n set sucessful for AudioStreamOutDirect");
+                } else {
+                    ALOGE(" \n set Failed for AudioStreamOutDirect");
+                    delete out;
+                }
+            }
+            else {
+               mDirectOutrefCnt++;
+                ALOGE(" \n AudioHardware::AudioStreamOutDirect is already open refCnt %d", mDirectOutrefCnt);
+             }
+            return mDirectOutput;
+        }
+        else
+#endif /*QCOM_VOIP_ENABLED*/
+	    if (flags & AUDIO_OUTPUT_FLAG_LPA) {
+			status_t err = BAD_VALUE;
+#if 0
+            if (mOutput) {
+                if (status) {
+                  *status = INVALID_OPERATION;
+                }
+                ALOGE(" AudioHardware::openOutputStream Only one output stream allowed \n");
+                return 0;
+            }
+#endif
+            // create new output LPA stream
+            AudioSessionOutLPA* out = new AudioSessionOutLPA(this, devices, *format, *channels,*sampleRate,0,&err);
+            if(err != NO_ERROR) {
+                delete out;
+                out = NULL;
+            }
+            if (status) *status = err;
+            mOutputLPA = out;
+        return mOutputLPA;
+
+        } else {
+#if 0
+            ALOGV(" AudioHardware::openOutputStream AudioStreamOutMSM8x60 output stream \n");
+            // only one output stream allowed
+            if (mOutput) {
+                if (status) {
+                  *status = INVALID_OPERATION;
+                }
+                ALOGE(" AudioHardware::openOutputStream Only one output stream allowed \n");
+                return 0;
+            }
+#endif
+            // create new output stream
+            AudioStreamOutMSM72xx* out = new AudioStreamOutMSM72xx();
+            lStatus = out->set(this, devices, format, channels, sampleRate);
+            if (status) {
+                *status = lStatus;
+            }
+            if (lStatus == NO_ERROR) {
+                mOutput = out;
+            } else {
+                delete out;
+            }
+            return mOutput;
+        }
+    }
+    return NULL;
+}
+
+void AudioHardware::closeOutputStream(AudioStreamOut* out) {
+    Mutex::Autolock lock(mLock);
+    if ((mOutput == 0
+#ifdef QCOM_VOIP_ENABLED
+      && mDirectOutput == 0
+#endif
+        && mOutputLPA == 0) || ((mOutput != out)
+#ifdef QCOM_VOIP_ENABLED
+      && (mDirectOutput != out)
+#endif
+       && (mOutputLPA != out))) {
+        ALOGW("Attempt to close invalid output stream");
+    }
+    else if (mOutput == out) {
+        delete mOutput;
+        mOutput = 0;
+    }
+#ifdef QCOM_VOIP_ENABLED
+    else if (mDirectOutput == out) {
+         mDirectOutrefCnt--;
+        if (mDirectOutrefCnt <= 0) {
+            ALOGV(" deleting  mDirectOutput \n");
+            delete mDirectOutput;
+            mDirectOutput = 0;
+        }
+    }
+#endif /*QCOM_VOIP_ENABLED*/
+    else if (mOutputLPA == out) {
+	    ALOGV(" deleting  mOutputLPA \n");
+        delete mOutputLPA;
+        mOutputLPA = 0;
+    }
+}
+
+AudioStreamIn* AudioHardware::openInputStream(
+        uint32_t devices, int *format, uint32_t *channels, uint32_t *sampleRate, status_t *status,
+        AudioSystem::audio_in_acoustics acoustic_flags)
+{
+    ALOGD("AudioHardware::openInputStream devices %x format %d channels %d samplerate %d",
+        devices, *format, *channels, *sampleRate);
+
+    // check for valid input source
+    if (!AudioSystem::isInputDevice((AudioSystem::audio_devices)devices)) {
+        return 0;
+    }
+
+    mLock.lock();
+#ifdef QCOM_VOIP_ENABLED
+    if ((devices == AudioSystem::DEVICE_IN_COMMUNICATION) && (*sampleRate == 8000)) {
+        ALOGV("Create Audio stream Voip \n");
+        AudioStreamInVoip* inVoip = new AudioStreamInVoip();
+        status_t lStatus = NO_ERROR;
+        lStatus =  inVoip->set(this, devices, format, channels, sampleRate, acoustic_flags);
+        if (status) {
+            *status = lStatus;
+        }
+        if (lStatus != NO_ERROR) {
+            ALOGE(" Error creating voip input \n");
+            mLock.unlock();
+            delete inVoip;
+            return 0;
+        }
+        mVoipInputs.add(inVoip);
+        mLock.unlock();
+        if (mVoipOutActive) {
+            inVoip->mSetupDevice = true;
+            setupDeviceforVoipCall(true);
+        }
+        return inVoip;
+    } else
+#endif /*QCOM_VOIP_ENABLED*/
+    {
+        AudioStreamInMSM72xx* in = new AudioStreamInMSM72xx();
+        status_t lStatus = in->set(this, devices, format, channels, sampleRate, acoustic_flags);
+        if (status) {
+            *status = lStatus;
+        }
+        if (lStatus != NO_ERROR) {
+            mLock.unlock();
+            delete in;
+            return 0;
+        }
+
+        mInputs.add(in);
+        mLock.unlock();
+        return in;
+    }
+
+}
+
+void AudioHardware::closeInputStream(AudioStreamIn* in) {
+    Mutex::Autolock lock(mLock);
+
+    ssize_t index = -1;
+    if((index = mInputs.indexOf((AudioStreamInMSM72xx *)in)) >= 0) {
+        ALOGV("closeInputStream AudioStreamInMSM72xx");
+        mLock.unlock();
+        delete mInputs[index];
+        mLock.lock();
+        mInputs.removeAt(index);
+    }
+#ifdef QCOM_VOIP_ENABLED
+    else if ((index = mVoipInputs.indexOf((AudioStreamInVoip *)in)) >= 0) {
+        ALOGV("closeInputStream mVoipInputs");
+        mLock.unlock();
+        delete mVoipInputs[index];
+        mLock.lock();
+        mVoipInputs.removeAt(index);
+    }
+#endif /*QCOM_VOIP_ENABLED*/
+    else {
+        ALOGE("Attempt to close invalid input stream");
+    }
+}
+
+status_t AudioHardware::setMode(int mode)
+{
+    status_t status = AudioHardwareBase::setMode(mode);
+    if (status == NO_ERROR) {
+        // make sure that doAudioRouteOrMute() is called by doRouting()
+        // even if the new device selected is the same as current one.
+        clearCurDevice();
+    }
+    return status;
+}
+
+bool AudioHardware::checkOutputStandby()
+{
+    if (mOutput)
+        if (!mOutput->checkStandby())
+            return false;
+
+    return true;
+}
+
+status_t AudioHardware::setMicMute(bool state)
+{
+    Mutex::Autolock lock(mLock);
+    return setMicMute_nosync(state);
+}
+
+// always call with mutex held
+status_t AudioHardware::setMicMute_nosync(bool state)
+{
+    if (mMicMute != state) {
+        mMicMute = state;
+        return doAudioRouteOrMute(SND_DEVICE_CURRENT);
+    }
+    return NO_ERROR;
+}
+
+status_t AudioHardware::getMicMute(bool* state)
+{
+    *state = mMicMute;
+    return NO_ERROR;
+}
+
+status_t AudioHardware::setParameters(const String8& keyValuePairs)
+{
+    AudioParameter param = AudioParameter(keyValuePairs);
+    String8 value;
+    String8 key;
+
+    const char BT_NREC_KEY[] = "bt_headset_nrec";
+    const char BT_NAME_KEY[] = "bt_headset_name";
+    const char BT_NREC_VALUE_ON[] = "on";
+#ifdef SRS_PROCESSING
+    int to_set=0;
+    ALOGV("setParameters() %s", keyValuePairs.string());
+    if(strncmp("SRS_Buffer", keyValuePairs.string(), 10) == 0) {
+        int SRSptr = 0;
+        String8 keySRSG  = String8("SRS_BufferG"), keySRSW  = String8("SRS_BufferW"),
+          keySRSC  = String8("SRS_BufferC"), keySRSHP = String8("SRS_BufferHP"),
+          keySRSP  = String8("SRS_BufferP"), keySRSHL = String8("SRS_BufferHL");
+        if (param.getInt(keySRSG, SRSptr) == NO_ERROR) {
+            SRSParamsG = (void*)SRSptr;
+            to_set |= SRS_PARAMS_G;
+        } else if (param.getInt(keySRSW, SRSptr) == NO_ERROR) {
+            SRSParamsW = (void*)SRSptr;
+            to_set |= SRS_PARAMS_W;
+        } else if (param.getInt(keySRSC, SRSptr) == NO_ERROR) {
+            SRSParamsC = (void*)SRSptr;
+            to_set |= SRS_PARAMS_C;
+        } else if (param.getInt(keySRSHP, SRSptr) == NO_ERROR) {
+            SRSParamsHP = (void*)SRSptr;
+            to_set |= SRS_PARAMS_HP;
+        } else if (param.getInt(keySRSP, SRSptr) == NO_ERROR) {
+            SRSParamsP = (void*)SRSptr;
+            to_set |= SRS_PARAMS_P;
+        } else if (param.getInt(keySRSHL, SRSptr) == NO_ERROR) {
+            SRSParamsHL = (void*)SRSptr;
+            to_set |= SRS_PARAMS_HL;
+        }
+
+        ALOGD("SetParam SRS flags=0x%x", to_set);
+
+        if(hpcm_playback_in_progress
+#ifdef QCOM_TUNNEL_LPA_ENABLED
+         || lpa_playback_in_progress
+#endif
+        ) {
+            msm72xx_enable_srs(to_set, true);
+        }
+
+        if(SRSptr)
+            return NO_ERROR;
+
+    }
+#endif /*SRS_PROCESSING*/
+    if (keyValuePairs.length() == 0) return BAD_VALUE;
+
+    key = String8(BT_NREC_KEY);
+    if (param.get(key, value) == NO_ERROR) {
+        if (value == BT_NREC_VALUE_ON) {
+            mBluetoothNrec = true;
+        } else {
+            mBluetoothNrec = false;
+            ALOGI("Turning noise reduction and echo cancellation off for BT "
+                 "headset");
+        }
+    }
+    key = String8(BTHEADSET_VGS);
+    if (param.get(key, value) == NO_ERROR) {
+        if (value == BT_NREC_VALUE_ON) {
+            mBluetoothVGS = true;
+        } else {
+            mBluetoothVGS = false;
+        }
+    }
+    key = String8(BT_NAME_KEY);
+    if (param.get(key, value) == NO_ERROR) {
+        mBluetoothId = 0;
+        for (int i = 0; i < mNumSndEndpoints; i++) {
+            if (!strcasecmp(value.string(), mSndEndpoints[i].name)) {
+                mBluetoothId = mSndEndpoints[i].id;
+                ALOGI("Using custom acoustic parameters for %s", value.string());
+                break;
+            }
+        }
+        if (mBluetoothId == 0) {
+            ALOGI("Using default acoustic parameters "
+                 "(%s not in acoustic database)", value.string());
+            doRouting(NULL);
+        }
+    }
+
+    key = String8(DUALMIC_KEY);
+    if (param.get(key, value) == NO_ERROR) {
+        if (value == "true") {
+            mDualMicEnabled = true;
+            ALOGI("DualMike feature Enabled");
+        } else {
+            mDualMicEnabled = false;
+            ALOGI("DualMike feature Disabled");
+        }
+        doRouting(NULL);
+    }
+
+    key = String8(TTY_MODE_KEY);
+    if (param.get(key, value) == NO_ERROR) {
+        if (value == "full") {
+            mTtyMode = TTY_FULL;
+        } else if (value == "hco") {
+            mTtyMode = TTY_HCO;
+        } else if (value == "vco") {
+            mTtyMode = TTY_VCO;
+        } else {
+            mTtyMode = TTY_OFF;
+        }
+        if(mMode != AudioSystem::MODE_IN_CALL){
+           return NO_ERROR;
+        }
+        ALOGI("Changed TTY Mode=%s", value.string());
+        if((mMode == AudioSystem::MODE_IN_CALL) &&
+           (mCurSndDevice == SND_DEVICE_HEADSET))
+           doRouting(NULL);
+    }
+#ifdef QCOM_VOIP_ENABLED
+    key = String8(VOIPRATE_KEY);
+    if (param.get(key, value) == NO_ERROR) {
+        mVoipBitRate = atoi(value);
+        ALOGI("VOIP Bitrate =%d", mVoipBitRate);
+        param.remove(key);
+    }
+#endif /*QCOM_VOIP_ENABLED*/
+    return NO_ERROR;
+}
+#ifdef QCOM_VOIP_ENABLED
+
+uint32_t AudioHardware::getMvsMode(int format, int rate)
+{
+    switch(format) {
+    case AudioSystem::PCM_16_BIT:
+         if(rate == AUDIO_HW_VOIP_SAMPLERATE_8K) {
+            return MVS_MODE_PCM;
+        } else if(rate== AUDIO_HW_VOIP_SAMPLERATE_16K) {
+            return MVS_MODE_PCM_WB;
+        } else {
+            return MVS_MODE_PCM;
+        }
+        break;
+    case AudioSystem::AMR_NB:
+        return MVS_MODE_AMR;
+        break;
+    case AudioSystem::AMR_WB:
+        return MVS_MODE_AMR_WB;
+        break;
+    case AudioSystem::EVRC:
+        return   MVS_MODE_IS127;
+        break;
+    case AudioSystem::EVRCB:
+        return MVS_MODE_4GV_NB;
+        break;
+    case AudioSystem::EVRCWB:
+        return MVS_MODE_4GV_WB;
+        break;
+    default:
+        return BAD_INDEX;
+    }
+}
+
+uint32_t AudioHardware::getMvsRateType(uint32_t mvsMode, uint32_t *rateType)
+{
+    int ret = 0;
+
+    switch (mvsMode) {
+    case MVS_MODE_AMR: {
+        switch (mVoipBitRate) {
+        case 4750:
+            *rateType = MVS_AMR_MODE_0475;
+            break;
+        case 5150:
+            *rateType = MVS_AMR_MODE_0515;
+            break;
+        case 5900:
+            *rateType = MVS_AMR_MODE_0590;
+            break;
+        case 6700:
+            *rateType = MVS_AMR_MODE_0670;
+            break;
+        case 7400:
+            *rateType = MVS_AMR_MODE_0740;
+            break;
+        case 7950:
+            *rateType = MVS_AMR_MODE_0795;
+            break;
+        case 10200:
+            *rateType = MVS_AMR_MODE_1020;
+            break;
+        case 12200:
+            *rateType = MVS_AMR_MODE_1220;
+            break;
+        default:
+            ALOGD("wrong rate for AMR NB.\n");
+            ret = -EINVAL;
+        break;
+        }
+        break;
+    }
+    case MVS_MODE_AMR_WB: {
+        switch (mVoipBitRate) {
+        case 6600:
+            *rateType = MVS_AMR_MODE_0660;
+            break;
+        case 8850:
+            *rateType = MVS_AMR_MODE_0885;
+            break;
+        case 12650:
+            *rateType = MVS_AMR_MODE_1265;
+            break;
+        case 14250:
+            *rateType = MVS_AMR_MODE_1425;
+            break;
+        case 15850:
+            *rateType = MVS_AMR_MODE_1585;
+            break;
+        case 18250:
+            *rateType = MVS_AMR_MODE_1825;
+            break;
+        case 19850:
+            *rateType = MVS_AMR_MODE_1985;
+            break;
+        case 23050:
+            *rateType = MVS_AMR_MODE_2305;
+            break;
+        case 23850:
+            *rateType = MVS_AMR_MODE_2385;
+            break;
+        default:
+            ALOGD("wrong rate for AMR_WB.\n");
+            ret = -EINVAL;
+            break;
+        }
+    break;
+    }
+    case MVS_MODE_PCM:
+    case MVS_MODE_PCM_WB:
+        *rateType = 0;
+        break;
+    case MVS_MODE_IS127:
+    case MVS_MODE_4GV_NB:
+    case MVS_MODE_4GV_WB: {
+        switch (mVoipBitRate) {
+        case MVS_VOC_0_RATE:
+        case MVS_VOC_8_RATE:
+        case MVS_VOC_4_RATE:
+        case MVS_VOC_2_RATE:
+        case MVS_VOC_1_RATE:
+            *rateType = mVoipBitRate;
+            break;
+        default:
+            ALOGE("wrong rate for IS127/4GV_NB/WB.\n");
+            ret = -EINVAL;
+            break;
+        }
+        break;
+    }
+        default:
+        ALOGE("wrong mode type.\n");
+        ret = -EINVAL;
+    }
+    ALOGD("mode=%d, rate=%u, rateType=%d\n",
+        mvsMode, mVoipBitRate, *rateType);
+    return ret;
+}
+#endif /*QCOM_VOIP_ENABLED*/
+String8 AudioHardware::getParameters(const String8& keys)
+{
+    AudioParameter param = AudioParameter(keys);
+    String8 value;
+
+    String8 key = String8(DUALMIC_KEY);
+
+    if (param.get(key, value) == NO_ERROR) {
+        value = String8(mDualMicEnabled ? "true" : "false");
+        param.add(key, value);
+    }
+
+    key = String8(BTHEADSET_VGS);
+    if (param.get(key, value) == NO_ERROR) {
+        if(mBluetoothVGS)
+           param.addInt(String8("isVGS"), true);
+    }
+
+    key = String8("tunneled-input-formats");
+    if ( param.get(key,value) == NO_ERROR ) {
+        param.addInt(String8("AMR"), true );
+        if (mMode == AudioSystem::MODE_IN_CALL) {
+            param.addInt(String8("QCELP"), true );
+            param.addInt(String8("EVRC"), true );
+        }
+    }
+#ifdef QCOM_FM_ENABLED
+    key = String8("Fm-radio");
+    if ( param.get(key,value) == NO_ERROR ) {
+        if (IsFmon()||(mCurSndDevice == SND_DEVICE_FM_ANALOG_STEREO_HEADSET)){
+            param.addInt(String8("isFMON"), true );
+        }
+    }
+#endif
+    key = String8(ECHO_SUPRESSION);
+    if (param.get(key, value) == NO_ERROR) {
+        value = String8("yes");
+        param.add(key, value);
+    }
+
+    ALOGV("AudioHardware::getParameters() %s", param.toString().string());
+    return param.toString();
+}
+
+int check_and_set_audpp_parameters(char *buf, int size)
+{
+    char *p, *ps;
+    static const char *const seps = ",";
+    int table_num;
+    int i, j;
+    int device_id = 0;
+    int samp_index = 0;
+    eq_filter_type eq[12];
+    int fd;
+    void *audioeq;
+    void *(*eq_cal)(int32_t, int32_t, int32_t, uint16_t, int32_t, int32_t *, int32_t *, uint16_t *);
+    uint16_t numerator[6];
+    uint16_t denominator[4];
+    uint16_t shift[2];
+
+    if ((buf[0] == 'A') && ((buf[1] == '1') || (buf[1] == '2') || (buf[1] == '3'))) {
+        /* IIR filter */
+        if(buf[1] == '1') device_id=0;
+        if(buf[1] == '2') device_id=1;
+        if(buf[1] == '3') device_id=2;
+        if (!(p = strtok(buf, ",")))
+            goto token_err;
+
+        /* Table header */
+        table_num = strtol(p + 1, &ps, 10);
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        /* Table description */
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+
+        for (i = 0; i < 48; i++) {
+            iir_cfg[device_id].iir_params[i] = (uint16_t)strtol(p, &ps, 16);
+            if (!(p = strtok(NULL, seps)))
+                goto token_err;
+        }
+        rx_iir_flag[device_id] = (uint16_t)strtol(p, &ps, 16);
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        iir_cfg[device_id].num_bands = (uint16_t)strtol(p, &ps, 16);
+
+    } else if ((buf[0] == 'B') && ((buf[1] == '1') || (buf[1] == '2') || (buf[1] == '3'))) {
+        /* This is the ADRC record we are looking for.  Tokenize it */
+        if(buf[1] == '1') device_id=0;
+        if(buf[1] == '2') device_id=1;
+        if(buf[1] == '3') device_id=2;
+        adrc_filter_exists[device_id] = true;
+        if (!(p = strtok(buf, ",")))
+            goto token_err;
+
+        /* Table header */
+        table_num = strtol(p + 1, &ps, 10);
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+
+        /* Table description */
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        adrc_flag[device_id] = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        adrc_cfg[device_id].adrc_params[0] = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        adrc_cfg[device_id].adrc_params[1] = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        adrc_cfg[device_id].adrc_params[2] = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        adrc_cfg[device_id].adrc_params[3] = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        adrc_cfg[device_id].adrc_params[4] = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        adrc_cfg[device_id].adrc_params[5] = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        adrc_cfg[device_id].adrc_params[6] = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        adrc_cfg[device_id].adrc_params[7] = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+
+    } else if (buf[0] == 'C' && ((buf[1] == '1') || (buf[1] == '2') || (buf[1] == '3'))) {
+        /* This is the EQ record we are looking for.  Tokenize it */
+        if(buf[1] == '1') device_id=0;
+        if(buf[1] == '2') device_id=1;
+        if(buf[1] == '3') device_id=2;
+        if (!(p = strtok(buf, ",")))
+            goto token_err;
+
+        /* Table header */
+        table_num = strtol(p + 1, &ps, 10);
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        /* Table description */
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+
+        eq_flag[device_id] = (uint16_t)strtol(p, &ps, 16);
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        ALOGI("EQ flag = %02x.", eq_flag[device_id]);
+
+        audioeq = ::dlopen("/system/lib/libaudioeq.so", RTLD_NOW);
+        if (audioeq == NULL) {
+            ALOGE("audioeq library open failure");
+            return -1;
+        }
+        eq_cal = (void *(*) (int32_t, int32_t, int32_t, uint16_t, int32_t, int32_t *, int32_t *, uint16_t *))::dlsym(audioeq, "audioeq_calccoefs");
+        memset(&equalizer[device_id], 0, sizeof(eqalizer));
+        /* Temp add the bands here */
+        equalizer[device_id].bands = 8;
+        for (i = 0; i < equalizer[device_id].bands; i++) {
+
+            eq[i].gain = (uint16_t)strtol(p, &ps, 16);
+
+            if (!(p = strtok(NULL, seps)))
+                goto token_err;
+            eq[i].freq = (uint16_t)strtol(p, &ps, 16);
+
+            if (!(p = strtok(NULL, seps)))
+                goto token_err;
+            eq[i].type = (uint16_t)strtol(p, &ps, 16);
+
+            if (!(p = strtok(NULL, seps)))
+                goto token_err;
+            eq[i].qf = (uint16_t)strtol(p, &ps, 16);
+
+            if (!(p = strtok(NULL, seps)))
+                goto token_err;
+
+            eq_cal(eq[i].gain, eq[i].freq, 48000, eq[i].type, eq[i].qf, (int32_t*)numerator, (int32_t *)denominator, shift);
+            for (j = 0; j < 6; j++) {
+                equalizer[device_id].params[ ( i * 6) + j] = numerator[j];
+            }
+            for (j = 0; j < 4; j++) {
+                equalizer[device_id].params[(equalizer[device_id].bands * 6) + (i * 4) + j] = denominator[j];
+            }
+            equalizer[device_id].params[(equalizer[device_id].bands * 10) + i] = shift[0];
+        }
+        ::dlclose(audioeq);
+
+    } else if ((buf[0] == 'D') && ((buf[1] == '1') || (buf[1] == '2') || (buf[1] == '3'))) {
+     /* This is the MB_ADRC record we are looking for.  Tokenize it */
+        if(buf[1] == '1') device_id=0;
+        if(buf[1] == '2') device_id=1;
+        if(buf[1] == '3') device_id=2;
+        mbadrc_filter_exists[device_id] = true;
+        if (!(p = strtok(buf, ",")))
+            goto token_err;
+          /* Table header */
+        table_num = strtol(p + 1, &ps, 10);
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+
+        /* Table description */
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        mbadrc_cfg[device_id].num_bands = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        mbadrc_cfg[device_id].down_samp_level = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        mbadrc_cfg[device_id].adrc_delay = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        mbadrc_cfg[device_id].ext_buf_size = (uint16_t)strtol(p, &ps, 16);
+        int ext_buf_count = mbadrc_cfg[device_id].ext_buf_size / 2;
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        mbadrc_cfg[device_id].ext_partition = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        mbadrc_cfg[device_id].ext_buf_msw = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        mbadrc_cfg[device_id].ext_buf_lsw = (uint16_t)strtol(p, &ps, 16);
+
+        for(i = 0;i < mbadrc_cfg[device_id].num_bands; i++) {
+            for(j = 0; j < 10; j++) {
+                if (!(p = strtok(NULL, seps)))
+                    goto token_err;
+                mbadrc_cfg[device_id].adrc_band[i].adrc_band_params[j] = (uint16_t)strtol(p, &ps, 16);
+            }
+        }
+
+        for(i = 0;i < mbadrc_cfg[device_id].ext_buf_size/2; i++) {
+            if (!(p = strtok(NULL, seps)))
+                goto token_err;
+            mbadrc_cfg[device_id].ext_buf.buff[i] = (uint16_t)strtol(p, &ps, 16);
+        }
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+
+        mbadrc_flag[device_id] = (uint16_t)strtol(p, &ps, 16);
+        ALOGV("MBADRC flag = %02x.", mbadrc_flag[device_id]);
+    }else if ((buf[0] == 'E') || (buf[0] == 'F') || (buf[0] == 'G')){
+     //Pre-Processing Features TX_IIR,NS,AGC
+        switch (buf[1]) {
+                case '1':
+                        samp_index = 0;
+                        break;
+                case '2':
+                        samp_index = 1;
+                        break;
+                case '3':
+                        samp_index = 2;
+                        break;
+                case '4':
+                        samp_index = 3;
+                        break;
+                case '5':
+                        samp_index = 4;
+                        break;
+                case '6':
+                        samp_index = 5;
+                        break;
+                case '7':
+                        samp_index = 6;
+                        break;
+                case '8':
+                        samp_index = 7;
+                        break;
+                case '9':
+                        samp_index = 8;
+                        break;
+                default:
+                        return -EINVAL;
+                        break;
+        }
+
+        if (buf[0] == 'E')  {
+        /* TX_IIR filter */
+        if (!(p = strtok(buf, ","))){
+            goto token_err;}
+
+        /* Table header */
+        table_num = strtol(p + 1, &ps, 10);
+        if (!(p = strtok(NULL, seps))){
+            goto token_err;}
+        /* Table description */
+        if (!(p = strtok(NULL, seps))){
+            goto token_err;}
+
+        for (i = 0; i < 48; i++) {
+            j = (i >= 40)? i : ((i % 2)? (i - 1) : (i + 1));
+            tx_iir_cfg[samp_index].iir_params[j] = (uint16_t)strtol(p, &ps, 16);
+            if (!(p = strtok(NULL, seps))){
+                goto token_err;}
+        }
+
+        tx_iir_cfg[samp_index].active_flag = (uint16_t)strtol(p, &ps, 16);
+        if (!(p = strtok(NULL, seps))){
+            goto token_err;}
+
+        txiir_flag[device_id] = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        tx_iir_cfg[samp_index].num_bands = (uint16_t)strtol(p, &ps, 16);
+
+        tx_iir_cfg[samp_index].cmd_id = 0;
+
+        ALOGV("TX IIR flag = %02x.", txiir_flag[device_id]);
+        if (txiir_flag[device_id] != 0)
+             enable_preproc_mask[samp_index] |= TX_IIR_ENABLE;
+        } else if(buf[0] == 'F')  {
+        /* AGC filter */
+        if (!(p = strtok(buf, ",")))
+            goto token_err;
+
+        /* Table header */
+        table_num = strtol(p + 1, &ps, 10);
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        /* Table description */
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+
+        tx_agc_cfg[samp_index].cmd_id = (uint16_t)strtol(p, &ps, 16);
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+
+        tx_agc_cfg[samp_index].tx_agc_param_mask = (uint16_t)strtol(p, &ps, 16);
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+
+        tx_agc_cfg[samp_index].tx_agc_enable_flag = (uint16_t)strtol(p, &ps, 16);
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+
+        tx_agc_cfg[samp_index].static_gain = (uint16_t)strtol(p, &ps, 16);
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+
+        tx_agc_cfg[samp_index].adaptive_gain_flag = (uint16_t)strtol(p, &ps, 16);
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+
+        for (i = 0; i < 19; i++) {
+            tx_agc_cfg[samp_index].agc_params[i] = (uint16_t)strtol(p, &ps, 16);
+            if (!(p = strtok(NULL, seps)))
+                goto token_err;
+            }
+
+        agc_flag[device_id] = (uint16_t)strtol(p, &ps, 16);
+        ALOGV("AGC flag = %02x.", agc_flag[device_id]);
+        if (agc_flag[device_id] != 0)
+            enable_preproc_mask[samp_index] |= AGC_ENABLE;
+        } else if ((buf[0] == 'G')) {
+        /* This is the NS record we are looking for.  Tokenize it */
+        if (!(p = strtok(buf, ",")))
+            goto token_err;
+
+        /* Table header */
+        table_num = strtol(p + 1, &ps, 10);
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+
+        /* Table description */
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        ns_cfg[samp_index].cmd_id = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        ns_cfg[samp_index].ec_mode_new = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        ns_cfg[samp_index].dens_gamma_n = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        ns_cfg[samp_index].dens_nfe_block_size = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        ns_cfg[samp_index].dens_limit_ns = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        ns_cfg[samp_index].dens_limit_ns_d = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        ns_cfg[samp_index].wb_gamma_e = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        ns_cfg[samp_index].wb_gamma_n = (uint16_t)strtol(p, &ps, 16);
+
+        if (!(p = strtok(NULL, seps)))
+            goto token_err;
+        ns_flag[device_id] = (uint16_t)strtol(p, &ps, 16);
+
+        ALOGV("NS flag = %02x.", ns_flag[device_id]);
+        if (ns_flag[device_id] != 0)
+            enable_preproc_mask[samp_index] |= NS_ENABLE;
+        }
+    }
+    return 0;
+
+token_err:
+    ALOGE("malformatted pcm control buffer");
+    return -EINVAL;
+}
+
+static int get_audpp_filter(void)
+{
+    struct stat st;
+    char *read_buf;
+    char *next_str, *current_str;
+    int csvfd;
+
+    ALOGI("get_audpp_filter");
+    static const char *const path =
+        "/system/etc/AudioFilter.csv";
+    csvfd = open(path, O_RDONLY);
+    if (csvfd < 0) {
+        /* failed to open normal acoustic file ... */
+        ALOGE("failed to open AUDIO_NORMAL_FILTER %s: %s (%d).",
+             path, strerror(errno), errno);
+        return -1;
+    } else ALOGI("open %s success.", path);
+
+    if (fstat(csvfd, &st) < 0) {
+        ALOGE("failed to stat %s: %s (%d).",
+             path, strerror(errno), errno);
+        close(csvfd);
+        return -1;
+    }
+
+    read_buf = (char *) mmap(0, st.st_size,
+                    PROT_READ | PROT_WRITE,
+                    MAP_PRIVATE,
+                    csvfd, 0);
+
+    if (read_buf == MAP_FAILED) {
+        ALOGE("failed to mmap parameters file: %s (%d)",
+             strerror(errno), errno);
+        close(csvfd);
+        return -1;
+    }
+
+    current_str = read_buf;
+
+    while (*current_str != (char)EOF)  {
+        int len;
+        next_str = strchr(current_str, '\n');
+        if (!next_str)
+           break;
+        len = next_str - current_str;
+        *next_str++ = '\0';
+        if (check_and_set_audpp_parameters(current_str, len)) {
+            ALOGI("failed to set audpp parameters, exiting.");
+            munmap(read_buf, st.st_size);
+            close(csvfd);
+            return -1;
+        }
+        current_str = next_str;
+    }
+
+    munmap(read_buf, st.st_size);
+    close(csvfd);
+    return 0;
+}
+#ifdef SRS_PROCESSING
+static void msm72xx_enable_srs(int flags, bool state)
+{
+    int fd = open(PCM_CTL_DEVICE, O_RDWR);
+    if (fd < 0) {
+        ALOGE("Cannot open PCM Ctl device for srs params");
+        return;
+    }
+
+    ALOGD("Enable SRS flags=0x%x state= %d",flags,state);
+    if (state == false) {
+        if(post_proc_feature_mask & SRS_ENABLE) {
+            new_post_proc_feature_mask &= SRS_DISABLE;
+            post_proc_feature_mask &= SRS_DISABLE;
+        }
+        if(SRSParamsG) {
+            unsigned short int backup = ((unsigned short int*)SRSParamsG)[2];
+            ((unsigned short int*)SRSParamsG)[2] = 0;
+            ioctl(fd, AUDIO_SET_SRS_TRUMEDIA_PARAM, SRSParamsG);
+            ((unsigned short int*)SRSParamsG)[2] = backup;
+        }
+    } else {
+        new_post_proc_feature_mask |= SRS_ENABLE;
+        post_proc_feature_mask |= SRS_ENABLE;
+        if(SRSParamsW && (flags & SRS_PARAMS_W))
+            ioctl(fd, AUDIO_SET_SRS_TRUMEDIA_PARAM, SRSParamsW);
+        if(SRSParamsC && (flags & SRS_PARAMS_C))
+            ioctl(fd, AUDIO_SET_SRS_TRUMEDIA_PARAM, SRSParamsC);
+        if(SRSParamsHP && (flags & SRS_PARAMS_HP))
+            ioctl(fd, AUDIO_SET_SRS_TRUMEDIA_PARAM, SRSParamsHP);
+        if(SRSParamsP && (flags & SRS_PARAMS_P))
+            ioctl(fd, AUDIO_SET_SRS_TRUMEDIA_PARAM, SRSParamsP);
+        if(SRSParamsHL && (flags & SRS_PARAMS_HL))
+            ioctl(fd, AUDIO_SET_SRS_TRUMEDIA_PARAM, SRSParamsHL);
+        if(SRSParamsG && (flags & SRS_PARAMS_G))
+            ioctl(fd, AUDIO_SET_SRS_TRUMEDIA_PARAM, SRSParamsG);
+    }
+
+    if (ioctl(fd, AUDIO_ENABLE_AUDPP, &post_proc_feature_mask) < 0) {
+        ALOGE("enable audpp error");
+    }
+
+    close(fd);
+}
+
+#endif /*SRS_PROCESSING*/
+static int msm72xx_enable_postproc(bool state)
+{
+    int fd;
+    int device_id=0;
+
+    char postProc[PROPERTY_VALUE_MAX];
+    property_get("audio.legacy.postproc",postProc,"0");
+
+    if(!(strcmp("true",postProc) == 0)){
+        post_proc_feature_mask &= MBADRC_DISABLE;
+        post_proc_feature_mask &= ADRC_DISABLE;
+        post_proc_feature_mask &= EQ_DISABLE;
+        post_proc_feature_mask &= RX_IIR_DISABLE;
+        ALOGV("Legacy Post Proc disabled.");
+        return 0;
+    }
+
+    if (!audpp_filter_inited)
+    {
+        ALOGE("Parsing error in AudioFilter.csv.");
+        post_proc_feature_mask &= MBADRC_DISABLE;
+        post_proc_feature_mask &= ADRC_DISABLE;
+        post_proc_feature_mask &= EQ_DISABLE;
+        post_proc_feature_mask &= RX_IIR_DISABLE;
+        return -EINVAL;
+    }
+    if(snd_device < 0) {
+        ALOGE("Enabling/Disabling post proc features for device: %d", snd_device);
+        post_proc_feature_mask &= MBADRC_DISABLE;
+        post_proc_feature_mask &= ADRC_DISABLE;
+        post_proc_feature_mask &= EQ_DISABLE;
+        post_proc_feature_mask &= RX_IIR_DISABLE;
+        return -EINVAL;
+    }
+
+    if(snd_device == SND_DEVICE_SPEAKER)
+    {
+        device_id = 0;
+        ALOGI("set device to SND_DEVICE_SPEAKER device_id=0");
+    }
+    if(snd_device == SND_DEVICE_HANDSET)
+    {
+        device_id = 1;
+        ALOGI("set device to SND_DEVICE_HANDSET device_id=1");
+    }
+    if(snd_device == SND_DEVICE_HEADSET)
+    {
+        device_id = 2;
+        ALOGI("set device to SND_DEVICE_HEADSET device_id=2");
+    }
+
+    fd = open(PCM_CTL_DEVICE, O_RDWR);
+    if (fd < 0) {
+        ALOGE("Cannot open PCM Ctl device");
+        return -EPERM;
+    }
+
+    if(mbadrc_filter_exists[device_id] && state)
+    {
+        ALOGV("MBADRC Enabled");
+        post_proc_feature_mask &= ADRC_DISABLE;
+        if ((mbadrc_flag[device_id] == 0) && (post_proc_feature_mask & MBADRC_ENABLE))
+        {
+            ALOGV("MBADRC Disable");
+            post_proc_feature_mask &= MBADRC_DISABLE;
+        }
+        else if(post_proc_feature_mask & MBADRC_ENABLE)
+        {
+            ALOGV("MBADRC Enabled %d", post_proc_feature_mask);
+
+            if (ioctl(fd, AUDIO_SET_MBADRC, &mbadrc_cfg[device_id]) < 0)
+            {
+                ALOGE("set mbadrc filter error");
+            }
+        }
+    }
+    else if (adrc_filter_exists[device_id] && state)
+    {
+        post_proc_feature_mask &= MBADRC_DISABLE;
+        ALOGV("ADRC Enabled %d", post_proc_feature_mask);
+
+        if (adrc_flag[device_id] == 0 && (post_proc_feature_mask & ADRC_ENABLE))
+            post_proc_feature_mask &= ADRC_DISABLE;
+        else if(post_proc_feature_mask & ADRC_ENABLE)
+        {
+            ALOGI("ADRC Filter ADRC FLAG = %02x.", adrc_flag[device_id]);
+            ALOGI("ADRC Filter COMP THRESHOLD = %02x.", adrc_cfg[device_id].adrc_params[0]);
+            ALOGI("ADRC Filter COMP SLOPE = %02x.", adrc_cfg[device_id].adrc_params[1]);
+            ALOGI("ADRC Filter COMP RMS TIME = %02x.", adrc_cfg[device_id].adrc_params[2]);
+            ALOGI("ADRC Filter COMP ATTACK[0] = %02x.", adrc_cfg[device_id].adrc_params[3]);
+            ALOGI("ADRC Filter COMP ATTACK[1] = %02x.", adrc_cfg[device_id].adrc_params[4]);
+            ALOGI("ADRC Filter COMP RELEASE[0] = %02x.", adrc_cfg[device_id].adrc_params[5]);
+            ALOGI("ADRC Filter COMP RELEASE[1] = %02x.", adrc_cfg[device_id].adrc_params[6]);
+            ALOGI("ADRC Filter COMP DELAY = %02x.", adrc_cfg[device_id].adrc_params[7]);
+            if (ioctl(fd, AUDIO_SET_ADRC, &adrc_cfg[device_id]) < 0)
+            {
+                ALOGE("set adrc filter error.");
+            }
+        }
+    }
+    else
+    {
+        ALOGV("MBADRC and ADRC Disabled");
+        post_proc_feature_mask &= (MBADRC_DISABLE | ADRC_DISABLE);
+    }
+
+    if (eq_flag[device_id] == 0 && (post_proc_feature_mask & EQ_ENABLE))
+        post_proc_feature_mask &= EQ_DISABLE;
+    else if ((post_proc_feature_mask & EQ_ENABLE) && state)
+    {
+        ALOGI("Setting EQ Filter");
+        if (ioctl(fd, AUDIO_SET_EQ, &equalizer[device_id]) < 0) {
+            ALOGE("set Equalizer error.");
+        }
+    }
+
+    if (rx_iir_flag[device_id] == 0 && (post_proc_feature_mask & RX_IIR_ENABLE))
+        post_proc_feature_mask &= RX_IIR_DISABLE;
+    else if ((post_proc_feature_mask & RX_IIR_ENABLE)&& state)
+    {
+        ALOGI("IIR Filter FLAG = %02x.", rx_iir_flag[device_id]);
+        ALOGI("IIR NUMBER OF BANDS = %02x.", iir_cfg[device_id].num_bands);
+        ALOGI("IIR Filter N1 = %02x.", iir_cfg[device_id].iir_params[0]);
+        ALOGI("IIR Filter N2 = %02x.",  iir_cfg[device_id].iir_params[1]);
+        ALOGI("IIR Filter N3 = %02x.",  iir_cfg[device_id].iir_params[2]);
+        ALOGI("IIR Filter N4 = %02x.",  iir_cfg[device_id].iir_params[3]);
+        ALOGI("IIR FILTER M1 = %02x.",  iir_cfg[device_id].iir_params[24]);
+        ALOGI("IIR FILTER M2 = %02x.", iir_cfg[device_id].iir_params[25]);
+        ALOGI("IIR FILTER M3 = %02x.",  iir_cfg[device_id].iir_params[26]);
+        ALOGI("IIR FILTER M4 = %02x.",  iir_cfg[device_id].iir_params[27]);
+        ALOGI("IIR FILTER M16 = %02x.",  iir_cfg[device_id].iir_params[39]);
+        ALOGI("IIR FILTER SF1 = %02x.",  iir_cfg[device_id].iir_params[40]);
+         if (ioctl(fd, AUDIO_SET_RX_IIR, &iir_cfg[device_id]) < 0)
+        {
+            ALOGE("set rx iir filter error.");
+        }
+    }
+
+    if(state){
+        ALOGI("Enabling post proc features with mask 0x%04x", post_proc_feature_mask);
+        if (ioctl(fd, AUDIO_ENABLE_AUDPP, &post_proc_feature_mask) < 0) {
+            ALOGE("enable audpp error");
+            close(fd);
+            return -EPERM;
+        }
+    } else{
+        if(post_proc_feature_mask & MBADRC_ENABLE) post_proc_feature_mask &= MBADRC_DISABLE;
+        if(post_proc_feature_mask & ADRC_ENABLE) post_proc_feature_mask &= ADRC_DISABLE;
+        if(post_proc_feature_mask & EQ_ENABLE) post_proc_feature_mask &= EQ_DISABLE;
+        if(post_proc_feature_mask & RX_IIR_ENABLE) post_proc_feature_mask &= RX_IIR_DISABLE;
+
+        ALOGI("disabling post proc features with mask 0x%04x", post_proc_feature_mask);
+        if (ioctl(fd, AUDIO_ENABLE_AUDPP, &post_proc_feature_mask) < 0) {
+            ALOGE("enable audpp error");
+            close(fd);
+            return -EPERM;
+        }
+   }
+
+   close(fd);
+   return 0;
+}
+
+static unsigned calculate_audpre_table_index(unsigned index)
+{
+    switch (index) {
+        case 48000:    return SAMP_RATE_INDX_48000;
+        case 44100:    return SAMP_RATE_INDX_44100;
+        case 32000:    return SAMP_RATE_INDX_32000;
+        case 24000:    return SAMP_RATE_INDX_24000;
+        case 22050:    return SAMP_RATE_INDX_22050;
+        case 16000:    return SAMP_RATE_INDX_16000;
+        case 12000:    return SAMP_RATE_INDX_12000;
+        case 11025:    return SAMP_RATE_INDX_11025;
+        case 8000:    return SAMP_RATE_INDX_8000;
+        default:     return -1;
+    }
+}
+size_t AudioHardware::getInputBufferSize(uint32_t sampleRate, int format, int channelCount)
+{
+    ALOGD("AudioHardware::getInputBufferSize sampleRate %d format %d channelCount %d"
+            ,sampleRate, format, channelCount);
+    if ( (format != AudioSystem::PCM_16_BIT) &&
+         (format != AudioSystem::AMR_NB)     &&
+         (format != AudioSystem::AMR_WB)     &&
+         (format != AudioSystem::EVRC)       &&
+         (format != AudioSystem::EVRCB)      &&
+         (format != AudioSystem::EVRCWB)     &&
+         (format != AudioSystem::QCELP)      &&
+         (format != AudioSystem::AAC)){
+        ALOGW("getInputBufferSize bad format: 0x%x", format);
+        return 0;
+    }
+    if (channelCount < 1 || channelCount > 2) {
+        ALOGW("getInputBufferSize bad channel count: %d", channelCount);
+        return 0;
+    }
+
+    if(format == AudioSystem::AMR_NB)
+       return 320*channelCount;
+    else if (format == AudioSystem::EVRC)
+       return 230*channelCount;
+    else if (format == AudioSystem::QCELP)
+       return 350*channelCount;
+    else if (format == AudioSystem::AAC)
+       return 2048;
+#ifdef QCOM_VOIP_ENABLED
+    else if (sampleRate == AUDIO_HW_VOIP_SAMPLERATE_8K)
+       return 320*channelCount;
+    else if (sampleRate == AUDIO_HW_VOIP_SAMPLERATE_16K)
+       return 640*channelCount;
+#endif /*QCOM_VOIP_ENABLED*/
+    else
+       return 2048*channelCount;
+}
+
+static status_t set_volume_rpc(uint32_t device,
+                               uint32_t method,
+                               uint32_t volume,
+                               int m7xsnddriverfd)
+{
+
+    ALOGD("rpc_snd_set_volume(%d, %d, %d)\n", device, method, volume);
+
+    if (device == -1UL) return NO_ERROR;
+
+    if (m7xsnddriverfd < 0) {
+        ALOGE("Can not open snd device");
+        return -EPERM;
+    }
+    /* rpc_snd_set_volume(
+     *     device,            # Any hardware device enum, including
+     *                        # SND_DEVICE_CURRENT
+     *     method,            # must be SND_METHOD_VOICE to do anything useful
+     *     volume,            # integer volume level, in range [0,5].
+     *                        # note that 0 is audible (not quite muted)
+     *  )
+     * rpc_snd_set_volume only works for in-call sound volume.
+     */
+     struct msm_snd_volume_config args;
+     args.device = device;
+     args.method = method;
+     args.volume = volume;
+
+     if (ioctl(m7xsnddriverfd, SND_SET_VOLUME, &args) < 0) {
+         ALOGE("snd_set_volume error.");
+         return -EIO;
+     }
+     return NO_ERROR;
+}
+
+status_t AudioHardware::setVoiceVolume(float v)
+{
+    if (v < 0.0) {
+        ALOGW("setVoiceVolume(%f) under 0.0, assuming 0.0\n", v);
+        v = 0.0;
+    } else if (v > 1.0) {
+        ALOGW("setVoiceVolume(%f) over 1.0, assuming 1.0\n", v);
+        v = 1.0;
+    }
+    // Added 0.1 to current volume, as in voice call Mute cannot be set as minimum volume(0.00)
+    // setting Rx volume level as 2 for minimum and 7 as max level.
+    v = 0.1 + v;
+
+    int vol = lrint(v * 3.0);
+    ALOGD("setVoiceVolume(%f)\n", v);
+    ALOGI("Setting in-call volume to %d (available range is 2 to 7)\n", vol);
+
+    if ((mCurSndDevice != -1) && ((mCurSndDevice == SND_DEVICE_TTY_HEADSET) || (mCurSndDevice == SND_DEVICE_TTY_VCO)))
+    {
+        vol = 1;
+        ALOGI("For TTY device in FULL or VCO mode, the volume level is set to: %d \n", vol);
+    }
+
+    Mutex::Autolock lock(mLock);
+    set_volume_rpc(SND_DEVICE_CURRENT, SND_METHOD_VOICE, vol, m7xsnddriverfd);
+    return NO_ERROR;
+}
+
+#ifdef QCOM_FM_ENABLED
+status_t AudioHardware::setFmVolume(float v)
+{
+    if (v < 0.0) {
+        ALOGW("setFmVolume(%f) under 0.0, assuming 0.0\n", v);
+        v = 0.0;
+    } else if (v > 1.0) {
+        ALOGW("setFmVolume(%f) over 1.0, assuming 1.0\n", v);
+        v = 1.0;
+    }
+
+    int vol = lrint(v * 7.5);
+    if (vol > 7)
+        vol = 7;
+    ALOGD("setFmVolume(%f)\n", v);
+    Mutex::Autolock lock(mLock);
+    set_volume_rpc(SND_DEVICE_CURRENT, SND_METHOD_VOICE, vol, m7xsnddriverfd);
+    return NO_ERROR;
+}
+#endif
+
+status_t AudioHardware::setMasterVolume(float v)
+{
+    Mutex::Autolock lock(mLock);
+    int vol = ceil(v * 7.0);
+    ALOGI("Set master volume to %d.\n", vol);
+    set_volume_rpc(SND_DEVICE_HANDSET, SND_METHOD_VOICE, vol, m7xsnddriverfd);
+    set_volume_rpc(SND_DEVICE_SPEAKER, SND_METHOD_VOICE, vol, m7xsnddriverfd);
+    set_volume_rpc(SND_DEVICE_BT,      SND_METHOD_VOICE, vol, m7xsnddriverfd);
+    set_volume_rpc(SND_DEVICE_HEADSET, SND_METHOD_VOICE, vol, m7xsnddriverfd);
+    set_volume_rpc(SND_DEVICE_IN_S_SADC_OUT_HANDSET, SND_METHOD_VOICE, vol, m7xsnddriverfd);
+    set_volume_rpc(SND_DEVICE_IN_S_SADC_OUT_SPEAKER_PHONE, SND_METHOD_VOICE, vol, m7xsnddriverfd);
+    set_volume_rpc(SND_DEVICE_TTY_HEADSET, SND_METHOD_VOICE, 1, m7xsnddriverfd);
+    set_volume_rpc(SND_DEVICE_TTY_VCO, SND_METHOD_VOICE, 1, m7xsnddriverfd);
+    // We return an error code here to let the audioflinger do in-software
+    // volume on top of the maximum volume that we set through the SND API.
+    // return error - software mixer will handle it
+    return -1;
+}
+
+static status_t do_route_audio_rpc(uint32_t device,
+                                   bool ear_mute, bool mic_mute, int m7xsnddriverfd)
+{
+    if (device == -1UL)
+        return NO_ERROR;
+
+    ALOGW("rpc_snd_set_device(%d, %d, %d)\n", device, ear_mute, mic_mute);
+
+    if (m7xsnddriverfd < 0) {
+        ALOGE("Can not open snd device");
+        return -EPERM;
+    }
+    // RPC call to switch audio path
+    /* rpc_snd_set_device(
+     *     device,            # Hardware device enum to use
+     *     ear_mute,          # Set mute for outgoing voice audio
+     *                        # this should only be unmuted when in-call
+     *     mic_mute,          # Set mute for incoming voice audio
+     *                        # this should only be unmuted when in-call or
+     *                        # recording.
+     *  )
+     */
+    struct msm_snd_device_config args;
+    args.device = device;
+    args.ear_mute = ear_mute ? SND_MUTE_MUTED : SND_MUTE_UNMUTED;
+    if((device != SND_DEVICE_CURRENT) && (!mic_mute)
+#ifdef QCOM_FM_ENABLED
+      &&(device != SND_DEVICE_FM_DIGITAL_STEREO_HEADSET)
+      &&(device != SND_DEVICE_FM_DIGITAL_SPEAKER_PHONE)
+      &&(device != SND_DEVICE_FM_DIGITAL_BT_A2DP_HEADSET)
+#endif
+       ) {
+        //Explicitly mute the mic to release DSP resources
+        args.mic_mute = SND_MUTE_MUTED;
+        if (ioctl(m7xsnddriverfd, SND_SET_DEVICE, &args) < 0) {
+            ALOGE("snd_set_device error.");
+            return -EIO;
+        }
+    }
+    args.mic_mute = mic_mute ? SND_MUTE_MUTED : SND_MUTE_UNMUTED;
+    if (ioctl(m7xsnddriverfd, SND_SET_DEVICE, &args) < 0) {
+        ALOGE("snd_set_device error.");
+        return -EIO;
+    }
+
+    return NO_ERROR;
+}
+
+// always call with mutex held
+status_t AudioHardware::doAudioRouteOrMute(uint32_t device)
+{
+    int rc;
+    int nEarmute=true;
+#if 0
+    if (device == (uint32_t)SND_DEVICE_BT || device == (uint32_t)SND_DEVICE_CARKIT) {
+        if (mBluetoothId) {
+            device = mBluetoothId;
+        } else if (!mBluetoothNrec) {
+            device = SND_DEVICE_BT_EC_OFF;
+        }
+    }
+#endif
+#ifdef QCOM_FM_ENABLED
+    if(IsFmon()){
+        /* FM needs both Rx path and Tx path to be unmuted */
+        nEarmute = false;
+        mMicMute = false;
+    } else
+#endif
+    if (mMode == AudioSystem::MODE_IN_CALL)
+        nEarmute = false;
+#ifdef QCOM_VOIP_ENABLED
+    else if(mMode == AudioSystem::MODE_IN_COMMUNICATION){
+        nEarmute = false;
+        ALOGW("VoipCall in MODE_IN_COMMUNICATION");
+    }
+#endif
+    rc = do_route_audio_rpc(device,
+                              nEarmute , mMicMute, m7xsnddriverfd);
+#ifdef QCOM_FM_ENABLED
+    if ((
+        (device == SND_DEVICE_FM_DIGITAL_STEREO_HEADSET) ||
+        (device == SND_DEVICE_FM_DIGITAL_SPEAKER_PHONE)  ||
+        (device == SND_DEVICE_FM_DIGITAL_BT_A2DP_HEADSET)) &&
+        (device != mCurSndDevice)) {
+        ALOGV("doAudioRouteOrMute():switch to FM mode");
+        switch_mode(MODE_FM);
+    } else if (((mCurSndDevice == SND_DEVICE_FM_DIGITAL_STEREO_HEADSET) ||
+        (mCurSndDevice == SND_DEVICE_FM_DIGITAL_SPEAKER_PHONE)  ||
+        (mCurSndDevice == SND_DEVICE_FM_DIGITAL_BT_A2DP_HEADSET)) &&
+        (device != mCurSndDevice)) {
+        ALOGV("doAudioRouteOrMute():switch to AUX PCM mode");
+        switch_mode(MODE_BTSCO);
+    }
+#endif
+    return rc;
+}
+
+#ifdef QCOM_FM_ENABLED
+bool AudioHardware::isFMAnalog()
+{
+    char value[PROPERTY_VALUE_MAX];
+    bool isAfm = false;
+
+    if (property_get("hw.fm.isAnalog", value, NULL)
+    && !strcasecmp(value, "true")){
+        isAfm = true;
+    }
+
+    return isAfm;
+}
+#endif
+status_t AudioHardware::doRouting(AudioStreamInMSM72xx *input, int outputDevice)
+{
+    /* currently this code doesn't work without the htc libacoustic */
+
+    Mutex::Autolock lock(mLock);
+    uint32_t outputDevices;
+    status_t ret = NO_ERROR;
+    int new_snd_device = -1;
+#ifdef QCOM_FM_ENABLED
+    bool enableDgtlFmDriver = false;
+#endif
+
+    if (outputDevice)
+        outputDevices = outputDevice;
+    else
+        outputDevices = mOutput->devices();
+
+    //int (*msm72xx_enable_audpp)(int);
+    //msm72xx_enable_audpp = (int (*)(int))::dlsym(acoustic, "msm72xx_enable_audpp");
+
+    if (input != NULL) {
+        uint32_t inputDevice = input->devices();
+        ALOGI("do input routing device %x\n", inputDevice);
+        // ignore routing device information when we start a recording in voice
+        // call
+        // Recording will happen through currently active tx device
+        if(inputDevice == AudioSystem::DEVICE_IN_VOICE_CALL)
+            return NO_ERROR;
+        if (inputDevice != 0) {
+            if (inputDevice & AudioSystem::DEVICE_IN_BLUETOOTH_SCO_HEADSET) {
+                ALOGI("Routing audio to Bluetooth PCM\n");
+                new_snd_device = SND_DEVICE_BT;
+            } else if (inputDevice & AudioSystem::DEVICE_IN_WIRED_HEADSET) {
+                    ALOGI("Routing audio to Wired Headset\n");
+                    new_snd_device = SND_DEVICE_HEADSET;
+#ifdef QCOM_FM_ENABLED
+            } else if (inputDevice & AudioSystem::DEVICE_IN_FM_RX_A2DP) {
+                    ALOGI("Routing audio from FM to Bluetooth A2DP\n");
+                    new_snd_device = SND_DEVICE_FM_DIGITAL_BT_A2DP_HEADSET;
+                    FmA2dpStatus=true;
+            } else if (inputDevice & AudioSystem::DEVICE_IN_FM_RX) {
+                    ALOGI("Routing audio to FM\n");
+                    enableDgtlFmDriver = true;
+#endif
+            } else {
+                if (outputDevices & AudioSystem::DEVICE_OUT_SPEAKER) {
+                    ALOGI("Routing audio to Speakerphone\n");
+                    new_snd_device = SND_DEVICE_SPEAKER;
+                    new_post_proc_feature_mask = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE | MBADRC_ENABLE);
+                } else {
+                    ALOGI("Routing audio to Handset\n");
+                    new_snd_device = SND_DEVICE_HANDSET;
+                }
+            }
+        }
+    }
+
+    // if inputDevice == 0, restore output routing
+    if (new_snd_device == -1) {
+        if (outputDevices & (outputDevices - 1)) {
+            if ((outputDevices & AudioSystem::DEVICE_OUT_SPEAKER) == 0) {
+                ALOGV("Hardware does not support requested route combination (%#X),"
+                     " picking closest possible route...", outputDevices);
+            }
+        }
+
+        if ((mTtyMode != TTY_OFF) && (mMode == AudioSystem::MODE_IN_CALL) &&
+                (outputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADSET)) {
+            if (mTtyMode == TTY_FULL) {
+                ALOGI("Routing audio to TTY FULL Mode\n");
+                new_snd_device = SND_DEVICE_TTY_HEADSET;
+            } else if (mTtyMode == TTY_VCO) {
+                ALOGI("Routing audio to TTY VCO Mode\n");
+                new_snd_device = SND_DEVICE_TTY_VCO;
+            } else if (mTtyMode == TTY_HCO) {
+                ALOGI("Routing audio to TTY HCO Mode\n");
+                new_snd_device = SND_DEVICE_TTY_HCO;
+            }
+#ifdef COMBO_DEVICE_SUPPORTED
+        } else if ((outputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADSET) &&
+                   (outputDevices & AudioSystem::DEVICE_OUT_SPEAKER)) {
+            ALOGI("Routing audio to Wired Headset and Speaker\n");
+            new_snd_device = SND_DEVICE_STEREO_HEADSET_AND_SPEAKER;
+            new_post_proc_feature_mask = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE | MBADRC_ENABLE);
+        } else if ((outputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADPHONE) &&
+                   (outputDevices & AudioSystem::DEVICE_OUT_SPEAKER)) {
+            ALOGI("Routing audio to No microphone Wired Headset and Speaker (%d,%x)\n", mMode, outputDevices);
+            new_snd_device = SND_DEVICE_STEREO_HEADSET_AND_SPEAKER;
+            new_post_proc_feature_mask = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE | MBADRC_ENABLE);
+#endif
+#ifdef QCOM_FM_ENABLED
+        } else if ((outputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADSET) &&
+                   (outputDevices & AudioSystem::DEVICE_OUT_FM)) {
+            if( !isFMAnalog() ){
+                ALOGI("Routing FM to Wired Headset\n");
+                new_snd_device = SND_DEVICE_FM_DIGITAL_STEREO_HEADSET;
+                enableDgtlFmDriver = true;
+                new_post_proc_feature_mask = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE | MBADRC_ENABLE);
+            } else{
+                ALOGW("Enabling Anlg FM + codec device\n");
+                new_snd_device = SND_DEVICE_FM_ANALOG_STEREO_HEADSET_CODEC;
+                enableDgtlFmDriver = false;
+            }
+        } else if ((outputDevices & AudioSystem::DEVICE_OUT_SPEAKER) &&
+                   (outputDevices & AudioSystem::DEVICE_OUT_FM)) {
+            ALOGI("Routing FM to Speakerphone\n");
+            new_snd_device = SND_DEVICE_FM_DIGITAL_SPEAKER_PHONE;
+            new_post_proc_feature_mask = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE | MBADRC_ENABLE);
+            enableDgtlFmDriver = true;
+        } else if ( (outputDevices & AudioSystem::DEVICE_OUT_FM) && isFMAnalog()) {
+            ALOGW("Enabling Anlg FM on wired headset\n");
+            new_snd_device = SND_DEVICE_FM_ANALOG_STEREO_HEADSET;
+            enableDgtlFmDriver = false;
+#endif
+        } else if (outputDevices &
+                   (AudioSystem::DEVICE_OUT_BLUETOOTH_SCO | AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_HEADSET)) {
+            ALOGI("Routing audio to Bluetooth PCM\n");
+            new_snd_device = SND_DEVICE_BT;
+        } else if (outputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_CARKIT) {
+            ALOGI("Routing audio to Bluetooth PCM\n");
+            new_snd_device = SND_DEVICE_CARKIT;
+        } else if (outputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADSET) {
+            ALOGI("Routing audio to Wired Headset\n");
+            new_snd_device = SND_DEVICE_HEADSET;
+            new_post_proc_feature_mask = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE | MBADRC_ENABLE);
+        } else if (outputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADPHONE) {
+            ALOGI("Routing audio to Wired Headphone\n");
+            new_snd_device = SND_DEVICE_HEADSET;
+            new_post_proc_feature_mask = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE | MBADRC_ENABLE);
+        } else if (outputDevices & AudioSystem::DEVICE_OUT_SPEAKER) {
+            ALOGI("Routing audio to Speakerphone\n");
+            new_snd_device = SND_DEVICE_SPEAKER;
+            new_post_proc_feature_mask = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE | MBADRC_ENABLE);
+        } else if (outputDevices & AudioSystem::DEVICE_OUT_EARPIECE) {
+            ALOGI("Routing audio to Handset\n");
+            new_snd_device = SND_DEVICE_HANDSET;
+            new_post_proc_feature_mask = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE | MBADRC_ENABLE);
+        }
+    }
+
+    if (mDualMicEnabled && mMode == AudioSystem::MODE_IN_CALL) {
+        if (new_snd_device == SND_DEVICE_HANDSET) {
+            ALOGI("Routing audio to handset with DualMike enabled\n");
+            new_snd_device = SND_DEVICE_IN_S_SADC_OUT_HANDSET;
+        } else if (new_snd_device == SND_DEVICE_SPEAKER) {
+            ALOGI("Routing audio to speakerphone with DualMike enabled\n");
+            new_snd_device = SND_DEVICE_IN_S_SADC_OUT_SPEAKER_PHONE;
+        }
+    }
+#ifdef QCOM_FM_ENABLED
+    if ((mFmFd == -1) && enableDgtlFmDriver ) {
+        enableFM();
+    } else if ((mFmFd != -1) && !enableDgtlFmDriver ) {
+        disableFM();
+    }
+
+    if((outputDevices  == 0) && (FmA2dpStatus == true))
+       new_snd_device = SND_DEVICE_FM_DIGITAL_BT_A2DP_HEADSET;
+#endif
+
+    if (new_snd_device != -1 && new_snd_device != mCurSndDevice) {
+        ret = doAudioRouteOrMute(new_snd_device);
+
+        //disable post proc first for previous session
+        if(hpcm_playback_in_progress
+#ifdef QCOM_TUNNEL_LPA_ENABLED
+         || lpa_playback_in_progress
+#endif
+         ) {
+            msm72xx_enable_postproc(false);
+#ifdef SRS_PROCESSING
+            msm72xx_enable_srs(SRS_PARAMS_ALL, false);
+#endif /*SRS_PROCESSING*/
+        }
+
+        //enable post proc for new device
+        snd_device = new_snd_device;
+        post_proc_feature_mask = new_post_proc_feature_mask;
+
+        if(hpcm_playback_in_progress
+#ifdef QCOM_TUNNEL_LPA_ENABLED
+         || lpa_playback_in_progress
+#endif
+         ){
+            msm72xx_enable_postproc(true);
+#ifdef SRS_PROCESSING
+            msm72xx_enable_srs(SRS_PARAMS_ALL, true);
+#endif /*SRS_PROCESSING*/
+        }
+
+        mCurSndDevice = new_snd_device;
+    }
+
+    return ret;
+}
+
+#ifdef QCOM_FM_ENABLED
+status_t AudioHardware::enableFM()
+{
+    ALOGD("enableFM");
+    status_t status = NO_INIT;
+    status = ::open(FM_DEVICE, O_RDWR);
+    if (status < 0) {
+           ALOGE("Cannot open FM_DEVICE errno: %d", errno);
+           goto Error;
+    }
+    mFmFd = status;
+
+    status = ioctl(mFmFd, AUDIO_START, 0);
+
+    if (status < 0) {
+            ALOGE("Cannot do AUDIO_START");
+            goto Error;
+    }
+    return NO_ERROR;
+
+    Error:
+    if (mFmFd >= 0) {
+        ::close(mFmFd);
+        mFmFd = -1;
+    }
+    return NO_ERROR;
+}
+
+
+status_t AudioHardware::disableFM()
+{
+    int status;
+    ALOGD("disableFM");
+    if (mFmFd >= 0) {
+        status = ioctl(mFmFd, AUDIO_STOP, 0);
+        if (status < 0) {
+                ALOGE("Cannot do AUDIO_STOP");
+        }
+        ::close(mFmFd);
+        mFmFd = -1;
+    }
+
+    return NO_ERROR;
+}
+#endif
+status_t AudioHardware::checkMicMute()
+{
+    Mutex::Autolock lock(mLock);
+    if (mMode != AudioSystem::MODE_IN_CALL) {
+        setMicMute_nosync(true);
+    }
+
+    return NO_ERROR;
+}
+
+status_t AudioHardware::dumpInternals(int fd, const Vector<String16>& args)
+{
+    const size_t SIZE = 256;
+    char buffer[SIZE];
+    String8 result;
+    result.append("AudioHardware::dumpInternals\n");
+    snprintf(buffer, SIZE, "\tmInit: %s\n", mInit? "true": "false");
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmMicMute: %s\n", mMicMute? "true": "false");
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmBluetoothNrec: %s\n", mBluetoothNrec? "true": "false");
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmBluetoothId: %d\n", mBluetoothId);
+    result.append(buffer);
+    ::write(fd, result.string(), result.size());
+    return NO_ERROR;
+}
+
+status_t AudioHardware::dump(int fd, const Vector<String16>& args)
+{
+    dumpInternals(fd, args);
+    for (size_t index = 0; index < mInputs.size(); index++) {
+        mInputs[index]->dump(fd, args);
+    }
+
+    if (mOutput) {
+        mOutput->dump(fd, args);
+    }
+    return NO_ERROR;
+}
+
+uint32_t AudioHardware::getInputSampleRate(uint32_t sampleRate)
+{
+    uint32_t i;
+    uint32_t prevDelta;
+    uint32_t delta;
+
+    for (i = 0, prevDelta = 0xFFFFFFFF; i < sizeof(inputSamplingRates)/sizeof(uint32_t); i++, prevDelta = delta) {
+        delta = abs(sampleRate - inputSamplingRates[i]);
+        if (delta > prevDelta) break;
+    }
+    // i is always > 0 here
+    return inputSamplingRates[i-1];
+}
+
+// getActiveInput_l() must be called with mLock held
+AudioHardware::AudioStreamInMSM72xx *AudioHardware::getActiveInput_l()
+{
+    for (size_t i = 0; i < mInputs.size(); i++) {
+        // return first input found not being in standby mode
+        // as only one input can be in this state
+        if (mInputs[i]->state() > AudioStreamInMSM72xx::AUDIO_INPUT_CLOSED) {
+            return mInputs[i];
+        }
+    }
+
+    return NULL;
+}
+#ifdef QCOM_VOIP_ENABLED
+status_t AudioHardware::setupDeviceforVoipCall(bool value)
+{
+    ALOGV("setupDeviceforVoipCall value %d",value);
+    if (mMode == AudioSystem::MODE_IN_CALL && value == false) {
+        ALOGE("mode already set for voice call, do not change to normal");
+        return NO_ERROR;
+    }
+
+    int mode = (value ? AudioSystem::MODE_IN_COMMUNICATION : AudioSystem::MODE_NORMAL);
+    if (setMode(mode) == BAD_VALUE) {
+        ALOGV("setMode fails");
+        return UNKNOWN_ERROR;
+    }
+
+    if (setMicMute(!value) != NO_ERROR) {
+        ALOGV("MicMute fails");
+        return UNKNOWN_ERROR;
+    }
+
+    ALOGD("Device setup sucess for VOIP call");
+
+    return NO_ERROR;
+}
+#endif /*QCOM_VOIP_ENABLED*/
+// ----------------------------------------------------------------------------
+
+
+//  VOIP stream class
+//.----------------------------------------------------------------------------
+#ifdef QCOM_VOIP_ENABLED
+AudioHardware::AudioStreamInVoip::AudioStreamInVoip() :
+    mHardware(0), mFd(-1), mState(AUDIO_INPUT_CLOSED), mRetryCount(0),
+    mFormat(AUDIO_HW_IN_FORMAT), mChannels(AUDIO_HW_IN_CHANNELS),
+    mSampleRate(AUDIO_HW_VOIP_SAMPLERATE_8K), mBufferSize(AUDIO_HW_VOIP_BUFFERSIZE_8K),
+    mAcoustics((AudioSystem::audio_in_acoustics)0), mDevices(0), mSetupDevice(false)
+{
+}
+
+
+status_t AudioHardware::AudioStreamInVoip::set(
+        AudioHardware* hw, uint32_t devices, int *pFormat, uint32_t *pChannels, uint32_t *pRate,
+        AudioSystem::audio_in_acoustics acoustic_flags)
+{
+    ALOGD("AudioStreamInVoip::set devices = %u format = %x pChannels = %u Rate = %u \n",
+         devices, *pFormat, *pChannels, *pRate);
+    if ((pFormat == 0) || BAD_INDEX == hw->getMvsMode(*pFormat, *pRate)) {
+        ALOGE("Audio Format (%x) not supported \n",*pFormat);
+        return BAD_VALUE;
+    }
+
+    if (*pFormat == AudioSystem::PCM_16_BIT){
+    if (pRate == 0) {
+        return BAD_VALUE;
+    }
+    uint32_t rate = hw->getInputSampleRate(*pRate);
+    if (rate != *pRate) {
+        *pRate = rate;
+        ALOGE(" sample rate does not match\n");
+        return BAD_VALUE;
+    }
+
+    if (pChannels == 0 || (*pChannels & (AudioSystem::CHANNEL_IN_MONO)) == 0) {
+        *pChannels = AUDIO_HW_IN_CHANNELS;
+        ALOGE(" Channle count does not match\n");
+        return BAD_VALUE;
+    }
+
+    if(*pRate == AUDIO_HW_VOIP_SAMPLERATE_8K)
+       mBufferSize = 320;
+    else if(*pRate == AUDIO_HW_VOIP_SAMPLERATE_16K)
+       mBufferSize = 640;
+    else
+    {
+       ALOGE(" unsupported sample rate");
+       return -1;
+    }
+
+    }
+    mHardware = hw;
+
+    ALOGD("AudioStreamInVoip::set(%d, %d, %u)", *pFormat, *pChannels, *pRate);
+
+    status_t status = NO_INIT;
+    // open driver
+    ALOGV("Check if driver is open");
+    if(mHardware->mVoipFd >= 0) {
+        mFd = mHardware->mVoipFd;
+    } else {
+        ALOGE("open mvs driver");
+        status = ::open(MVS_DEVICE, /*O_WRONLY*/ O_RDWR);
+        if (status < 0) {
+            ALOGE("Cannot open %s errno: %d",MVS_DEVICE, errno);
+            goto Error;
+        }
+        mFd = status;
+        ALOGV("VOPIstreamin : Save the fd %d \n",mFd);
+        mHardware->mVoipFd = mFd;
+        // Increment voip stream count
+
+        // configuration
+        ALOGV("get mvs config");
+        struct msm_audio_mvs_config mvs_config;
+        status = ioctl(mFd, AUDIO_GET_MVS_CONFIG, &mvs_config);
+        if (status < 0) {
+           ALOGE("Cannot read mvs config");
+           goto Error;
+        }
+
+        mvs_config.mvs_mode = mHardware->getMvsMode(*pFormat, *pRate);
+        status = mHardware->getMvsRateType(mvs_config.mvs_mode ,&mvs_config.rate_type);
+        ALOGD("set mvs config mode %d rate_type %d", mvs_config.mvs_mode, mvs_config.rate_type);
+        if (status < 0) {
+            ALOGE("Incorrect mvs type");
+            goto Error;
+        }
+        status = ioctl(mFd, AUDIO_SET_MVS_CONFIG, &mvs_config);
+        if (status < 0) {
+            ALOGE("Cannot set mvs config");
+            goto Error;
+        }
+
+        ALOGV("start mvs");
+        status = ioctl(mFd, AUDIO_START, 0);
+        if (status < 0) {
+            ALOGE("Cannot start mvs driver");
+            goto Error;
+        }
+    }
+    mFormat =  *pFormat;
+    mChannels = *pChannels;
+    mSampleRate = *pRate;
+    if(mSampleRate == AUDIO_HW_VOIP_SAMPLERATE_8K)
+       mBufferSize = 320;
+    else if(mSampleRate == AUDIO_HW_VOIP_SAMPLERATE_16K)
+       mBufferSize = 640;
+    else
+    {
+       ALOGE(" unsupported sample rate");
+       return -1;
+    }
+
+    ALOGV(" AudioHardware::AudioStreamInVoip::set after configuring devices\
+            = %u format = %d pChannels = %u Rate = %u \n",
+             devices, mFormat, mChannels, mSampleRate);
+
+    ALOGV(" Set state  AUDIO_INPUT_OPENED\n");
+    mState = AUDIO_INPUT_OPENED;
+
+    mHardware->mVoipInActive = true;
+
+    if (!acoustic)
+        return NO_ERROR;
+
+     return NO_ERROR;
+
+Error:
+    if (mFd >= 0) {
+        ::close(mFd);
+        mFd = -1;
+        mHardware->mVoipFd = -1;
+    }
+    ALOGE("Error : ret status \n");
+    return status;
+}
+
+
+AudioHardware::AudioStreamInVoip::~AudioStreamInVoip()
+{
+    ALOGV("AudioStreamInVoip destructor");
+    mHardware->mVoipInActive = false;
+    standby();
+}
+
+
+
+ssize_t AudioHardware::AudioStreamInVoip::read( void* buffer, ssize_t bytes)
+{
+//    ALOGV("AudioStreamInVoip::read(%p, %ld)", buffer, bytes);
+    if (!mHardware) return -1;
+
+    size_t count = bytes;
+    size_t totalBytesRead = 0;
+
+    if (mState < AUDIO_INPUT_OPENED) {
+       ALOGE(" reopen the device \n");
+        AudioHardware *hw = mHardware;
+        hw->mLock.lock();
+        status_t status = set(hw, mDevices, &mFormat, &mChannels, &mSampleRate, mAcoustics);
+        if (status != NO_ERROR) {
+            hw->mLock.unlock();
+            return -1;
+        }
+        hw->mLock.unlock();
+        mState = AUDIO_INPUT_STARTED;
+        bytes = 0;
+    } else {
+      ALOGV("AudioStreamInVoip::read : device is already open \n");
+    }
+
+    if(count < mBufferSize) {
+      ALOGE("read:: read size requested is less than min input buffer size");
+      return 0;
+    }
+    
+    if (!mSetupDevice) {
+        mSetupDevice = true;
+        mHardware->setupDeviceforVoipCall(true);
+    }
+    struct msm_audio_mvs_frame audio_mvs_frame;
+    memset(&audio_mvs_frame, 0, sizeof(audio_mvs_frame));
+    if(mFormat == AudioSystem::PCM_16_BIT) {
+    audio_mvs_frame.frame_type = 0;
+       while (count >= mBufferSize) {
+           audio_mvs_frame.len = mBufferSize;
+           ALOGV("Calling read count = %u mBufferSize = %u \n", count, mBufferSize);
+           int bytesRead = ::read(mFd, &audio_mvs_frame, sizeof(audio_mvs_frame));
+           ALOGV("PCM read_bytes = %d mvs\n", bytesRead);
+           if (bytesRead > 0) {
+                   memcpy(buffer+totalBytesRead, &audio_mvs_frame.voc_pkt, mBufferSize);
+                   count -= mBufferSize;
+                   totalBytesRead += mBufferSize;
+                   if(!mFirstread) {
+                       mFirstread = true;
+                       break;
+                   }
+               } else {
+                   ALOGE("retry read count = %d buffersize = %d\n", count, mBufferSize);
+                   if (errno != EAGAIN) return bytesRead;
+                   mRetryCount++;
+                   ALOGW("EAGAIN - retrying");
+               }
+       }
+    }else{
+        struct msm_audio_mvs_frame *mvsFramePtr = (msm_audio_mvs_frame *)buffer;
+        int bytesRead = ::read(mFd, &audio_mvs_frame, sizeof(audio_mvs_frame));
+        ALOGV("Non PCM read_bytes = %d frame type %d len %d\n", bytesRead, audio_mvs_frame.frame_type, audio_mvs_frame.len);
+        mvsFramePtr->frame_type = audio_mvs_frame.frame_type;
+        mvsFramePtr->len = audio_mvs_frame.len;
+        memcpy(&mvsFramePtr->voc_pkt, &audio_mvs_frame.voc_pkt, audio_mvs_frame.len);
+        totalBytesRead = bytes;
+    }
+  return bytes;
+}
+
+status_t AudioHardware::AudioStreamInVoip::standby()
+{
+    ALOGD("AudioStreamInVoip::standby");
+    Mutex::Autolock lock(mHardware->mVoipLock);
+
+    if (!mHardware) return -1;
+    ALOGE("VoipOut %d driver fd %d", mHardware->mVoipOutActive, mHardware->mVoipFd);
+    mHardware->mVoipInActive = false;
+    if (mState > AUDIO_INPUT_CLOSED && !mHardware->mVoipOutActive) {
+         int ret = 0;
+         if (mHardware->mVoipFd >= 0) {
+            ret = ioctl(mHardware->mVoipFd, AUDIO_STOP, NULL);
+            ALOGD("MVS stop returned %d %d %d\n", ret, __LINE__, mHardware->mVoipFd);
+            ::close(mFd);
+            mFd = mHardware->mVoipFd = -1;
+            mSetupDevice = false;
+            mHardware->setupDeviceforVoipCall(false);
+            ALOGD("MVS driver closed %d mFd %d", __LINE__, mHardware->mVoipFd);
+        }
+        mState = AUDIO_INPUT_CLOSED;
+    } else
+        ALOGE("Not closing MVS driver");
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioStreamInVoip::dump(int fd, const Vector<String16>& args)
+{
+    const size_t SIZE = 256;
+    char buffer[SIZE];
+    String8 result;
+    result.append("AudioStreamInVoip::dump\n");
+    snprintf(buffer, SIZE, "\tsample rate: %d\n", sampleRate());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tbuffer size: %d\n", bufferSize());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tchannels: %d\n", channels());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tformat: %d\n", format());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmHardware: %p\n", mHardware);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmFd count: %d\n", mFd);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmState: %d\n", mState);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmRetryCount: %d\n", mRetryCount);
+    result.append(buffer);
+    ::write(fd, result.string(), result.size());
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioStreamInVoip::setParameters(const String8& keyValuePairs)
+{
+    AudioParameter param = AudioParameter(keyValuePairs);
+    String8 key = String8(AudioParameter::keyRouting);
+    status_t status = NO_ERROR;
+    int device;
+    ALOGV("AudioStreamInVoip::setParameters() %s", keyValuePairs.string());
+
+    if (param.getInt(key, device) == NO_ERROR) {
+        ALOGV("set input routing %x", device);
+        if (device & (device - 1)) {
+            status = BAD_VALUE;
+        } else {
+            mDevices = device;
+            status = mHardware->doRouting(this);
+        }
+        param.remove(key);
+    }
+
+    if (param.size()) {
+        status = BAD_VALUE;
+    }
+    return status;
+}
+
+String8 AudioHardware::AudioStreamInVoip::getParameters(const String8& keys)
+{
+    AudioParameter param = AudioParameter(keys);
+    String8 value;
+    String8 key = String8(AudioParameter::keyRouting);
+
+    if (param.get(key, value) == NO_ERROR) {
+        ALOGV("get routing %x", mDevices);
+        param.addInt(key, (int)mDevices);
+    }
+
+    key = String8("voip_flag");
+    if (param.get(key, value) == NO_ERROR) {
+        param.addInt(key, true);
+    }
+
+    ALOGV("AudioStreamInVoip::getParameters() %s", param.toString().string());
+    return param.toString();
+}
+
+// getActiveInput_l() must be called with mLock held
+AudioHardware::AudioStreamInVoip*AudioHardware::getActiveVoipInput_l()
+{
+    for (size_t i = 0; i < mVoipInputs.size(); i++) {
+        // return first input found not being in standby mode
+        // as only one input can be in this state
+        if (mVoipInputs[i]->state() > AudioStreamInVoip::AUDIO_INPUT_CLOSED) {
+            return mVoipInputs[i];
+        }
+    }
+
+    return NULL;
+}
+#endif /*QCOM_VOIP_ENABLED*/
+// ---------------------------------------------------------------------------
+//  VOIP stream class end
+
+
+// ----------------------------------------------------------------------------
+
+AudioHardware::AudioStreamOutMSM72xx::AudioStreamOutMSM72xx() :
+    mHardware(0), mFd(-1), mStartCount(0), mRetryCount(0), mStandby(true), mDevices(0)
+{
+}
+
+status_t AudioHardware::AudioStreamOutMSM72xx::set(
+        AudioHardware* hw, uint32_t devices, int *pFormat, uint32_t *pChannels, uint32_t *pRate)
+{
+    int lFormat = pFormat ? *pFormat : 0;
+    uint32_t lChannels = pChannels ? *pChannels : 0;
+    uint32_t lRate = pRate ? *pRate : 0;
+
+    mHardware = hw;
+
+    // fix up defaults
+    if (lFormat == 0) lFormat = format();
+    if (lChannels == 0) lChannels = channels();
+    if (lRate == 0) lRate = sampleRate();
+
+    // check values
+    if ((lFormat != format()) ||
+        (lChannels != channels()) ||
+        (lRate != sampleRate())) {
+        if (pFormat) *pFormat = format();
+        if (pChannels) *pChannels = channels();
+        if (pRate) *pRate = sampleRate();
+        ALOGE("AudioStreamOutMSM72xx: Setting up correct values");
+        return NO_ERROR;
+    }
+
+    if (pFormat) *pFormat = lFormat;
+    if (pChannels) *pChannels = lChannels;
+    if (pRate) *pRate = lRate;
+
+    mDevices = devices;
+
+    return NO_ERROR;
+}
+
+AudioHardware::AudioStreamOutMSM72xx::~AudioStreamOutMSM72xx()
+{
+    if (mFd >= 0) close(mFd);
+}
+
+ssize_t AudioHardware::AudioStreamOutMSM72xx::write(const void* buffer, size_t bytes)
+{
+    //ALOGE("AudioStreamOutMSM72xx::write(%p, %u)", buffer, bytes);
+    status_t status = NO_INIT;
+    size_t count = bytes;
+    const uint8_t* p = static_cast<const uint8_t*>(buffer);
+
+    if (mStandby) {
+
+        // open driver
+        ALOGV("open driver");
+        status = ::open("/dev/msm_pcm_out", O_RDWR);
+        if (status < 0) {
+            ALOGE("Cannot open /dev/msm_pcm_out errno: %d", errno);
+            goto Error;
+        }
+        mFd = status;
+
+        // configuration
+        ALOGV("get config");
+        struct msm_audio_config config;
+        status = ioctl(mFd, AUDIO_GET_CONFIG, &config);
+        if (status < 0) {
+            ALOGE("Cannot read config");
+            goto Error;
+        }
+
+        ALOGV("set config");
+        config.channel_count = AudioSystem::popCount(channels());
+        config.sample_rate = sampleRate();
+        config.buffer_size = bufferSize();
+        config.buffer_count = AUDIO_HW_NUM_OUT_BUF;
+        config.type = CODEC_TYPE_PCM;
+        status = ioctl(mFd, AUDIO_SET_CONFIG, &config);
+        if (status < 0) {
+            ALOGE("Cannot set config");
+            goto Error;
+        }
+
+        ALOGV("buffer_size: %u", config.buffer_size);
+        ALOGV("buffer_count: %u", config.buffer_count);
+        ALOGV("channel_count: %u", config.channel_count);
+        ALOGV("sample_rate: %u", config.sample_rate);
+
+        // fill 2 buffers before AUDIO_START
+        mStartCount = AUDIO_HW_NUM_OUT_BUF;
+        mStandby = false;
+    }
+
+    while (count) {
+        ssize_t written = ::write(mFd, p, count);
+        if (written >= 0) {
+            count -= written;
+            p += written;
+        } else {
+            if (errno != EAGAIN) return written;
+            mRetryCount++;
+            ALOGW("EAGAIN - retry");
+        }
+    }
+
+    // start audio after we fill 2 buffers
+    if (mStartCount) {
+        if (--mStartCount == 0) {
+            ioctl(mFd, AUDIO_START, 0);
+            hpcm_playback_in_progress = true;
+            post_proc_feature_mask = new_post_proc_feature_mask;
+            //enable post processing
+            msm72xx_enable_postproc(true);
+#ifdef SRS_PROCESSING
+            msm72xx_enable_srs(SRS_PARAMS_ALL, true);
+#endif /*SRS_PROCESSING*/
+        }
+    }
+    return bytes;
+
+Error:
+    if (mFd >= 0) {
+        ::close(mFd);
+        mFd = -1;
+    }
+    // Simulate audio output timing in case of error
+    usleep(bytes * 1000000 / frameSize() / sampleRate());
+
+    return status;
+}
+
+status_t AudioHardware::AudioStreamOutMSM72xx::standby()
+{
+    status_t status = NO_ERROR;
+    if (!mStandby && mFd >= 0) {
+        //disable post processing
+        hpcm_playback_in_progress = false;
+#ifdef QCOM_TUNNEL_LPA_ENABLED
+        if(!lpa_playback_in_progress)
+#endif
+        {
+            msm72xx_enable_postproc(false);
+#ifdef SRS_PROCESSING
+            msm72xx_enable_srs(SRS_PARAMS_ALL, false);
+#endif /*SRS_PROCESSING*/
+        }
+        ::close(mFd);
+        mFd = -1;
+    }
+    mStandby = true;
+    return status;
+}
+
+status_t AudioHardware::AudioStreamOutMSM72xx::dump(int fd, const Vector<String16>& args)
+{
+    const size_t SIZE = 256;
+    char buffer[SIZE];
+    String8 result;
+    result.append("AudioStreamOutMSM72xx::dump\n");
+    snprintf(buffer, SIZE, "\tsample rate: %d\n", sampleRate());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tbuffer size: %d\n", bufferSize());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tchannels: %d\n", channels());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tformat: %d\n", format());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmHardware: %p\n", mHardware);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmFd: %d\n", mFd);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmStartCount: %d\n", mStartCount);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmRetryCount: %d\n", mRetryCount);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmStandby: %s\n", mStandby? "true": "false");
+    result.append(buffer);
+    ::write(fd, result.string(), result.size());
+    return NO_ERROR;
+}
+
+bool AudioHardware::AudioStreamOutMSM72xx::checkStandby()
+{
+    return mStandby;
+}
+
+
+status_t AudioHardware::AudioStreamOutMSM72xx::setParameters(const String8& keyValuePairs)
+{
+    AudioParameter param = AudioParameter(keyValuePairs);
+    String8 key = String8(AudioParameter::keyRouting);
+    status_t status = NO_ERROR;
+    int device;
+    ALOGV("AudioStreamOutMSM72xx::setParameters() %s", keyValuePairs.string());
+
+    if (param.getInt(key, device) == NO_ERROR) {
+        mDevices = device;
+        ALOGV("set output routing %x", mDevices);
+        status = mHardware->doRouting(NULL, device);
+        param.remove(key);
+    }
+
+    if (param.size()) {
+        status = BAD_VALUE;
+    }
+    return status;
+}
+
+String8 AudioHardware::AudioStreamOutMSM72xx::getParameters(const String8& keys)
+{
+    AudioParameter param = AudioParameter(keys);
+    String8 value;
+    String8 key = String8(AudioParameter::keyRouting);
+
+    if (param.get(key, value) == NO_ERROR) {
+        ALOGV("get routing %x", mDevices);
+        param.addInt(key, (int)mDevices);
+    }
+
+    ALOGV("AudioStreamOutMSM72xx::getParameters() %s", param.toString().string());
+    return param.toString();
+}
+
+status_t AudioHardware::AudioStreamOutMSM72xx::getRenderPosition(uint32_t *dspFrames)
+{
+    //TODO: enable when supported by driver
+    return INVALID_OPERATION;
+}
+
+#ifdef QCOM_VOIP_ENABLED
+AudioHardware::AudioStreamOutDirect::AudioStreamOutDirect() :
+    mHardware(0), mFd(-1), mStartCount(0), mRetryCount(0), mStandby(true), mDevices(0),mChannels(AudioSystem::CHANNEL_OUT_MONO),
+    mSampleRate(AUDIO_HW_VOIP_SAMPLERATE_8K), mBufferSize(AUDIO_HW_VOIP_BUFFERSIZE_8K), mFormat(AudioSystem::PCM_16_BIT)
+{
+}
+
+status_t AudioHardware::AudioStreamOutDirect::set(
+        AudioHardware* hw, uint32_t devices, int *pFormat, uint32_t *pChannels, uint32_t *pRate)
+{
+    int lFormat = pFormat ? *pFormat : 0;
+    uint32_t lChannels = pChannels ? *pChannels : 0;
+    uint32_t lRate = pRate ? *pRate : 0;
+
+    ALOGD("AudioStreamOutDirect::set  lFormat = %x lChannels= %u lRate = %u\n",
+        lFormat, lChannels, lRate );
+
+    if ((pFormat == 0) || BAD_INDEX == hw->getMvsMode(*pFormat, lRate)) {
+        ALOGE("Audio Format (%x) not supported \n",*pFormat);
+        return BAD_VALUE;
+    }
+
+
+    if (*pFormat == AudioSystem::PCM_16_BIT){
+        // fix up defaults
+        if (lFormat == 0) lFormat = format();
+        if (lChannels == 0) lChannels = channels();
+        if (lRate == 0) lRate = sampleRate();
+
+        // check values
+        if ((lFormat != format()) ||
+            (lChannels != channels())) {
+            if (pFormat) *pFormat = format();
+            if (pChannels) *pChannels = channels();
+            ALOGE("  AudioStreamOutDirect::set return bad values\n");
+            return BAD_VALUE;
+        }
+
+        if (pFormat) *pFormat = lFormat;
+        if (pChannels) *pChannels = lChannels;
+        if (pRate) *pRate = lRate;
+
+        if(lRate == AUDIO_HW_VOIP_SAMPLERATE_8K) {
+            mBufferSize = AUDIO_HW_VOIP_BUFFERSIZE_8K;
+        } else if(lRate== AUDIO_HW_VOIP_SAMPLERATE_16K) {
+            mBufferSize = AUDIO_HW_VOIP_BUFFERSIZE_16K;
+        } else {
+            ALOGE("  AudioStreamOutDirect::set return bad values\n");
+            return BAD_VALUE;
+        }
+    }
+
+    mHardware = hw;
+
+    // check values
+    mFormat =  lFormat;
+    mChannels = lChannels;
+    mSampleRate = lRate;
+
+
+    mDevices = devices;
+    mHardware->mVoipOutActive = true;
+
+    return NO_ERROR;
+}
+
+AudioHardware::AudioStreamOutDirect::~AudioStreamOutDirect()
+{
+    ALOGV("AudioStreamOutDirect destructor");
+    mHardware->mVoipOutActive = false;
+    standby();
+}
+
+ssize_t AudioHardware::AudioStreamOutDirect::write(const void* buffer, size_t bytes)
+{
+//    ALOGE("AudioStreamOutDirect::write(%p, %u)", buffer, bytes);
+    status_t status = NO_INIT;
+    size_t count = bytes;
+    const uint8_t* p = static_cast<const uint8_t*>(buffer);
+
+    if (mStandby) {
+        if(mHardware->mVoipFd >= 0) {
+            mFd = mHardware->mVoipFd;
+
+            mHardware->mVoipOutActive = true;
+            if (mHardware->mVoipInActive)
+                mHardware->setupDeviceforVoipCall(true);
+
+            mStandby = false;
+        } else {
+            // open driver
+            ALOGE("open mvs driver");
+            status = ::open(MVS_DEVICE, /*O_WRONLY*/ O_RDWR);
+            if (status < 0) {
+                ALOGE("Cannot open %s errno: %d",MVS_DEVICE, errno);
+                goto Error;
+            }
+            mFd = status;
+            mHardware->mVoipFd = mFd;
+            // configuration
+            ALOGV("get mvs config");
+            struct msm_audio_mvs_config mvs_config;
+            status = ioctl(mFd, AUDIO_GET_MVS_CONFIG, &mvs_config);
+            if (status < 0) {
+               ALOGE("Cannot read mvs config");
+               goto Error;
+            }
+
+            mvs_config.mvs_mode = mHardware->getMvsMode(mFormat, mSampleRate);
+            status = mHardware->getMvsRateType(mvs_config.mvs_mode ,&mvs_config.rate_type);
+            ALOGD("set mvs config mode %d rate_type %d", mvs_config.mvs_mode, mvs_config.rate_type);
+            if (status < 0) {
+                ALOGE("Incorrect mvs type");
+                goto Error;
+            }
+            status = ioctl(mFd, AUDIO_SET_MVS_CONFIG, &mvs_config);
+            if (status < 0) {
+                ALOGE("Cannot set mvs config");
+                goto Error;
+            }
+
+            ALOGV("start mvs config");
+            status = ioctl(mFd, AUDIO_START, 0);
+            if (status < 0) {
+                ALOGE("Cannot start mvs driver");
+                goto Error;
+            }
+            mHardware->mVoipOutActive = true;
+            if (mHardware->mVoipInActive)
+                mHardware->setupDeviceforVoipCall(true);
+
+            mStandby = false;
+        }
+    }
+    struct msm_audio_mvs_frame audio_mvs_frame;
+    memset(&audio_mvs_frame, 0, sizeof(audio_mvs_frame));
+    if (mFormat == AudioSystem::PCM_16_BIT) {
+        audio_mvs_frame.frame_type = 0;
+        while (count) {
+            audio_mvs_frame.len = mBufferSize;
+            memcpy(&audio_mvs_frame.voc_pkt, p, mBufferSize);
+            // TODO - this memcpy is rendundant can be removed.
+            ALOGV("write mvs bytes");
+            size_t written = ::write(mFd, &audio_mvs_frame, sizeof(audio_mvs_frame));
+            ALOGV(" mvs bytes written : %d \n", written);
+            if (written == 0) {
+                count -= mBufferSize;
+                p += mBufferSize;
+            } else {
+                if (errno != EAGAIN) return written;
+                mRetryCount++;
+                ALOGW("EAGAIN - retry");
+            }
+        }
+    }
+    else {
+        struct msm_audio_mvs_frame *mvsFramePtr = (msm_audio_mvs_frame *)buffer;
+        audio_mvs_frame.frame_type = mvsFramePtr->frame_type;
+        audio_mvs_frame.len = mvsFramePtr->len;
+        ALOGV("Write Frametype %d, Frame len %d", audio_mvs_frame.frame_type, audio_mvs_frame.len);
+        if(audio_mvs_frame.len < 0)
+            goto Error;
+        memcpy(&audio_mvs_frame.voc_pkt, &mvsFramePtr->voc_pkt, audio_mvs_frame.len);
+        size_t written =::write(mFd, &audio_mvs_frame, sizeof(audio_mvs_frame));
+        ALOGV(" mvs bytes written : %d bytes %d \n", written,bytes);
+    }
+
+    return bytes;
+
+Error:
+ALOGE("  write Error \n");
+    if (mFd >= 0) {
+        ::close(mFd);
+        mFd = -1;
+        mHardware->mVoipFd = -1;
+    }
+    // Simulate audio output timing in case of error
+//    usleep(bytes * 1000000 / frameSize() / sampleRate());
+
+    return status;
+}
+
+
+
+status_t AudioHardware::AudioStreamOutDirect::standby()
+{
+    ALOGD("AudioStreamOutDirect::standby()");
+    Mutex::Autolock lock(mHardware->mVoipLock);
+    status_t status = NO_ERROR;
+    int ret = 0;
+
+    ALOGD("Voipin %d driver fd %d", mHardware->mVoipInActive, mHardware->mVoipFd);
+    mHardware->mVoipOutActive = false;
+    if (mHardware->mVoipFd >= 0 && !mHardware->mVoipInActive) {
+       ret = ioctl(mHardware->mVoipFd, AUDIO_STOP, NULL);
+       ALOGD("MVS stop returned %d %d %d \n", ret, __LINE__, mHardware->mVoipFd);
+       ::close(mFd);
+       mFd = mHardware->mVoipFd = -1;
+       mHardware->setupDeviceforVoipCall(false);
+       ALOGD("MVS driver closed %d mFd %d", __LINE__, mHardware->mVoipFd);
+   } else
+        ALOGE("Not closing MVS driver");
+
+
+    mStandby = true;
+    return status;
+}
+
+status_t AudioHardware::AudioStreamOutDirect::dump(int fd, const Vector<String16>& args)
+{
+    const size_t SIZE = 256;
+    char buffer[SIZE];
+    String8 result;
+    result.append("AudioStreamOutDirect::dump\n");
+    snprintf(buffer, SIZE, "\tsample rate: %d\n", sampleRate());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tbuffer size: %d\n", bufferSize());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tchannels: %d\n", channels());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tformat: %d\n", format());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmHardware: %p\n", mHardware);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmFd: %d\n", mFd);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmStartCount: %d\n", mStartCount);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmRetryCount: %d\n", mRetryCount);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmStandby: %s\n", mStandby? "true": "false");
+    result.append(buffer);
+    ::write(fd, result.string(), result.size());
+    return NO_ERROR;
+}
+
+bool AudioHardware::AudioStreamOutDirect::checkStandby()
+{
+    return mStandby;
+}
+
+
+status_t AudioHardware::AudioStreamOutDirect::setParameters(const String8& keyValuePairs)
+{
+    AudioParameter param = AudioParameter(keyValuePairs);
+    String8 key = String8(AudioParameter::keyRouting);
+    status_t status = NO_ERROR;
+    int device;
+    ALOGV("AudioStreamOutDirect::setParameters() %s", keyValuePairs.string());
+
+    if (param.getInt(key, device) == NO_ERROR) {
+        mDevices = device;
+        ALOGV("set output routing %x", mDevices);
+        status = mHardware->doRouting(NULL);
+        param.remove(key);
+    }
+
+    if (param.size()) {
+        status = BAD_VALUE;
+    }
+    return status;
+}
+
+String8 AudioHardware::AudioStreamOutDirect::getParameters(const String8& keys)
+{
+    AudioParameter param = AudioParameter(keys);
+    String8 value;
+    String8 key = String8(AudioParameter::keyRouting);
+
+    if (param.get(key, value) == NO_ERROR) {
+        ALOGV("get routing %x", mDevices);
+        param.addInt(key, (int)mDevices);
+    }
+
+    key = String8("voip_flag");
+    if (param.get(key, value) == NO_ERROR) {
+        param.addInt(key, true);
+    }
+
+    ALOGV("AudioStreamOutDirect::getParameters() %s", param.toString().string());
+    return param.toString();
+}
+
+status_t AudioHardware::AudioStreamOutDirect::getRenderPosition(uint32_t *dspFrames)
+{
+    //TODO: enable when supported by driver
+    return INVALID_OPERATION;
+}
+#endif /*QCOM_VOIP_ENABLED*/
+
+// End AudioStreamOutDirect
+
+//.----------------------------------------------------------------------------
+int AudioHardware::AudioStreamInMSM72xx::InstanceCount = 0;
+AudioHardware::AudioStreamInMSM72xx::AudioStreamInMSM72xx() :
+    mHardware(0), mFd(-1), mState(AUDIO_INPUT_CLOSED), mRetryCount(0),
+    mFormat(AUDIO_HW_IN_FORMAT), mChannels(AUDIO_HW_IN_CHANNELS),
+    mSampleRate(AUDIO_HW_IN_SAMPLERATE), mBufferSize(AUDIO_HW_IN_BUFFERSIZE),
+    mAcoustics((AudioSystem::audio_in_acoustics)0), mDevices(0)
+{
+    AudioStreamInMSM72xx::InstanceCount++;
+}
+
+status_t AudioHardware::AudioStreamInMSM72xx::set(
+        AudioHardware* hw, uint32_t devices, int *pFormat, uint32_t *pChannels, uint32_t *pRate,
+        AudioSystem::audio_in_acoustics acoustic_flags)
+{
+    if(AudioStreamInMSM72xx::InstanceCount > 1)
+    {
+        ALOGE("More than one instance of recording not supported");
+        return -EBUSY;
+    }
+
+    if ((pFormat == 0) ||
+        ((*pFormat != AUDIO_HW_IN_FORMAT) &&
+         (*pFormat != AudioSystem::AMR_NB) &&
+         (*pFormat != AudioSystem::EVRC) &&
+         (*pFormat != AudioSystem::QCELP) &&
+         (*pFormat != AudioSystem::AAC)))
+    {
+        *pFormat = AUDIO_HW_IN_FORMAT;
+        ALOGE("audio format bad value");
+        return BAD_VALUE;
+    }
+    if (pRate == 0) {
+        return BAD_VALUE;
+    }
+    uint32_t rate = hw->getInputSampleRate(*pRate);
+    if (rate != *pRate) {
+        *pRate = rate;
+        ALOGE(" sample rate does not match\n");
+        return BAD_VALUE;
+    }
+
+    if (pChannels == 0 || (*pChannels & (AudioSystem::CHANNEL_IN_MONO | AudioSystem::CHANNEL_IN_STEREO)) == 0)
+    {
+        *pChannels = AUDIO_HW_IN_CHANNELS;
+        ALOGE(" Channel count does not match\n");
+        return BAD_VALUE;
+    }
+
+    mHardware = hw;
+
+    ALOGV("AudioStreamInMSM72xx::set(%d, %d, %u)", *pFormat, *pChannels, *pRate);
+    if (mFd >= 0) {
+        ALOGE("Audio record already open");
+        return -EPERM;
+    }
+
+    struct msm_audio_config config;
+    struct msm_audio_voicememo_config gcfg;
+    memset(&gcfg,0,sizeof(gcfg));
+    status_t status = 0;
+    if(*pFormat == AUDIO_HW_IN_FORMAT)
+    {
+    // open audio input device
+        status = ::open(PCM_IN_DEVICE, O_RDWR);
+        if (status < 0) {
+            ALOGE("Cannot open %s errno: %d", PCM_IN_DEVICE, errno);
+            goto Error;
+        }
+        mFd = status;
+
+        // configuration
+        status = ioctl(mFd, AUDIO_GET_CONFIG, &config);
+        if (status < 0) {
+            ALOGE("Cannot read config");
+           goto Error;
+        }
+
+    ALOGV("set config");
+    config.channel_count = AudioSystem::popCount(*pChannels);
+    config.sample_rate = *pRate;
+    config.buffer_size = bufferSize();
+    config.buffer_count = 2;
+        config.type = CODEC_TYPE_PCM;
+    status = ioctl(mFd, AUDIO_SET_CONFIG, &config);
+    if (status < 0) {
+        ALOGE("Cannot set config");
+        if (ioctl(mFd, AUDIO_GET_CONFIG, &config) == 0) {
+            if (config.channel_count == 1) {
+                *pChannels = AudioSystem::CHANNEL_IN_MONO;
+            } else {
+                *pChannels = AudioSystem::CHANNEL_IN_STEREO;
+            }
+            *pRate = config.sample_rate;
+        }
+        goto Error;
+    }
+
+    ALOGV("confirm config");
+    status = ioctl(mFd, AUDIO_GET_CONFIG, &config);
+    if (status < 0) {
+        ALOGE("Cannot read config");
+        goto Error;
+    }
+    ALOGV("buffer_size: %u", config.buffer_size);
+    ALOGV("buffer_count: %u", config.buffer_count);
+    ALOGV("channel_count: %u", config.channel_count);
+    ALOGV("sample_rate: %u", config.sample_rate);
+    ALOGV("input device: %x", devices);
+
+    mDevices = devices;
+    mFormat = AUDIO_HW_IN_FORMAT;
+    mChannels = *pChannels;
+    mSampleRate = config.sample_rate;
+    mBufferSize = config.buffer_size;
+    }
+    else if( (*pFormat == AudioSystem::AMR_NB) ||
+             (*pFormat == AudioSystem::EVRC) ||
+             (*pFormat == AudioSystem::QCELP))
+           {
+
+      // open vocie memo input device
+      status = ::open(VOICE_MEMO_DEVICE, O_RDWR);
+      if (status < 0) {
+          ALOGE("Cannot open Voice Memo device for read");
+          goto Error;
+      }
+      mFd = status;
+      /* Config param */
+      if(ioctl(mFd, AUDIO_GET_CONFIG, &config))
+      {
+        ALOGE(" Error getting buf config param AUDIO_GET_CONFIG \n");
+        goto  Error;
+      }
+
+      ALOGV("The Config buffer size is %d", config.buffer_size);
+      ALOGV("The Config buffer count is %d", config.buffer_count);
+      ALOGV("The Config Channel count is %d", config.channel_count);
+      ALOGV("The Config Sample rate is %d", config.sample_rate);
+
+      mDevices = devices;
+      mChannels = *pChannels;
+      mSampleRate = config.sample_rate;
+
+      if (mDevices == AudioSystem::DEVICE_IN_VOICE_CALL)
+      {
+        if ((mChannels & AudioSystem::CHANNEL_IN_VOICE_DNLINK) &&
+            (mChannels & AudioSystem::CHANNEL_IN_VOICE_UPLINK)) {
+          ALOGI("Recording Source: Voice Call Both Uplink and Downlink");
+          gcfg.rec_type = RPC_VOC_REC_BOTH;
+        } else if (mChannels & AudioSystem::CHANNEL_IN_VOICE_DNLINK) {
+          ALOGI("Recording Source: Voice Call DownLink");
+          gcfg.rec_type = RPC_VOC_REC_FORWARD;
+        } else if (mChannels & AudioSystem::CHANNEL_IN_VOICE_UPLINK) {
+          ALOGI("Recording Source: Voice Call UpLink");
+          gcfg.rec_type = RPC_VOC_REC_REVERSE;
+        }
+      }
+      else {
+        ALOGI("Recording Source: Mic/Headset");
+        gcfg.rec_type = RPC_VOC_REC_REVERSE;
+      }
+
+      gcfg.rec_interval_ms = 0; // AV sync
+      gcfg.auto_stop_ms = 0;
+
+      switch (*pFormat)
+      {
+        case AudioSystem::AMR_NB:
+        {
+          ALOGI("Recording Format: AMR_NB");
+          gcfg.capability = RPC_VOC_CAP_AMR; // RPC_VOC_CAP_AMR (64)
+          gcfg.max_rate = RPC_VOC_AMR_RATE_1220; // Max rate (Fixed frame)
+          gcfg.min_rate = RPC_VOC_AMR_RATE_1220; // Min rate (Fixed frame length)
+          gcfg.frame_format = RPC_VOC_PB_AMR; // RPC_VOC_PB_AMR
+          mFormat = AudioSystem::AMR_NB;
+          mBufferSize = 320;
+          break;
+        }
+
+        case AudioSystem::EVRC:
+        {
+          ALOGI("Recording Format: EVRC");
+          gcfg.capability = RPC_VOC_CAP_IS127;
+          gcfg.max_rate = RPC_VOC_1_RATE; // Max rate (Fixed frame)
+          gcfg.min_rate = RPC_VOC_1_RATE; // Min rate (Fixed frame length)
+          gcfg.frame_format = RPC_VOC_PB_NATIVE_QCP;
+          mFormat = AudioSystem::EVRC;
+          mBufferSize = 230;
+          break;
+        }
+
+        case AudioSystem::QCELP:
+        {
+          ALOGI("Recording Format: QCELP");
+          gcfg.capability = RPC_VOC_CAP_IS733; // RPC_VOC_CAP_AMR (64)
+          gcfg.max_rate = RPC_VOC_1_RATE; // Max rate (Fixed frame)
+          gcfg.min_rate = RPC_VOC_1_RATE; // Min rate (Fixed frame length)
+          gcfg.frame_format = RPC_VOC_PB_NATIVE_QCP;
+          mFormat = AudioSystem::QCELP;
+          mBufferSize = 350;
+          break;
+        }
+
+        default:
+        break;
+      }
+
+      gcfg.dtx_enable = 0;
+      gcfg.data_req_ms = 20;
+
+      /* Set Via  config param */
+      if (ioctl(mFd, AUDIO_SET_VOICEMEMO_CONFIG, &gcfg))
+      {
+        ALOGE("Error: AUDIO_SET_VOICEMEMO_CONFIG failed\n");
+        goto  Error;
+      }
+
+      if (ioctl(mFd, AUDIO_GET_VOICEMEMO_CONFIG, &gcfg))
+      {
+        ALOGE("Error: AUDIO_GET_VOICEMEMO_CONFIG failed\n");
+        goto  Error;
+      }
+
+      ALOGV("After set rec_type = 0x%8x\n",gcfg.rec_type);
+      ALOGV("After set rec_interval_ms = 0x%8x\n",gcfg.rec_interval_ms);
+      ALOGV("After set auto_stop_ms = 0x%8x\n",gcfg.auto_stop_ms);
+      ALOGV("After set capability = 0x%8x\n",gcfg.capability);
+      ALOGV("After set max_rate = 0x%8x\n",gcfg.max_rate);
+      ALOGV("After set min_rate = 0x%8x\n",gcfg.min_rate);
+      ALOGV("After set frame_format = 0x%8x\n",gcfg.frame_format);
+      ALOGV("After set dtx_enable = 0x%8x\n",gcfg.dtx_enable);
+      ALOGV("After set data_req_ms = 0x%8x\n",gcfg.data_req_ms);
+    }
+    else if(*pFormat == AudioSystem::AAC) {
+      // open AAC input device
+               status = ::open(PCM_IN_DEVICE, O_RDWR);
+               if (status < 0) {
+                     ALOGE("Cannot open AAC input  device for read");
+                     goto Error;
+               }
+               mFd = status;
+
+      /* Config param */
+               if(ioctl(mFd, AUDIO_GET_CONFIG, &config))
+               {
+                     ALOGE(" Error getting buf config param AUDIO_GET_CONFIG \n");
+                     goto  Error;
+               }
+
+      ALOGV("The Config buffer size is %d", config.buffer_size);
+      ALOGV("The Config buffer count is %d", config.buffer_count);
+      ALOGV("The Config Channel count is %d", config.channel_count);
+      ALOGV("The Config Sample rate is %d", config.sample_rate);
+
+      mDevices = devices;
+      mChannels = *pChannels;
+      mSampleRate = *pRate;
+      mBufferSize = 2048;
+      mFormat = *pFormat;
+
+      config.channel_count = AudioSystem::popCount(*pChannels);
+      config.sample_rate = *pRate;
+      config.type = 1; // Configuring PCM_IN_DEVICE to AAC format
+
+      if (ioctl(mFd, AUDIO_SET_CONFIG, &config)) {
+             ALOGE(" Error in setting config of msm_pcm_in device \n");
+                   goto Error;
+        }
+    }
+
+    //mHardware->setMicMute_nosync(false);
+    mState = AUDIO_INPUT_OPENED;
+
+    //if (!acoustic)
+    //    return NO_ERROR;
+
+    audpre_index = calculate_audpre_table_index(mSampleRate);
+    if(audpre_index < 0) {
+        ALOGE("wrong sampling rate");
+        status = -EINVAL;
+        goto Error;
+    }
+    return NO_ERROR;
+
+Error:
+    if (mFd >= 0) {
+        ::close(mFd);
+        mFd = -1;
+    }
+    return status;
+}
+
+static int msm72xx_enable_preproc(bool state)
+{
+    uint16_t mask = 0x0000;
+
+    if (audpp_filter_inited)
+    {
+        int fd;
+
+        fd = open(PREPROC_CTL_DEVICE, O_RDWR);
+        if (fd < 0) {
+             ALOGE("Cannot open PreProc Ctl device");
+             return -EPERM;
+        }
+
+        if (enable_preproc_mask[audpre_index] & AGC_ENABLE) {
+            /* Setting AGC Params */
+            ALOGI("AGC Filter Param1= %02x.", tx_agc_cfg[audpre_index].cmd_id);
+            ALOGI("AGC Filter Param2= %02x.", tx_agc_cfg[audpre_index].tx_agc_param_mask);
+            ALOGI("AGC Filter Param3= %02x.", tx_agc_cfg[audpre_index].tx_agc_enable_flag);
+            ALOGI("AGC Filter Param4= %02x.", tx_agc_cfg[audpre_index].static_gain);
+            ALOGI("AGC Filter Param5= %02x.", tx_agc_cfg[audpre_index].adaptive_gain_flag);
+            ALOGI("AGC Filter Param6= %02x.", tx_agc_cfg[audpre_index].agc_params[0]);
+            ALOGI("AGC Filter Param7= %02x.", tx_agc_cfg[audpre_index].agc_params[18]);
+            if ((enable_preproc_mask[audpre_index] & AGC_ENABLE) &&
+                (ioctl(fd, AUDIO_SET_AGC, &tx_agc_cfg[audpre_index]) < 0))
+            {
+                ALOGE("set AGC filter error.");
+            }
+        }
+
+        if (enable_preproc_mask[audpre_index] & NS_ENABLE) {
+            /* Setting NS Params */
+            ALOGI("NS Filter Param1= %02x.", ns_cfg[audpre_index].cmd_id);
+            ALOGI("NS Filter Param2= %02x.", ns_cfg[audpre_index].ec_mode_new);
+            ALOGI("NS Filter Param3= %02x.", ns_cfg[audpre_index].dens_gamma_n);
+            ALOGI("NS Filter Param4= %02x.", ns_cfg[audpre_index].dens_nfe_block_size);
+            ALOGI("NS Filter Param5= %02x.", ns_cfg[audpre_index].dens_limit_ns);
+            ALOGI("NS Filter Param6= %02x.", ns_cfg[audpre_index].dens_limit_ns_d);
+            ALOGI("NS Filter Param7= %02x.", ns_cfg[audpre_index].wb_gamma_e);
+            ALOGI("NS Filter Param8= %02x.", ns_cfg[audpre_index].wb_gamma_n);
+            if ((enable_preproc_mask[audpre_index] & NS_ENABLE) &&
+                (ioctl(fd, AUDIO_SET_NS, &ns_cfg[audpre_index]) < 0))
+            {
+                ALOGE("set NS filter error.");
+            }
+        }
+
+        if (enable_preproc_mask[audpre_index] & TX_IIR_ENABLE) {
+            /* Setting TX_IIR Params */
+            ALOGI("TX_IIR Filter Param1= %02x.", tx_iir_cfg[audpre_index].cmd_id);
+            ALOGI("TX_IIR Filter Param2= %02x.", tx_iir_cfg[audpre_index].active_flag);
+            ALOGI("TX_IIR Filter Param3= %02x.", tx_iir_cfg[audpre_index].num_bands);
+            ALOGI("TX_IIR Filter Param4= %02x.", tx_iir_cfg[audpre_index].iir_params[0]);
+            ALOGI("TX_IIR Filter Param5= %02x.", tx_iir_cfg[audpre_index].iir_params[1]);
+            ALOGI("TX_IIR Filter Param6 %02x.", tx_iir_cfg[audpre_index].iir_params[47]);
+            if ((enable_preproc_mask[audpre_index] & TX_IIR_ENABLE) &&
+                (ioctl(fd, AUDIO_SET_TX_IIR, &tx_iir_cfg[audpre_index]) < 0))
+            {
+               ALOGE("set TX IIR filter error.");
+            }
+        }
+
+        if (state == true) {
+            /*Setting AUDPRE_ENABLE*/
+            if (ioctl(fd, AUDIO_ENABLE_AUDPRE, &enable_preproc_mask[audpre_index]) < 0) {
+                ALOGE("set AUDPRE_ENABLE error.");
+            }
+        } else {
+            /*Setting AUDPRE_ENABLE*/
+            if (ioctl(fd, AUDIO_ENABLE_AUDPRE, &mask) < 0) {
+                ALOGE("set AUDPRE_ENABLE error.");
+            }
+        }
+        close(fd);
+    }
+
+    return NO_ERROR;
+}
+
+// ----------------------------------------------------------------------------
+// Audio Stream from LPA output
+// Start AudioSessionOutLPA
+// ----------------------------------------------------------------------------
+
+AudioHardware::AudioSessionOutLPA::AudioSessionOutLPA( AudioHardware *hw,
+                                         uint32_t   devices,
+                                         int        format,
+                                         uint32_t   channels,
+                                         uint32_t   samplingRate,
+                                         int        type,
+                                         status_t   *status)
+{
+    Mutex::Autolock autoLock(mLock);
+    // Default initilization
+	mHardware = hw;
+    ALOGE("AudioSessionOutLPA constructor");
+	mFormat             = format;
+    mSampleRate         = samplingRate;
+    mChannels           = popcount(channels);
+    mBufferSize         = LPA_BUFFER_SIZE; //TODO to check what value is correct
+    *status             = BAD_VALUE;
+
+    mPaused             = false;
+    mIsDriverStarted    = false;
+    mGenerateEOS        = true;
+    mSeeking            = false;
+    mReachedEOS         = false;
+    mSkipWrite          = false;
+    timeStarted = 0;
+    timePlayed = 0;
+
+    mInputBufferSize    = LPA_BUFFER_SIZE;
+    mInputBufferCount   = BUFFER_COUNT;
+    efd = -1;
+    mEosEventReceived   =false;
+
+    mEventThread        = NULL;
+    mEventThreadAlive   = false;
+    mKillEventThread    = false;
+    mObserver           = NULL;
+    if((format == AUDIO_FORMAT_PCM_16_BIT) && (mChannels == 0 || mChannels > 2)) {
+        ALOGE("Invalid number of channels %d", channels);
+        return;
+    }
+
+    *status = openAudioSessionDevice();
+
+    //Creates the event thread to poll events from LPA Driver
+    if (*status == NO_ERROR)
+        createEventThread();
+}
+
+AudioHardware::AudioSessionOutLPA::~AudioSessionOutLPA()
+{
+    ALOGV("AudioSessionOutLPA destructor");
+	mSkipWrite = true;
+    mWriteCv.signal();
+
+    //TODO: This might need to be Locked using Parent lock
+    reset();
+    //standby();//TODO Do we really need standby?
+
+}
+
+status_t AudioHardware::AudioSessionOutLPA::setParameters(const String8& keyValuePairs)
+{
+    AudioParameter param = AudioParameter(keyValuePairs);
+    String8 key = String8(AudioParameter::keyRouting);
+    status_t status = NO_ERROR;
+    int device;
+    ALOGV("AudioSessionOutLPA::setParameters() %s", keyValuePairs.string());
+
+    if (param.getInt(key, device) == NO_ERROR) {
+        mDevices = device;
+        ALOGV("set output routing %x", mDevices);
+        status = mHardware->doRouting(NULL, device);
+        param.remove(key);
+    }
+
+    if (param.size()) {
+        status = BAD_VALUE;
+    }
+    return status;
+}
+String8 AudioHardware::AudioSessionOutLPA::getParameters(const String8& keys)
+{
+    AudioParameter param = AudioParameter(keys);
+    String8 value;
+    String8 key = String8(AudioParameter::keyRouting);
+
+    if (param.get(key, value) == NO_ERROR) {
+        ALOGV("get routing %x", mDevices);
+        param.addInt(key, (int)mDevices);
+    }
+
+    ALOGV("AudioSessionOutLPA::getParameters() %s", param.toString().string());
+    return param.toString();
+}
+
+ssize_t AudioHardware::AudioSessionOutLPA::write(const void* buffer, size_t bytes)
+{
+    Mutex::Autolock autoLock(mLock);
+    int err;
+    ALOGV("write Empty Queue size() = %d, Filled Queue size() = %d ",
+         mEmptyQueue.size(),mFilledQueue.size());
+
+    if (mSkipWrite) {
+        mSkipWrite = false;
+        if (bytes < LPA_BUFFER_SIZE)
+            bytes = 0;
+        else
+            return 0;
+    }
+
+    if (mSkipWrite)
+        mSkipWrite = false;
+
+    //2.) Dequeue the buffer from empty buffer queue. Copy the data to be
+    //    written into the buffer. Then Enqueue the buffer to the filled
+    //    buffer queue
+    mEmptyQueueMutex.lock();
+    List<BuffersAllocated>::iterator it = mEmptyQueue.begin();
+    BuffersAllocated buf = *it;
+    mEmptyQueue.erase(it);
+    mEmptyQueueMutex.unlock();
+
+    memset(buf.memBuf, 0, bytes);
+    memcpy(buf.memBuf, buffer, bytes);
+    buf.bytesToWrite = bytes;
+
+    struct msm_audio_aio_buf aio_buf_local;
+    if ( buf.bytesToWrite > 0) {
+        memset(&aio_buf_local, 0, sizeof(msm_audio_aio_buf));
+        aio_buf_local.buf_addr = buf.memBuf;
+        aio_buf_local.buf_len = buf.bytesToWrite;
+        aio_buf_local.data_len = buf.bytesToWrite;
+        aio_buf_local.private_data = (void*) buf.memFd;
+
+        if ( (buf.bytesToWrite % 2) != 0 ) {
+            ALOGV("Increment for even bytes");
+            aio_buf_local.data_len += 1;
+        }
+        if (timeStarted == 0)
+            timeStarted = nanoseconds_to_microseconds(systemTime(SYSTEM_TIME_MONOTONIC));
+    } else {
+        /* Put the buffer back into requestQ */
+        ALOGV("mEmptyQueueMutex locking: %d", __LINE__);
+        mEmptyQueueMutex.lock();
+        ALOGV("mEmptyQueueMutex locked: %d", __LINE__);
+        mEmptyQueue.push_back(buf);
+        ALOGV("mEmptyQueueMutex unlocking: %d", __LINE__);
+        mEmptyQueueMutex.unlock();
+        ALOGV("mEmptyQueueMutex unlocked: %d", __LINE__);
+        //Post EOS in case the filled queue is empty and EOS is reached.
+        mReachedEOS = true;
+        mFilledQueueMutex.lock();
+        if (mFilledQueue.empty() && !mEosEventReceived) {
+            ALOGV("mEosEventReceived made true");
+            mEosEventReceived = true;
+            if (mObserver != NULL) {
+                ALOGV("mObserver: posting EOS");
+                mObserver->postEOS(0);
+            }
+        }
+        mFilledQueueMutex.unlock();
+        return NO_ERROR;
+    }
+    mFilledQueueMutex.lock();
+    mFilledQueue.push_back(buf);
+    mFilledQueueMutex.unlock();
+
+    ALOGV("PCM write start");
+    //3.) Write the buffer to the Driver
+    if(mIsDriverStarted) {
+       if (ioctl(afd, AUDIO_ASYNC_WRITE, &aio_buf_local) < 0 ) {
+           ALOGE("error on async write\n");
+       }
+    }
+    ALOGV("PCM write complete");
+
+    if (bytes < LPA_BUFFER_SIZE) {
+        ALOGV("Last buffer case");
+        mLock.unlock();
+        if (fsync(afd) != 0) {
+            ALOGE("fsync failed.");
+        }
+        mLock.lock();
+        mReachedEOS = true;
+    }
+
+    return NO_ERROR; //TODO Do wee need to send error
+}
+
+
+status_t AudioHardware::AudioSessionOutLPA::standby()
+{
+    ALOGD("AudioSessionOutLPA::standby()");
+    status_t status = NO_ERROR;
+    //TODO  Do we really need standby()
+    return status;
+}
+
+
+status_t AudioHardware::AudioSessionOutLPA::dump(int fd, const Vector<String16>& args)
+{
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioSessionOutLPA::setVolume(float left, float right)
+{
+   float v = (left + right) / 2;
+    if (v < 0.0) {
+        ALOGW("AudioSessionOutLPA::setVolume(%f) under 0.0, assuming 0.0\n", v);
+        v = 0.0;
+    } else if (v > 1.0) {
+        ALOGW("AudioSessionOutLPA::setVolume(%f) over 1.0, assuming 1.0\n", v);
+        v = 1.0;
+    }
+
+    // Ensure to convert the log volume back to linear for LPA
+    long vol = v * 10000;
+    ALOGV("AudioSessionOutLPA::setVolume(%f)\n", v);
+    ALOGV("Setting session volume to %ld (available range is 0 to 100)\n", vol);
+
+
+    if (ioctl(afd,AUDIO_SET_VOLUME, vol)< 0)
+        ALOGE("LPA volume set failed");
+
+    ALOGV("LPA volume set (%f) succeeded",vol);
+
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioSessionOutLPA::openAudioSessionDevice( )
+{
+    status_t status = NO_ERROR;
+
+	//It opens LPA driver
+	 ALOGE("Opening LPA pcm_dec driver");
+    afd = open("/dev/msm_pcm_lp_dec", O_WRONLY | O_NONBLOCK);
+    if ( afd < 0 ) {
+        ALOGE("pcm_lp_dec: cannot open pcm_dec device and the error is %d", errno);
+        //initCheck = false;
+        return UNKNOWN_ERROR;
+    } else {
+        //initCheck = true;
+        ALOGV("pcm_lp_dec: pcm_lp_dec Driver opened");
+    }
+
+	start();
+        bufferAlloc();
+
+	return status;
+}
+
+void AudioHardware::AudioSessionOutLPA::bufferAlloc( )
+{
+    // Allocate ION buffers
+    void *ion_buf; int32_t ion_fd;
+    struct msm_audio_ion_info ion_info;
+    //1. Open the ion_audio
+    ionfd = open("/dev/ion", O_RDONLY | O_SYNC);
+    if (ionfd < 0) {
+        ALOGE("/dev/ion open failed \n");
+        return;
+    }
+    for (int i = 0; i < mInputBufferCount; i++) {
+        ion_buf = memBufferAlloc(mInputBufferSize, &ion_fd);
+        memset(&ion_info, 0, sizeof(msm_audio_ion_info));
+        ALOGE("Registering ION with fd %d and address as %p", ion_fd, ion_buf);
+        ion_info.fd = ion_fd;
+        ion_info.vaddr = ion_buf;
+        if ( ioctl(afd, AUDIO_REGISTER_ION, &ion_info) < 0 ) {
+            ALOGE("Registration of ION with the Driver failed with fd %d and memory %x",
+                 ion_info.fd, (unsigned int)ion_info.vaddr);
+        }
+    }
+}
+
+
+void* AudioHardware::AudioSessionOutLPA::memBufferAlloc(int nSize, int32_t *ion_fd)
+{
+    void  *ion_buf = NULL;
+    void  *local_buf = NULL;
+    struct ion_fd_data fd_data;
+    struct ion_allocation_data alloc_data;
+
+    alloc_data.len =   nSize;
+    alloc_data.align = 0x1000;
+    alloc_data.flags = ION_HEAP(ION_AUDIO_HEAP_ID);
+    int rc = ioctl(ionfd, ION_IOC_ALLOC, &alloc_data);
+    if (rc) {
+        ALOGE("ION_IOC_ALLOC ioctl failed\n");
+        return ion_buf;
+    }
+    fd_data.handle = alloc_data.handle;
+
+    rc = ioctl(ionfd, ION_IOC_SHARE, &fd_data);
+    if (rc) {
+        ALOGE("ION_IOC_SHARE ioctl failed\n");
+        rc = ioctl(ionfd, ION_IOC_FREE, &(alloc_data.handle));
+        if (rc) {
+            ALOGE("ION_IOC_FREE ioctl failed\n");
+        }
+        return ion_buf;
+    }
+
+    // 2. MMAP to get the virtual address
+    ion_buf = mmap(NULL, nSize, PROT_READ | PROT_WRITE, MAP_SHARED, fd_data.fd, 0);
+    if(MAP_FAILED == ion_buf) {
+        ALOGE("mmap() failed \n");
+        close(fd_data.fd);
+        rc = ioctl(ionfd, ION_IOC_FREE, &(alloc_data.handle));
+        if (rc) {
+            ALOGE("ION_IOC_FREE ioctl failed\n");
+        }
+        return ion_buf;
+    }
+
+    local_buf = malloc(nSize);
+    if (NULL == local_buf) {
+        // unmap the corresponding ION buffer and close the fd
+        munmap(ion_buf, mInputBufferSize);
+        close(fd_data.fd);
+        rc = ioctl(ionfd, ION_IOC_FREE, &(alloc_data.handle));
+        if (rc) {
+            ALOGE("ION_IOC_FREE ioctl failed\n");
+        }
+        return NULL;
+    }
+
+    // 3. Store this information for internal mapping / maintanence
+    BuffersAllocated buf(local_buf, ion_buf, nSize, fd_data.fd, alloc_data.handle);
+    mEmptyQueue.push_back(buf);
+
+    // 4. Send the mem fd information
+    *ion_fd = fd_data.fd;
+    ALOGV("IONBufferAlloc calling with required size %d", nSize);
+    ALOGV("ION allocated is %d, fd_data.fd %d and buffer is %x", *ion_fd, fd_data.fd, (unsigned int)ion_buf);
+
+    // 5. Return the virtual address
+    return ion_buf;
+}
+
+void AudioHardware::AudioSessionOutLPA::bufferDeAlloc()
+{
+    // De-Allocate ION buffers
+    int rc = 0;
+    //Remove all the buffers from empty queue
+    mEmptyQueueMutex.lock();
+    while (!mEmptyQueue.empty())  {
+        List<BuffersAllocated>::iterator it = mEmptyQueue.begin();
+        BuffersAllocated &ionBuffer = *it;
+        struct msm_audio_ion_info ion_info;
+        ion_info.vaddr = (*it).memBuf;
+        ion_info.fd = (*it).memFd;
+        if (ioctl(afd, AUDIO_DEREGISTER_ION, &ion_info) < 0) {
+            ALOGE("ION deregister failed");
+        }
+        ALOGV("Ion Unmapping the address %p, size %d, fd %d from empty",ionBuffer.memBuf,ionBuffer.bytesToWrite,ionBuffer.memFd);
+        munmap(ionBuffer.memBuf, mInputBufferSize);
+        ALOGV("closing the ion shared fd");
+        close(ionBuffer.memFd);
+        rc = ioctl(ionfd, ION_IOC_FREE, &ionBuffer.ion_handle);
+        if (rc) {
+            ALOGE("ION_IOC_FREE ioctl failed\n");
+        }
+        // free the local buffer corresponding to ion buffer
+        free(ionBuffer.localBuf);
+        ALOGE("Removing from empty Q");
+        mEmptyQueue.erase(it);
+    }
+    mEmptyQueueMutex.unlock();
+
+    //Remove all the buffers from Filled queue
+    mFilledQueueMutex.lock();
+    while(!mFilledQueue.empty()){
+        List<BuffersAllocated>::iterator it = mFilledQueue.begin();
+        BuffersAllocated &ionBuffer = *it;
+        struct msm_audio_ion_info ion_info;
+        ion_info.vaddr = (*it).memBuf;
+        ion_info.fd = (*it).memFd;
+        if (ioctl(afd, AUDIO_DEREGISTER_ION, &ion_info) < 0) {
+            ALOGE("ION deregister failed");
+        }
+        ALOGV("Ion Unmapping the address %p, size %d, fd %d from Request",ionBuffer.memBuf,ionBuffer.bytesToWrite,ionBuffer.memFd);
+        munmap(ionBuffer.memBuf, mInputBufferSize);
+        ALOGV("closing the ion shared fd");
+        close(ionBuffer.memFd);
+        rc = ioctl(ionfd, ION_IOC_FREE, &ionBuffer.ion_handle);
+        if (rc) {
+            ALOGE("ION_IOC_FREE ioctl failed\n");
+        }
+        // free the local buffer corresponding to ion buffer
+        free(ionBuffer.localBuf);
+        ALOGV("Removing from Filled Q");
+        mFilledQueue.erase(it);
+    }
+    mFilledQueueMutex.unlock();
+    if (ionfd >= 0) {
+        close(ionfd);
+        ionfd = -1;
+    }
+}
+
+uint32_t AudioHardware::AudioSessionOutLPA::latency() const
+{
+    // Android wants latency in milliseconds.
+    return 1000;//TODO to correct the value
+}
+
+void AudioHardware::AudioSessionOutLPA::requestAndWaitForEventThreadExit()
+{
+    if (!mEventThreadAlive)
+        return;
+    mKillEventThread = true;
+    if (ioctl(afd, AUDIO_ABORT_GET_EVENT, 0) < 0) {
+        ALOGE("Audio Abort event failed");
+    }
+    pthread_join(mEventThread,NULL);
+}
+
+void * AudioHardware::AudioSessionOutLPA::eventThreadWrapper(void *me)
+{
+    static_cast<AudioSessionOutLPA *>(me)->eventThreadEntry();
+    return NULL;
+}
+
+void  AudioHardware::AudioSessionOutLPA::eventThreadEntry()
+{
+    struct msm_audio_event cur_pcmdec_event;
+    mEventThreadAlive = true;
+    int rc = 0;
+    //2.) Set the priority for the event thread
+    pid_t tid  = gettid();
+    androidSetThreadPriority(tid, ANDROID_PRIORITY_AUDIO);
+    prctl(PR_SET_NAME, (unsigned long)"HAL Audio EventThread", 0, 0, 0);
+    ALOGV("event thread created ");
+    if (mKillEventThread) {
+        mEventThreadAlive = false;
+        ALOGV("Event Thread is dying.");
+        return;
+    }
+    while (1) {
+        //Wait for an event to occur
+        rc = ioctl(afd, AUDIO_GET_EVENT, &cur_pcmdec_event);
+        ALOGE("pcm dec Event Thread rc = %d and errno is %d",rc, errno);
+
+        if ( (rc < 0) && ((errno == ENODEV) || (errno == EBADF)) ) {
+            ALOGV("AUDIO__GET_EVENT called. Exit the thread");
+            break;
+        }
+
+        switch ( cur_pcmdec_event.event_type ) {
+        case AUDIO_EVENT_WRITE_DONE:
+            {
+                ALOGE("WRITE_DONE: addr %p len %d and fd is %d\n",
+                     cur_pcmdec_event.event_payload.aio_buf.buf_addr,
+                     cur_pcmdec_event.event_payload.aio_buf.data_len,
+                     (int32_t) cur_pcmdec_event.event_payload.aio_buf.private_data);
+                Mutex::Autolock autoLock(mLock);
+                mFilledQueueMutex.lock();
+                BuffersAllocated buf = *(mFilledQueue.begin());
+                for (List<BuffersAllocated>::iterator it = mFilledQueue.begin();
+                    it != mFilledQueue.end(); ++it) {
+                    if (it->memBuf == cur_pcmdec_event.event_payload.aio_buf.buf_addr) {
+                        buf = *it;
+                        mFilledQueue.erase(it);
+                        // Post buffer to Empty Q
+                        ALOGV("mEmptyQueueMutex locking: %d", __LINE__);
+                        mEmptyQueueMutex.lock();
+                        ALOGV("mEmptyQueueMutex locked: %d", __LINE__);
+                        mEmptyQueue.push_back(buf);
+                        ALOGV("mEmptyQueueMutex unlocking: %d", __LINE__);
+                        mEmptyQueueMutex.unlock();
+                        ALOGV("mEmptyQueueMutex unlocked: %d", __LINE__);
+                        if (mFilledQueue.empty() && mReachedEOS && mGenerateEOS) {
+                            ALOGV("Posting the EOS to the observer player %p", mObserver);
+                            mEosEventReceived = true;
+                            if (mObserver != NULL) {
+                                ALOGV("mObserver: posting EOS");
+                                mObserver->postEOS(0);
+                            }
+                        }
+                        break;
+                    }
+                }
+                mFilledQueueMutex.unlock();
+                 mWriteCv.signal();
+            }
+            break;
+        case AUDIO_EVENT_SUSPEND:
+            {
+                struct msm_audio_stats stats;
+                int nBytesConsumed = 0;
+
+                ALOGV("AUDIO_EVENT_SUSPEND received\n");
+                if (!mPaused) {
+                    ALOGV("Not in paused, no need to honor SUSPEND event");
+                    break;
+                }
+                // 1. Get the Byte count that is consumed
+                if ( ioctl(afd, AUDIO_GET_STATS, &stats)  < 0 ) {
+                    ALOGE("AUDIO_GET_STATUS failed");
+                } else {
+                    ALOGV("Number of bytes consumed by DSP is %u", stats.byte_count);
+                    nBytesConsumed = stats.byte_count;
+                    }
+                    // Reset eosflag to resume playback where we actually paused
+                    mReachedEOS = false;
+                    // 3. Call AUDIO_STOP on the Driver.
+                    ALOGV("Received AUDIO_EVENT_SUSPEND and calling AUDIO_STOP");
+                    if ( ioctl(afd, AUDIO_STOP, 0) < 0 ) {
+                         ALOGE("AUDIO_STOP failed");
+                    }
+                    mIsDriverStarted = false;
+                    break;
+            }
+            break;
+        case AUDIO_EVENT_RESUME:
+            {
+                ALOGV("AUDIO_EVENT_RESUME received\n");
+            }
+            break;
+        default:
+            ALOGE("Received Invalid Event from driver\n");
+            break;
+        }
+    }
+    mEventThreadAlive = false;
+    ALOGV("Event Thread is dying.");
+}
+
+
+void AudioHardware::AudioSessionOutLPA::createEventThread()
+{
+    ALOGV("Creating Event Thread");
+    mKillEventThread = false;
+    mEventThreadAlive = true;
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+    pthread_create(&mEventThread, &attr, eventThreadWrapper, this);
+    ALOGV("Event Thread created");
+}
+
+status_t AudioHardware::AudioSessionOutLPA::start( ) //TODO YM LPA removed start time
+{
+
+    ALOGV("LPA playback start");
+    if (mPaused && mIsDriverStarted) {
+        mPaused = false;
+        if (ioctl(afd, AUDIO_PAUSE, 0) < 0) {
+            ALOGE("Resume:: LPA driver resume failed");
+            return UNKNOWN_ERROR;
+        }
+    } else {
+	 //get config, set config and AUDIO_START LPA driver
+	 int sessionId = 0;
+        mPaused = false;
+    if ( afd >= 0 ) {
+        struct msm_audio_config config;
+        if ( ioctl(afd, AUDIO_GET_CONFIG, &config) < 0 ) {
+            ALOGE("could not get config");
+            close(afd);
+            afd = -1;
+            return BAD_VALUE;
+        }
+
+        config.sample_rate = mSampleRate;
+        config.channel_count = mChannels;
+        ALOGV("sample_rate=%d and channel count=%d \n", mSampleRate, mChannels);
+        if ( ioctl(afd, AUDIO_SET_CONFIG, &config) < 0 ) {
+            ALOGE("could not set config");
+            close(afd);
+            afd = -1;
+            return BAD_VALUE;
+        }
+    }
+    //Start the Driver
+    if (ioctl(afd, AUDIO_START,0) < 0) {
+        ALOGE("Driver start failed!");
+        return BAD_VALUE;
+    }
+    mIsDriverStarted = true;
+    if (timeStarted == 0)
+        timeStarted = nanoseconds_to_microseconds(systemTime(SYSTEM_TIME_MONOTONIC));// Needed
+    }
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioSessionOutLPA::pause()
+{
+    ALOGV("LPA playback pause");
+    if (ioctl(afd, AUDIO_PAUSE, 1) < 0) {
+    ALOGE("Audio Pause failed");
+    }
+    mPaused = true;
+	timePlayed += (nanoseconds_to_microseconds(systemTime(SYSTEM_TIME_MONOTONIC)) - timeStarted);//needed
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioSessionOutLPA::drain()
+{
+    ALOGV("LPA playback EOS");
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioSessionOutLPA::flush()
+{
+	Mutex::Autolock autoLock(mLock);
+    ALOGV("LPA playback flush ");
+    int err;
+
+    // 2.) Add all the available buffers to Empty Queue (Maintain order)
+    mFilledQueueMutex.lock();
+    mEmptyQueueMutex.lock();
+    while (!mFilledQueue.empty()) {
+        List<BuffersAllocated>::iterator it = mFilledQueue.begin();
+        BuffersAllocated buf = *it;
+        buf.bytesToWrite = 0;
+        mEmptyQueue.push_back(buf);
+        mFilledQueue.erase(it);
+    }
+    mEmptyQueueMutex.unlock();
+    mFilledQueueMutex.unlock();
+    ALOGV("Transferred all the buffers from Filled queue to "
+          "Empty queue to handle seek");
+    ALOGV("mPaused %d mEosEventReceived %d", mPaused, mEosEventReceived);
+    mReachedEOS = false;
+    if (!mPaused) {
+        if (!mEosEventReceived) {
+            if (ioctl(afd, AUDIO_PAUSE, 1) < 0) {
+                ALOGE("Audio Pause failed");
+                return UNKNOWN_ERROR;
+            }
+            mSkipWrite = true;
+            if (ioctl(afd, AUDIO_FLUSH, 0) < 0) {
+                ALOGE("Audio Flush failed");
+                return UNKNOWN_ERROR;
+            }
+        }
+    } else {
+        timeStarted = 0;
+        mSkipWrite = true;
+        if (ioctl(afd, AUDIO_FLUSH, 0) < 0) {
+            ALOGE("Audio Flush failed");
+            return UNKNOWN_ERROR;
+        }
+        if (ioctl(afd, AUDIO_PAUSE, 1) < 0) {
+            ALOGE("Audio Pause failed");
+            return UNKNOWN_ERROR;
+        }
+    }
+    mEosEventReceived = false;
+	//4.) Skip the current write from the decoder and signal to the Write get
+    //   the next set of data from the decoder
+    mWriteCv.signal();
+    return NO_ERROR;
+}
+status_t AudioHardware::AudioSessionOutLPA::stop()
+{
+    Mutex::Autolock autoLock(mLock);
+    ALOGV("AudioSessionOutLPA- stop");
+    // close all the existing PCM devices
+    mSkipWrite = true;
+    mWriteCv.signal();
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioSessionOutLPA::setObserver(void *observer)
+{
+    ALOGV("Registering the callback \n");
+    mObserver = reinterpret_cast<AudioEventObserver *>(observer);
+    return NO_ERROR;
+}
+
+status_t  AudioHardware::AudioSessionOutLPA::getNextWriteTimestamp(int64_t *timestamp)
+{
+
+    *timestamp = nanoseconds_to_microseconds(systemTime(SYSTEM_TIME_MONOTONIC)) - timeStarted + timePlayed;//needed
+    ALOGV("Timestamp returned = %lld\n", *timestamp);
+    return NO_ERROR;
+}
+
+void AudioHardware::AudioSessionOutLPA::reset()
+{
+    ALOGD("AudioSessionOutLPA::reset()");
+    mGenerateEOS = false;
+    //Close the LPA driver
+    ioctl(afd,AUDIO_STOP,0);
+    mIsDriverStarted = false;
+    requestAndWaitForEventThreadExit();
+    status_t status = NO_ERROR;
+    bufferDeAlloc();
+    ::close(afd);
+    ALOGD("AudioSessionOutLPA::reset() complete");
+}
+
+status_t AudioHardware::AudioSessionOutLPA::getRenderPosition(uint32_t *dspFrames)
+{
+    //TODO: enable when supported by driver
+    return INVALID_OPERATION;
+}
+
+
+status_t AudioHardware::AudioSessionOutLPA::getBufferInfo(buf_info **buf) {
+
+    buf_info *tempbuf = (buf_info *)malloc(sizeof(buf_info) + mInputBufferCount*sizeof(int *));
+    ALOGV("Get buffer info");
+    tempbuf->bufsize = LPA_BUFFER_SIZE;
+    tempbuf->nBufs = mInputBufferCount;
+    tempbuf->buffers = (int **)((char*)tempbuf + sizeof(buf_info));
+    List<BuffersAllocated>::iterator it = mEmptyQueue.begin();
+    for (int i = 0; i < mInputBufferCount; i++) {
+        tempbuf->buffers[i] = (int *)it->memBuf;
+        it++;
+    }
+    *buf = tempbuf;
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioSessionOutLPA::isBufferAvailable(int *isAvail) {
+
+    Mutex::Autolock autoLock(mLock);
+    ALOGV("isBufferAvailable Empty Queue size() = %d, Filled Queue size() = %d ",
+          mEmptyQueue.size(),mFilledQueue.size());
+    *isAvail = false;
+    // 1.) Wait till a empty buffer is available in the Empty buffer queue
+    mEmptyQueueMutex.lock();
+    if (mEmptyQueue.empty()) {
+        ALOGV("Write: waiting on mWriteCv");
+        mLock.unlock();
+        mWriteCv.wait(mEmptyQueueMutex);
+        mEmptyQueueMutex.unlock();
+        mLock.lock();
+        if (mSkipWrite) {
+            ALOGV("Write: Flushing the previous write buffer");
+            mSkipWrite = false;
+            return NO_ERROR;
+        }
+        ALOGV("Write: received a signal to wake up");
+         } else {
+        ALOGV("Buffer available in empty queue");
+        mEmptyQueueMutex.unlock();
+    }
+
+    *isAvail = true;
+    return NO_ERROR;
+}
+
+// End AudioSessionOutLPA
+//.----------------------------------------------------------------------------
+
+//.----------------------------------------------------------------------------
+AudioHardware::AudioStreamInMSM72xx::~AudioStreamInMSM72xx()
+{
+    ALOGV("AudioStreamInMSM72xx destructor");
+    AudioStreamInMSM72xx::InstanceCount--;
+    standby();
+}
+
+ssize_t AudioHardware::AudioStreamInMSM72xx::read( void* buffer, ssize_t bytes)
+{
+//    ALOGV("AudioStreamInMSM72xx::read(%p, %ld)", buffer, bytes);
+    if (!mHardware) return -1;
+
+    size_t count = bytes;
+    size_t  aac_framesize= bytes;
+    uint8_t* p = static_cast<uint8_t*>(buffer);
+    uint32_t* recogPtr = (uint32_t *)p;
+    uint16_t* frameCountPtr;
+    uint16_t* frameSizePtr;
+
+    if (mState < AUDIO_INPUT_OPENED) {
+        AudioHardware *hw = mHardware;
+        hw->mLock.lock();
+        status_t status = set(hw, mDevices, &mFormat, &mChannels, &mSampleRate, mAcoustics);
+        hw->mLock.unlock();
+        if (status != NO_ERROR) {
+            return -1;
+        }
+        mFirstread = false;
+    }
+
+    if (mState < AUDIO_INPUT_STARTED) {
+        mState = AUDIO_INPUT_STARTED;
+        // force routing to input device
+#ifdef QCOM_FM_ENABLED
+        if (mDevices != AudioSystem::DEVICE_IN_FM_RX) {
+            mHardware->clearCurDevice();
+            mHardware->doRouting(this);
+        }
+#endif
+        if (ioctl(mFd, AUDIO_START, 0)) {
+            ALOGE("Error starting record");
+            standby();
+            return -1;
+        }
+        msm72xx_enable_preproc(true);
+    }
+
+    // Resetting the bytes value, to return the appropriate read value
+    bytes = 0;
+    if (mFormat == AudioSystem::AAC)
+    {
+        *((uint32_t*)recogPtr) = 0x51434F4D ;// ('Q','C','O', 'M') Number to identify format as AAC by higher layers
+        recogPtr++;
+        frameCountPtr = (uint16_t*)recogPtr;
+        *frameCountPtr = 0;
+        p += 3*sizeof(uint16_t);
+        count -= 3*sizeof(uint16_t);
+    }
+    while (count > 0) {
+
+        if (mFormat == AudioSystem::AAC) {
+            frameSizePtr = (uint16_t *)p;
+            p += sizeof(uint16_t);
+            if(!(count > 2)) break;
+            count -= sizeof(uint16_t);
+        }
+
+        ssize_t bytesRead = ::read(mFd, p, count);
+        if (bytesRead > 0) {
+            count -= bytesRead;
+            p += bytesRead;
+            bytes += bytesRead;
+
+            if (mFormat == AudioSystem::AAC){
+                *frameSizePtr =  bytesRead;
+                (*frameCountPtr)++;
+            }
+
+            if(!mFirstread)
+            {
+               mFirstread = true;
+               break;
+            }
+
+        }
+        else if(bytesRead == 0)
+        {
+         ALOGI("Bytes Read = %d ,Buffer no longer sufficient",bytesRead);
+         break;
+        } else {
+            if (errno != EAGAIN) return bytesRead;
+            mRetryCount++;
+            ALOGW("EAGAIN - retrying");
+        }
+    }
+    if (mFormat == AudioSystem::AAC)
+         return aac_framesize;
+
+    return bytes;
+}
+
+status_t AudioHardware::AudioStreamInMSM72xx::standby()
+{
+    if (mState > AUDIO_INPUT_CLOSED) {
+        msm72xx_enable_preproc(false);
+        if (mFd >= 0) {
+            ::close(mFd);
+            mFd = -1;
+        }
+        mState = AUDIO_INPUT_CLOSED;
+    }
+    if (!mHardware) return -1;
+    // restore output routing if necessary
+#ifdef QCOM_FM_ENABLED
+    if (!mHardware->isFMAnalog() && !mHardware->IsFmon())
+#endif
+    {
+        mHardware->clearCurDevice();
+        mHardware->doRouting(this);
+    }
+#ifdef QCOM_FM_ENABLED
+    if(mHardware->IsFmA2dpOn())
+        mHardware->SwitchOffFmA2dp();
+#endif
+
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioStreamInMSM72xx::dump(int fd, const Vector<String16>& args)
+{
+    const size_t SIZE = 256;
+    char buffer[SIZE];
+    String8 result;
+    result.append("AudioStreamInMSM72xx::dump\n");
+    snprintf(buffer, SIZE, "\tsample rate: %d\n", sampleRate());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tbuffer size: %d\n", bufferSize());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tchannels: %d\n", channels());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tformat: %d\n", format());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmHardware: %p\n", mHardware);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmFd count: %d\n", mFd);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmState: %d\n", mState);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmRetryCount: %d\n", mRetryCount);
+    result.append(buffer);
+    ::write(fd, result.string(), result.size());
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioStreamInMSM72xx::setParameters(const String8& keyValuePairs)
+{
+    AudioParameter param = AudioParameter(keyValuePairs);
+    String8 key = String8(AudioParameter::keyRouting);
+    status_t status = NO_ERROR;
+    int device;
+    ALOGV("AudioStreamInMSM72xx::setParameters() %s", keyValuePairs.string());
+
+    if (param.getInt(key, device) == NO_ERROR) {
+        ALOGD("set input routing %x", device);
+        if (device & (device - 1)) {
+            status = BAD_VALUE;
+        } else {
+            mDevices = device;
+            status = mHardware->doRouting(this);
+        }
+        param.remove(key);
+    }
+
+    if (param.size()) {
+        status = BAD_VALUE;
+    }
+    return status;
+}
+
+String8 AudioHardware::AudioStreamInMSM72xx::getParameters(const String8& keys)
+{
+    AudioParameter param = AudioParameter(keys);
+    String8 value;
+    String8 key = String8(AudioParameter::keyRouting);
+
+    if (param.get(key, value) == NO_ERROR) {
+        ALOGV("get routing %x", mDevices);
+        param.addInt(key, (int)mDevices);
+    }
+
+    ALOGV("AudioStreamInMSM72xx::getParameters() %s", param.toString().string());
+    return param.toString();
+}
+
+// ----------------------------------------------------------------------------
+
+extern "C" AudioHardwareInterface* createAudioHardware(void) {
+    return new AudioHardware();
+}
+
+}; // namespace android
diff --git a/audio/AudioHardware.h b/audio/AudioHardware.h
new file mode 100644
index 0000000..6f20ada
--- /dev/null
+++ b/audio/AudioHardware.h
@@ -0,0 +1,639 @@
+/*
+** Copyright 2008, The Android Open-Source Project
+** Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#ifndef ANDROID_AUDIO_HARDWARE_H
+#define ANDROID_AUDIO_HARDWARE_H
+
+#include <stdint.h>
+#include <sys/types.h>
+#include <utils/List.h>
+
+#include <utils/threads.h>
+#include <sys/prctl.h>
+#include <utils/SortedVector.h>
+
+#include <hardware_legacy/AudioHardwareBase.h>
+
+extern "C" {
+#include <linux/msm_audio.h>
+#include <linux/ion.h>
+#include <linux/msm_audio_voicememo.h>
+#ifdef QCOM_VOIP_ENABLED
+#include <linux/msm_audio_mvs.h>
+#endif
+}
+
+namespace android_audio_legacy {
+using android::List;
+using android::SortedVector;
+using android::Mutex;
+using android::Condition;
+
+// ----------------------------------------------------------------------------
+// Kernel driver interface
+//
+
+#define SAMP_RATE_INDX_8000 0
+#define SAMP_RATE_INDX_11025 1
+#define SAMP_RATE_INDX_12000 2
+#define SAMP_RATE_INDX_16000 3
+#define SAMP_RATE_INDX_22050 4
+#define SAMP_RATE_INDX_24000 5
+#define SAMP_RATE_INDX_32000 6
+#define SAMP_RATE_INDX_44100 7
+#define SAMP_RATE_INDX_48000 8
+
+#define EQ_MAX_BAND_NUM 12
+
+#define ADRC_ENABLE  0x0001
+#define ADRC_DISABLE 0xFFFE
+#define EQ_ENABLE    0x0002
+#define EQ_DISABLE   0xFFFD
+#define RX_IIR_ENABLE  0x0004
+#define RX_IIR_DISABLE 0xFFFB
+#define MBADRC_ENABLE  0x0010
+#define MBADRC_DISABLE 0xFFEF
+#define SRS_ENABLE 0x0020
+#define SRS_DISABLE 0xFFDF
+#define LPA_BUFFER_SIZE 512*1024
+#define BUFFER_COUNT 2
+
+#define AGC_ENABLE     0x0001
+#define NS_ENABLE      0x0002
+#define TX_IIR_ENABLE  0x0004
+
+struct eq_filter_type {
+    int16_t gain;
+    uint16_t freq;
+    uint16_t type;
+    uint16_t qf;
+};
+
+struct eqalizer {
+    uint16_t bands;
+    uint16_t params[132];
+};
+
+struct rx_iir_filter {
+    uint16_t num_bands;
+    uint16_t iir_params[48];
+};
+
+struct adrc_filter {
+    uint16_t adrc_params[8];
+};
+
+struct msm_audio_stats {
+    uint32_t byte_count;
+    uint32_t sample_count;
+    uint32_t unused[2];
+};
+
+struct tx_iir {
+        uint16_t  cmd_id;
+        uint16_t  active_flag;
+        uint16_t  num_bands;
+        uint16_t iir_params[48];
+};
+
+struct ns {
+        uint16_t  cmd_id;
+        uint16_t  ec_mode_new;
+        uint16_t  dens_gamma_n;
+        uint16_t  dens_nfe_block_size;
+        uint16_t  dens_limit_ns;
+        uint16_t  dens_limit_ns_d;
+        uint16_t  wb_gamma_e;
+        uint16_t  wb_gamma_n;
+};
+
+struct tx_agc {
+        uint16_t  cmd_id;
+        uint16_t  tx_agc_param_mask;
+        uint16_t  tx_agc_enable_flag;
+        uint16_t  static_gain;
+        int16_t   adaptive_gain_flag;
+        uint16_t  agc_params[19];
+};
+
+struct adrc_config {
+    uint16_t adrc_band_params[10];
+};
+
+struct adrc_ext_buf {
+    int16_t buff[196];
+};
+
+struct mbadrc_filter {
+    uint16_t num_bands;
+    uint16_t down_samp_level;
+    uint16_t adrc_delay;
+    uint16_t ext_buf_size;
+    uint16_t ext_partition;
+    uint16_t ext_buf_msw;
+    uint16_t ext_buf_lsw;
+    struct adrc_config adrc_band[5];
+    struct adrc_ext_buf  ext_buf;
+};
+
+enum tty_modes {
+    TTY_OFF = 0,
+    TTY_VCO = 1,
+    TTY_HCO = 2,
+    TTY_FULL = 3
+};
+
+#define CODEC_TYPE_PCM 0
+#define AUDIO_HW_NUM_OUT_BUF 2  // Number of buffers in audio driver for output
+// TODO: determine actual audio DSP and hardware latency
+#define AUDIO_HW_OUT_LATENCY_MS 0  // Additionnal latency introduced by audio DSP and hardware in ms
+
+#define AUDIO_HW_IN_SAMPLERATE 8000                 // Default audio input sample rate
+#define AUDIO_HW_IN_CHANNELS (AudioSystem::CHANNEL_IN_MONO) // Default audio input channel mask
+#define AUDIO_HW_IN_BUFFERSIZE 2048                 // Default audio input buffer size
+#define AUDIO_HW_IN_FORMAT (AudioSystem::PCM_16_BIT)  // Default audio input sample format
+#ifdef QCOM_VOIP_ENABLED
+#define AUDIO_HW_VOIP_BUFFERSIZE_8K 320
+#define AUDIO_HW_VOIP_BUFFERSIZE_16K 640
+#define AUDIO_HW_VOIP_SAMPLERATE_8K 8000
+#define AUDIO_HW_VOIP_SAMPLERATE_16K 16000
+#endif
+
+// ----------------------------------------------------------------------------
+using android_audio_legacy::AudioHardwareBase;
+using android_audio_legacy::AudioStreamOut;
+using android_audio_legacy::AudioStreamIn;
+using android_audio_legacy::AudioSystem;
+using android_audio_legacy::AudioHardwareInterface;
+class AudioHardware : public  AudioHardwareBase
+{
+    class AudioStreamOutMSM72xx;
+    class AudioSessionOutLPA;
+    class AudioStreamInMSM72xx;
+#ifdef QCOM_VOIP_ENABLED
+    class AudioStreamOutDirect;
+    class AudioStreamInVoip;
+#endif
+public:
+                        AudioHardware();
+    virtual             ~AudioHardware();
+    virtual status_t    initCheck();
+
+    virtual status_t    setVoiceVolume(float volume);
+#ifdef QCOM_FM_ENABLED
+    virtual status_t    setFmVolume(float volume);
+#endif
+    virtual status_t    setMasterVolume(float volume);
+
+    virtual status_t    setMode(int mode);
+
+    // mic mute
+    virtual status_t    setMicMute(bool state);
+    virtual status_t    getMicMute(bool* state);
+
+    virtual status_t    setParameters(const String8& keyValuePairs);
+    virtual String8     getParameters(const String8& keys);
+
+    // create I/O streams
+    virtual AudioStreamOut* openOutputStream(
+                                uint32_t devices,
+                                //audio_output_flags_t flags,
+                                int *format=0,
+                                uint32_t *channels=0,
+                                uint32_t *sampleRate=0,
+                                status_t *status=0);
+    virtual AudioStreamIn* openInputStream(
+
+                                uint32_t devices,
+                                int *format,
+                                uint32_t *channels,
+                                uint32_t *sampleRate,
+                                status_t *status,
+                                AudioSystem::audio_in_acoustics acoustics);
+
+    virtual    void        closeOutputStream(AudioStreamOut* out);
+    virtual    void        closeInputStream(AudioStreamIn* in);
+
+    virtual    size_t      getInputBufferSize(uint32_t sampleRate, int format, int channelCount);
+               void        clearCurDevice() { mCurSndDevice = -1; }
+#ifdef QCOM_FM_ENABLED
+                int IsFmon() const { return (mFmFd != -1); }
+                int IsFmA2dpOn() const { return FmA2dpStatus; }
+                void SwitchOffFmA2dp() { FmA2dpStatus = false; }
+                bool isFMAnalog();
+#endif
+protected:
+    virtual status_t    dump(int fd, const Vector<String16>& args);
+    uint32_t getMvsMode(int format, int rate);
+    uint32_t getMvsRateType(uint32_t MvsMode, uint32_t *rateType);
+    status_t setupDeviceforVoipCall(bool value);
+
+private:
+
+    status_t    doAudioRouteOrMute(uint32_t device);
+    status_t    setMicMute_nosync(bool state);
+    status_t    checkMicMute();
+    status_t    dumpInternals(int fd, const Vector<String16>& args);
+    uint32_t    getInputSampleRate(uint32_t sampleRate);
+    bool        checkOutputStandby();
+    status_t    doRouting(AudioStreamInMSM72xx *input, int outputDevice = 0);
+#ifdef QCOM_FM_ENABLED
+    status_t    enableFM();
+    status_t    disableFM();
+#endif
+    AudioStreamInMSM72xx*   getActiveInput_l();
+#ifdef QCOM_VOIP_ENABLED
+    AudioStreamInVoip* getActiveVoipInput_l();
+#endif
+
+    class AudioStreamOutMSM72xx : public AudioStreamOut {
+    public:
+                            AudioStreamOutMSM72xx();
+        virtual             ~AudioStreamOutMSM72xx();
+                status_t    set(AudioHardware* mHardware,
+                                uint32_t devices,
+                                int *pFormat,
+                                uint32_t *pChannels,
+                                uint32_t *pRate);
+        virtual uint32_t sampleRate() const {
+            char af_quality[PROPERTY_VALUE_MAX];
+            property_get("af.resampler.quality",af_quality,"0");
+            if(strcmp("255",af_quality) == 0) {
+                ALOGD("SampleRate 48k");
+                return 48000;
+            } else {
+                ALOGD("SampleRate 44.1k");
+                return 44100;
+            }
+        }
+        virtual size_t bufferSize() const {
+            char af_quality[PROPERTY_VALUE_MAX];
+            property_get("af.resampler.quality",af_quality,"0");
+            if(strcmp("255",af_quality) == 0) {
+                ALOGD("Bufsize 5248");
+                return 5248;
+            } else {
+                ALOGD("Bufsize 4800");
+                return 4800;
+            }
+        }
+        virtual uint32_t    channels() const { return AudioSystem::CHANNEL_OUT_STEREO; }
+        virtual int         format() const { return AudioSystem::PCM_16_BIT; }
+        virtual uint32_t    latency() const { return (1000*AUDIO_HW_NUM_OUT_BUF*(bufferSize()/frameSize()))/sampleRate()+AUDIO_HW_OUT_LATENCY_MS; }
+        virtual status_t    setVolume(float left, float right) { return INVALID_OPERATION; }
+        virtual ssize_t     write(const void* buffer, size_t bytes);
+        virtual status_t    standby();
+        virtual status_t    dump(int fd, const Vector<String16>& args);
+                bool        checkStandby();
+        virtual status_t    setParameters(const String8& keyValuePairs);
+        virtual String8     getParameters(const String8& keys);
+                uint32_t    devices() { return mDevices; }
+        virtual status_t    getRenderPosition(uint32_t *dspFrames);
+
+    private:
+                AudioHardware* mHardware;
+                int         mFd;
+                int         mStartCount;
+                int         mRetryCount;
+                bool        mStandby;
+                uint32_t    mDevices;
+    };
+#ifdef QCOM_VOIP_ENABLED
+    class AudioStreamOutDirect : public AudioStreamOut {
+    public:
+                            AudioStreamOutDirect();
+        virtual             ~AudioStreamOutDirect();
+                status_t    set(AudioHardware* mHardware,
+                                uint32_t devices,
+                                int *pFormat,
+                                uint32_t *pChannels,
+                                uint32_t *pRate);
+        virtual uint32_t    sampleRate() const { ALOGE(" AudioStreamOutDirect: sampleRate\n"); return 8000; }
+        // must be 32-bit aligned - driver only seems to like 4800
+        virtual size_t      bufferSize() const { ALOGE(" AudioStreamOutDirect: bufferSize\n"); return 320; }
+        virtual uint32_t    channels() const {ALOGD(" AudioStreamOutDirect: channels\n"); return mChannels; }
+        virtual int         format() const {ALOGE(" AudioStreamOutDirect: format\n"); return AudioSystem::PCM_16_BIT; }
+        virtual uint32_t    latency() const { return (1000*AUDIO_HW_NUM_OUT_BUF*(bufferSize()/frameSize()))/sampleRate()+AUDIO_HW_OUT_LATENCY_MS; }
+        virtual status_t    setVolume(float left, float right) { return INVALID_OPERATION; }
+        virtual ssize_t     write(const void* buffer, size_t bytes);
+        virtual status_t    standby();
+        virtual status_t    dump(int fd, const Vector<String16>& args);
+                bool        checkStandby();
+        virtual status_t    setParameters(const String8& keyValuePairs);
+        virtual String8     getParameters(const String8& keys);
+                uint32_t    devices() { return mDevices; }
+        virtual status_t    getRenderPosition(uint32_t *dspFrames);
+
+    private:
+                AudioHardware* mHardware;
+                int         mFd;
+                int         mRetryCount;
+                int         mStartCount;
+                bool        mStandby;
+                uint32_t    mDevices;
+                uint32_t    mChannels;
+                uint32_t    mSampleRate;
+                size_t      mBufferSize;
+                int         mFormat;
+    };
+#endif
+// ----------------------------------------------------------------------------
+
+class AudioSessionOutLPA : public AudioStreamOut
+{
+public:
+    AudioSessionOutLPA(AudioHardware* mHardware,
+                        uint32_t   devices,
+                        int        format,
+                        uint32_t   channels,
+                        uint32_t   samplingRate,
+                        int        type,
+                        status_t   *status);
+    virtual            ~AudioSessionOutLPA();
+
+    virtual uint32_t    sampleRate() const
+    {
+        return mSampleRate;
+    }
+
+    virtual size_t      bufferSize() const
+    {
+        return mBufferSize;
+    }
+
+    virtual uint32_t    channels() const
+    {
+        return mChannels;
+    }
+
+    virtual int         format() const
+    {
+        return mFormat;
+    }
+
+    virtual uint32_t    latency() const;
+
+    virtual ssize_t     write(const void *buffer, size_t bytes);
+
+    virtual status_t    start( );
+    virtual status_t    pause();
+    virtual status_t    flush();
+    virtual status_t    stop();
+
+    virtual status_t    dump(int fd, const Vector<String16>& args);
+
+    status_t            setVolume(float left, float right);
+
+    virtual status_t    standby();
+
+    virtual status_t    setParameters(const String8& keyValuePairs);
+
+    virtual String8     getParameters(const String8& keys);
+
+
+    // return the number of audio frames written by the audio dsp to DAC since
+    // the output has exited standby
+    virtual status_t    getRenderPosition(uint32_t *dspFrames);
+
+    virtual status_t    getNextWriteTimestamp(int64_t *timestamp);
+    virtual status_t    setObserver(void *observer);
+    virtual status_t    getBufferInfo(buf_info **buf);
+    virtual status_t    isBufferAvailable(int *isAvail);
+
+    void* memBufferAlloc(int nSize, int32_t *ion_fd);
+
+private:
+    Mutex               mLock;
+    uint32_t            mFrameCount;
+    uint32_t            mSampleRate;
+    uint32_t            mChannels;
+    size_t              mBufferSize;
+    int                 mFormat;
+    uint32_t            mStreamVol;
+
+    bool                mPaused;
+    bool                mIsDriverStarted;
+    bool                mGenerateEOS;
+    bool                mSeeking;
+    bool                mReachedEOS;
+    bool                mSkipWrite;
+    bool                mEosEventReceived;
+    uint32_t    mDevices;
+    AudioHardware* mHardware;
+    AudioEventObserver *mObserver;
+
+    void                createEventThread();
+    void                bufferAlloc();
+    void                bufferDeAlloc();
+    bool                isReadyToPostEOS(int errPoll, void *fd);
+    status_t            drain();
+	status_t            openAudioSessionDevice();
+    // make sure the event thread also exited
+    void                requestAndWaitForEventThreadExit();
+    int32_t             writeToDriver(char *buffer, int bytes);
+    static void *       eventThreadWrapper(void *me);
+    void                eventThreadEntry();
+//??    status_t            pause_l();
+//??    status_t            resume_l();
+    void                reset();
+
+    //Structure to hold ion buffer information
+    class BuffersAllocated {
+    /* overload BuffersAllocated constructor to support both ion and pmem memory allocation */
+    public:
+        BuffersAllocated(void *buf1, void *buf2, int32_t nSize, int32_t fd) :
+        localBuf(buf1), memBuf(buf2), memBufsize(nSize), memFd(fd)
+        {}
+        BuffersAllocated(void *buf1, void *buf2, int32_t nSize, int32_t share_fd, struct ion_handle *handle) :
+        ion_handle(handle), localBuf(buf1), memBuf(buf2), memBufsize(nSize), memFd(share_fd)
+        {}
+        struct ion_handle *ion_handle;
+        void* localBuf;
+        void* memBuf;
+        int32_t memBufsize;
+        int32_t memFd;
+        uint32_t bytesToWrite;
+    };
+    List<BuffersAllocated> mEmptyQueue;
+    List<BuffersAllocated> mFilledQueue;
+    List<BuffersAllocated> mBufPool;
+
+    //Declare all the threads
+    pthread_t mEventThread;
+
+    //Declare the condition Variables and Mutex
+    Mutex mEmptyQueueMutex;
+    Mutex mFilledQueueMutex;
+
+    Condition mWriteCv;
+    Condition mEventCv;
+	pthread_mutex_t event_mutex;
+    bool mKillEventThread;
+    bool mEventThreadAlive;
+    int mInputBufferSize;
+    int mInputBufferCount;
+    int64_t timePlayed;
+    int64_t timeStarted;
+
+    //event fd to signal the EOS and Kill from the userspace
+    int efd;
+	int afd;
+	int ionfd;
+};
+
+    class AudioStreamInMSM72xx : public AudioStreamIn {
+    public:
+        enum input_state {
+            AUDIO_INPUT_CLOSED,
+            AUDIO_INPUT_OPENED,
+            AUDIO_INPUT_STARTED
+        };
+
+                            AudioStreamInMSM72xx();
+        virtual             ~AudioStreamInMSM72xx();
+                status_t    set(AudioHardware* mHardware,
+                                uint32_t devices,
+                                int *pFormat,
+                                uint32_t *pChannels,
+                                uint32_t *pRate,
+                                AudioSystem::audio_in_acoustics acoustics);
+        virtual size_t      bufferSize() const { return mBufferSize; }
+        virtual uint32_t    channels() const { return mChannels; }
+        virtual int         format() const { return mFormat; }
+        virtual uint32_t    sampleRate() const { return mSampleRate; }
+        virtual status_t    setGain(float gain) { return INVALID_OPERATION; }
+        virtual ssize_t     read(void* buffer, ssize_t bytes);
+        virtual status_t    dump(int fd, const Vector<String16>& args);
+        virtual status_t    standby();
+        virtual status_t    setParameters(const String8& keyValuePairs);
+        virtual String8     getParameters(const String8& keys);
+        virtual unsigned int  getInputFramesLost() const { return 0; }
+                uint32_t    devices() { return mDevices; }
+                int         state() const { return mState; }
+        virtual status_t    addAudioEffect(effect_interface_s**) { return 0;}
+        virtual status_t    removeAudioEffect(effect_interface_s**) { return 0;}
+
+    private:
+                AudioHardware* mHardware;
+                int         mFd;
+                int         mState;
+                int         mRetryCount;
+                int         mFormat;
+                uint32_t    mChannels;
+                uint32_t    mSampleRate;
+                size_t      mBufferSize;
+                AudioSystem::audio_in_acoustics mAcoustics;
+                uint32_t    mDevices;
+                bool        mFirstread;
+                static int InstanceCount;
+    };
+
+#ifdef QCOM_VOIP_ENABLED
+    class AudioStreamInVoip : public AudioStreamInMSM72xx {
+    public:
+        enum input_state {
+            AUDIO_INPUT_CLOSED,
+            AUDIO_INPUT_OPENED,
+            AUDIO_INPUT_STARTED
+        };
+
+                            AudioStreamInVoip();
+        virtual             ~AudioStreamInVoip();
+                status_t    set(AudioHardware* mHardware,
+                                uint32_t devices,
+                                int *pFormat,
+                                uint32_t *pChannels,
+                                uint32_t *pRate,
+                                AudioSystem::audio_in_acoustics acoustics);
+        virtual size_t      bufferSize() const { return mBufferSize; }
+        virtual uint32_t    channels() const {ALOGD(" AudioStreamInVoip: channels %d \n",mChannels); return mChannels; }
+        virtual int         format() const { return AUDIO_HW_IN_FORMAT; }
+        virtual uint32_t    sampleRate() const { return mSampleRate; }
+        virtual status_t    setGain(float gain) { return INVALID_OPERATION; }
+        virtual ssize_t     read(void* buffer, ssize_t bytes);
+        virtual status_t    dump(int fd, const Vector<String16>& args);
+        virtual status_t    standby();
+        virtual status_t    setParameters(const String8& keyValuePairs);
+        virtual String8     getParameters(const String8& keys);
+        virtual unsigned int  getInputFramesLost() const { return 0; }
+                uint32_t    devices() { return mDevices; }
+                int         state() const { return mState; }
+                bool        mSetupDevice;
+
+    private:
+                AudioHardware* mHardware;
+                int         mFd;
+                int         mState;
+                int         mRetryCount;
+                int         mFormat;
+                uint32_t    mChannels;
+                uint32_t    mSampleRate;
+                size_t      mBufferSize;
+                AudioSystem::audio_in_acoustics mAcoustics;
+                uint32_t    mDevices;
+                bool        mFirstread;
+#ifdef QCOM_FM_ENABLED
+                uint32_t    mFmRec;
+#endif
+    };
+#endif /*QCOM_VOIP_ENABLED*/
+            static const uint32_t inputSamplingRates[];
+            bool        mInit;
+            bool        mMicMute;
+#ifdef QCOM_FM_ENABLED
+            int         mFmFd;
+            int         FmA2dpStatus;
+#endif
+            bool        mBluetoothNrec;
+            bool        mBluetoothVGS;
+            uint32_t    mBluetoothId;
+            AudioStreamOutMSM72xx*  mOutput;
+#ifdef QCOM_VOIP_ENABLED
+            AudioStreamOutDirect*  mDirectOutput;
+#endif
+            AudioSessionOutLPA* mOutputLPA;
+            SortedVector <AudioStreamInMSM72xx*>   mInputs;
+#ifdef QCOM_VOIP_ENABLED
+            SortedVector <AudioStreamInVoip*>   mVoipInputs;
+#endif /*QCOM_VOIP_ENABLED*/
+            uint32_t mVoipBitRate;
+            msm_snd_endpoint *mSndEndpoints;
+            int mNumSndEndpoints;
+
+            msm_cad_endpoint *mCadEndpoints;
+            int mNumCadEndpoints;
+
+            int mCurSndDevice;
+            int m7xsnddriverfd;
+            bool        mDualMicEnabled;
+            int         mTtyMode;
+#ifdef QCOM_VOIP_ENABLED
+            int mVoipFd;
+            bool mVoipInActive;
+            bool mVoipOutActive;
+            Mutex       mVoipLock;
+            int         mDirectOutrefCnt;
+#endif /*QCOM_VOIP_ENABLED*/
+     friend class AudioStreamInMSM72xx;
+            Mutex       mLock;
+};
+
+// ----------------------------------------------------------------------------
+
+}; // namespace android
+
+#endif // ANDROID_AUDIO_HARDWARE_MSM72XX_H
diff --git a/audio/AudioHardware_cad.cpp b/audio/AudioHardware_cad.cpp
new file mode 100644
index 0000000..3ca90b2
--- /dev/null
+++ b/audio/AudioHardware_cad.cpp
@@ -0,0 +1,3639 @@
+/*
+** Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+** Not a Contribution, Apache license notifications and license are retained
+** for attribution purposes only.
+** Copyright 2008, The Android Open-Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#include <math.h>
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "AudioHardwareMSM76XXA"
+#include <utils/Log.h>
+#include <utils/String8.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <dlfcn.h>
+#include <fcntl.h>
+#include <cutils/properties.h> // for property_get
+// hardware specific functions
+
+extern "C" {
+#include "initialize_audcal8x25.h"
+}
+#include "AudioHardware.h"
+#ifdef QCOM_FM_ENABLED
+extern "C" {
+#include "HardwarePinSwitching.h"
+}
+#endif
+//#include <media/AudioRecord.h>
+
+
+#define COMBO_DEVICE_SUPPORTED // Headset speaker combo device supported on this target
+#define DUALMIC_KEY "dualmic_enabled"
+#define TTY_MODE_KEY "tty_mode"
+#define ECHO_SUPRESSION "ec_supported"
+#define VOIPRATE_KEY "voip_rate"
+namespace android_audio_legacy {
+
+#ifdef SRS_PROCESSING
+void*       SRSParamsG = NULL;
+void*       SRSParamsW = NULL;
+void*       SRSParamsC = NULL;
+void*       SRSParamsHP = NULL;
+void*       SRSParamsP = NULL;
+void*       SRSParamsHL = NULL;
+
+#define SRS_PARAMS_G 1
+#define SRS_PARAMS_W 2
+#define SRS_PARAMS_C 4
+#define SRS_PARAMS_HP 8
+#define SRS_PARAMS_P 16
+#define SRS_PARAMS_HL 32
+#define SRS_PARAMS_ALL 0xFF
+
+#endif /*SRS_PROCESSING*/
+
+static void * acoustic;
+const uint32_t AudioHardware::inputSamplingRates[] = {
+        8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000
+};
+
+#ifdef SRS_PROCESSING
+static void msm72xx_enable_srs(int flags, bool state);
+#endif /*SRS_PROCESSING*/
+
+static int post_proc_feature_mask = 0;
+static bool hpcm_playback_in_progress = false;
+#ifdef QCOM_TUNNEL_LPA_ENABLED
+static bool lpa_playback_in_progress = false;
+#endif
+
+
+static int snd_device = -1;
+
+#define PCM_OUT_DEVICE "/dev/msm_pcm_out"
+#define PCM_IN_DEVICE "/dev/msm_pcm_in"
+#define PCM_CTL_DEVICE "/dev/msm_pcm_ctl"
+#define PREPROC_CTL_DEVICE "/dev/msm_preproc_ctl"
+#define VOICE_MEMO_DEVICE "/dev/msm_voicememo"
+#ifdef QCOM_FM_ENABLED
+#define FM_DEVICE  "/dev/msm_fm"
+#endif
+#define BTHEADSET_VGS "bt_headset_vgs"
+#ifdef QCOM_VOIP_ENABLED
+#define MVS_DEVICE "/dev/msm_mvs"
+#endif
+
+/*SND Devices*/
+static uint32_t SND_DEVICE_CURRENT = -1;
+static uint32_t SND_DEVICE_HANDSET = 0x0;
+static uint32_t SND_DEVICE_HEADSET = 0x3;
+static uint32_t SND_DEVICE_SPEAKER = 0x6;
+static uint32_t SND_DEVICE_TTY_HEADSET = 0x8;
+static uint32_t SND_DEVICE_TTY_VCO = 0x9;
+static uint32_t SND_DEVICE_TTY_HCO = 0xA;
+static uint32_t SND_DEVICE_BT = 0xC;
+static uint32_t SND_DEVICE_IN_S_SADC_OUT_HANDSET = 0x10;
+static uint32_t SND_DEVICE_IN_S_SADC_OUT_SPEAKER_PHONE = 0x19;
+static uint32_t SND_DEVICE_FM_DIGITAL_STEREO_HEADSET = 0x1A;
+static uint32_t SND_DEVICE_FM_DIGITAL_SPEAKER_PHONE = 0x1B;
+static uint32_t SND_DEVICE_FM_DIGITAL_BT_A2DP_HEADSET = 0x1C;
+static uint32_t SND_DEVICE_STEREO_HEADSET_AND_SPEAKER = 0x1F;
+static uint32_t SND_DEVICE_FM_ANALOG_STEREO_HEADSET = 0x23;
+static uint32_t SND_DEVICE_FM_ANALOG_STEREO_HEADSET_CODEC = 0x24;
+
+/*CAD Devices*/
+static uint32_t CAD_HW_DEVICE_ID_NONE                 = -1;
+static uint32_t CAD_HW_DEVICE_ID_HANDSET_SPKR         = -1;
+static uint32_t CAD_HW_DEVICE_ID_HANDSET_MIC          = -1;
+static uint32_t CAD_HW_DEVICE_ID_HEADSET_MIC          = -1;
+static uint32_t CAD_HW_DEVICE_ID_HEADSET_SPKR_MONO    = -1;
+static uint32_t CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO  = -1;
+static uint32_t CAD_HW_DEVICE_ID_SPEAKER_PHONE_MIC    = -1;
+static uint32_t CAD_HW_DEVICE_ID_SPEAKER_PHONE_MONO   = -1;
+static uint32_t CAD_HW_DEVICE_ID_SPEAKER_PHONE_STEREO = -1;
+static uint32_t CAD_HW_DEVICE_ID_BT_SCO_MIC           = -1;
+static uint32_t CAD_HW_DEVICE_ID_BT_SCO_SPKR          = -1;
+static uint32_t CAD_HW_DEVICE_ID_BT_A2DP_SPKR         = -1;
+static uint32_t CAD_HW_DEVICE_ID_TTY_HEADSET_MIC      = -1;
+static uint32_t CAD_HW_DEVICE_ID_TTY_HEADSET_SPKR     = -1;
+static uint32_t CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_MONO_RX     = -1;
+static uint32_t CAD_HW_DEVICE_ID_LP_FM_HEADSET_SPKR_STEREO_RX         = -1;
+static uint32_t CAD_HW_DEVICE_ID_I2S_RX                               = -1;
+static uint32_t CAD_HW_DEVICE_ID_SPEAKER_PHONE_MIC_ENDFIRE            = -1;
+static uint32_t CAD_HW_DEVICE_ID_HANDSET_MIC_ENDFIRE                  = -1;
+static uint32_t CAD_HW_DEVICE_ID_I2S_TX                               = -1;
+static uint32_t CAD_HW_DEVICE_ID_LP_FM_HEADSET_SPKR_STEREO_PLUS_HEADSET_SPKR_STEREO_RX = -1;
+static uint32_t CAD_HW_DEVICE_ID_FM_DIGITAL_HEADSET_SPKR_STEREO = -1;
+static uint32_t CAD_HW_DEVICE_ID_FM_DIGITAL_SPEAKER_PHONE_MONO = -1;
+static uint32_t CAD_HW_DEVICE_ID_FM_DIGITAL_SPEAKER_PHONE_MIC= -1;
+static uint32_t CAD_HW_DEVICE_ID_FM_DIGITAL_BT_A2DP_SPKR = -1;
+static uint32_t CAD_HW_DEVICE_ID_MAX                     = -1;
+
+static uint32_t CAD_HW_DEVICE_ID_CURRENT_RX = -1;
+static uint32_t CAD_HW_DEVICE_ID_CURRENT_TX = -1;
+// ----------------------------------------------------------------------------
+
+AudioHardware::AudioHardware() :
+    mInit(false), mMicMute(true), mBluetoothNrec(true), mBluetoothId(0), mTtyMode(TTY_OFF),
+    mOutput(0),mBluetoothVGS(false), mCadEndpoints(NULL), mCurSndDevice(-1)
+#ifdef QCOM_FM_ENABLED
+    ,mFmFd(-1),FmA2dpStatus(-1)
+#endif
+#ifdef QCOM_VOIP_ENABLED
+,mVoipFd(-1), mVoipInActive(false), mVoipOutActive(false), mDirectOutput(0), mVoipBitRate(0),
+mDirectOutrefCnt(0)
+#endif /*QCOM_VOIP_ENABLED*/
+{
+    m7xsnddriverfd = open("/dev/msm_cad", O_RDWR);
+    if (m7xsnddriverfd >= 0) {
+        int rc = ioctl(m7xsnddriverfd, CAD_GET_NUM_ENDPOINTS, &mNumCadEndpoints);
+        if (rc >= 0) {
+            mCadEndpoints = new msm_cad_endpoint[mNumCadEndpoints];
+            mInit = true;
+            ALOGV("constructed (%d SND endpoints)", rc);
+            struct msm_cad_endpoint *ept = mCadEndpoints;
+            for (int cnt = 0; cnt < mNumCadEndpoints; cnt++, ept++) {
+                ept->id = cnt;
+                ioctl(m7xsnddriverfd, CAD_GET_ENDPOINT, ept);
+                ALOGV("cnt = %d ept->name = %s ept->id = %d\n", cnt, ept->name, ept->id);
+#define CHECK_FOR(desc) if (!strcmp(ept->name, #desc)) CAD_HW_DEVICE_ID_##desc = ept->id;
+                CHECK_FOR(NONE);
+                CHECK_FOR(HANDSET_SPKR);
+                CHECK_FOR(HANDSET_MIC);
+                CHECK_FOR(HEADSET_MIC);
+                CHECK_FOR(HEADSET_SPKR_MONO);
+                CHECK_FOR(HEADSET_SPKR_STEREO);
+                CHECK_FOR(SPEAKER_PHONE_MIC);
+                CHECK_FOR(SPEAKER_PHONE_MONO);
+                CHECK_FOR(SPEAKER_PHONE_STEREO);
+                CHECK_FOR(BT_SCO_MIC);
+                CHECK_FOR(BT_SCO_SPKR);
+                CHECK_FOR(BT_A2DP_SPKR);
+                CHECK_FOR(TTY_HEADSET_MIC);
+                CHECK_FOR(TTY_HEADSET_SPKR);
+                CHECK_FOR(HEADSET_STEREO_PLUS_SPKR_MONO_RX);
+                CHECK_FOR(I2S_RX);
+                CHECK_FOR(SPEAKER_PHONE_MIC_ENDFIRE);
+                CHECK_FOR(HANDSET_MIC_ENDFIRE);
+                CHECK_FOR(I2S_TX);
+#ifdef QCOM_FM_ENABLED
+                CHECK_FOR(LP_FM_HEADSET_SPKR_STEREO_RX);
+                CHECK_FOR(LP_FM_HEADSET_SPKR_STEREO_PLUS_HEADSET_SPKR_STEREO_RX);
+                CHECK_FOR(FM_DIGITAL_HEADSET_SPKR_STEREO);
+                CHECK_FOR(FM_DIGITAL_SPEAKER_PHONE_MONO);
+                CHECK_FOR(FM_DIGITAL_SPEAKER_PHONE_MIC);
+                CHECK_FOR(FM_DIGITAL_BT_A2DP_SPKR);
+#endif
+#undef CHECK_FOR
+            }
+        }
+        else ALOGE("Could not retrieve number of MSM SND endpoints.");
+    } else
+        ALOGE("Could not open MSM SND driver.");
+
+    audcal_initialize();
+
+    char fluence_key[PROPERTY_VALUE_MAX] = "none";
+    property_get("ro.qc.sdk.audio.fluencetype",fluence_key,"0");
+
+    if (0 == strncmp("fluencepro", fluence_key, sizeof("fluencepro"))) {
+       ALOGE("FluencePro quadMic feature not supported");
+    } else if (0 == strncmp("fluence", fluence_key, sizeof("fluence"))) {
+       mDualMicEnabled = true;
+       ALOGV("Fluence dualmic feature Enabled");
+    } else {
+       mDualMicEnabled = false;
+       ALOGV("Fluence feature Disabled");
+    }
+}
+
+AudioHardware::~AudioHardware()
+{
+    for (size_t index = 0; index < mInputs.size(); index++) {
+        closeInputStream((AudioStreamIn*)mInputs[index]);
+    }
+    mInputs.clear();
+#ifdef QCOM_VOIP_ENABLED
+    mVoipInputs.clear();
+#endif
+    closeOutputStream((AudioStreamOut*)mOutput);
+    delete [] mCadEndpoints;
+    if (acoustic) {
+        ::dlclose(acoustic);
+        acoustic = 0;
+    }
+    if (m7xsnddriverfd > 0)
+    {
+      close(m7xsnddriverfd);
+      m7xsnddriverfd = -1;
+    }
+    mInit = false;
+}
+
+status_t AudioHardware::initCheck()
+{
+    return mInit ? NO_ERROR : NO_INIT;
+}
+
+AudioStreamOut* AudioHardware::openOutputStream(uint32_t devices, audio_output_flags_t flags, int *format, uint32_t *channels,
+        uint32_t *sampleRate, status_t *status)
+{
+    ALOGD("openOutputStream: devices = %u format = %x channels = %u sampleRate = %u flags %x\n",
+         devices, *format, *channels, *sampleRate, flags);
+    { // scope for the lock
+        status_t lStatus;
+        Mutex::Autolock lock(mLock);
+
+#ifdef QCOM_VOIP_ENABLED
+        // only one output stream allowed
+        if (mOutput && !((flags & AUDIO_OUTPUT_FLAG_DIRECT) && (flags & AUDIO_OUTPUT_FLAG_VOIP_RX))
+                    && !(flags & AUDIO_OUTPUT_FLAG_LPA)) {
+            if (status) {
+                *status = INVALID_OPERATION;
+            }
+            ALOGE(" AudioHardware::openOutputStream Only one output stream allowed \n");
+            return 0;
+        }
+        if ((flags & AUDIO_OUTPUT_FLAG_DIRECT) && (flags & AUDIO_OUTPUT_FLAG_VOIP_RX)) {
+
+            if(mDirectOutput == 0) {
+                // open direct output stream
+                ALOGV(" AudioHardware::openOutputStream Direct output stream \n");
+                AudioStreamOutDirect* out = new AudioStreamOutDirect();
+                lStatus = out->set(this, devices, format, channels, sampleRate);
+                if (status) {
+                    *status = lStatus;
+                }
+                if (lStatus == NO_ERROR) {
+                    mDirectOutput = out;
+                    mDirectOutrefCnt++;
+                    mLock.unlock();
+                    if (mVoipInActive)
+                        setupDeviceforVoipCall(true);
+                    mLock.lock();
+                    ALOGV(" \n set sucessful for AudioStreamOutDirect");
+                } else {
+                    ALOGE(" \n set Failed for AudioStreamOutDirect");
+                    delete out;
+                }
+            }
+            else {
+              mDirectOutrefCnt++;
+                ALOGE(" \n AudioHardware::AudioStreamOutDirect is already open refcnt %d",mDirectOutrefCnt);
+             }
+            return mDirectOutput;
+        }
+        else
+#endif /*QCOM_VOIP_ENABLED*/
+             if (flags & AUDIO_OUTPUT_FLAG_LPA) {
+                 status_t err = BAD_VALUE;
+#if 0
+            if (mOutput) {
+                if (status) {
+                  *status = INVALID_OPERATION;
+                }
+                ALOGE(" AudioHardware::openOutputStream Only one output stream allowed \n");
+                return 0;
+            }
+#endif
+            // create new output LPA stream
+            AudioSessionOutLPA* out = new AudioSessionOutLPA(this, devices, *format, *channels,*sampleRate,0,&err);
+            if(err != NO_ERROR) {
+                delete out;
+                out = NULL;
+            }
+            if (status) *status = err;
+            mOutputLPA = out;
+        return mOutputLPA;
+
+        } else {
+#if 0
+            ALOGV(" AudioHardware::openOutputStream AudioStreamOutMSM8x60 output stream \n");
+            // only one output stream allowed
+            if (mOutput) {
+                if (status) {
+                  *status = INVALID_OPERATION;
+                }
+                ALOGE(" AudioHardware::openOutputStream Only one output stream allowed \n");
+                return 0;
+            }
+#endif
+            // create new output stream
+            AudioStreamOutMSM72xx* out = new AudioStreamOutMSM72xx();
+            lStatus = out->set(this, devices, format, channels, sampleRate);
+            if (status) {
+                *status = lStatus;
+            }
+            if (lStatus == NO_ERROR) {
+                mOutput = out;
+            } else {
+                delete out;
+            }
+            return mOutput;
+        }
+    }
+return NULL;
+}
+
+void AudioHardware::closeOutputStream(AudioStreamOut* out) {
+    Mutex::Autolock lock(mLock);
+    if ((mOutput == 0
+#ifdef QCOM_VOIP_ENABLED
+      && mDirectOutput == 0
+#endif
+        && mOutputLPA == 0) || ((mOutput != out)
+#ifdef QCOM_VOIP_ENABLED
+      && (mDirectOutput != out)
+#endif
+       && (mOutputLPA != out))) {
+        ALOGW("Attempt to close invalid output stream");
+    }
+    else if (mOutput == out) {
+        delete mOutput;
+        mOutput = 0;
+    }
+#ifdef QCOM_VOIP_ENABLED
+    else if (mDirectOutput == out) {
+          mDirectOutrefCnt--;
+        if (mDirectOutrefCnt <= 0) {
+            ALOGV(" deleting  mDirectOutput \n");
+            delete mDirectOutput;
+            mDirectOutput = 0;
+        }
+    }
+#endif /*QCOM_VOIP_ENABLED*/
+    else if (mOutputLPA == out) {
+        ALOGV(" deleting  mOutputLPA \n");
+        delete mOutputLPA;
+        mOutputLPA = 0;
+    }
+}
+
+AudioStreamIn* AudioHardware::openInputStream(
+        uint32_t devices, int *format, uint32_t *channels, uint32_t *sampleRate, status_t *status,
+        AudioSystem::audio_in_acoustics acoustic_flags)
+{
+    ALOGD("AudioHardware::openInputStream devices %x format %d channels %d samplerate %d",
+        devices, *format, *channels, *sampleRate);
+
+    // check for valid input source
+    if (!AudioSystem::isInputDevice((AudioSystem::audio_devices)devices)) {
+        return 0;
+    }
+
+    mLock.lock();
+#ifdef QCOM_VOIP_ENABLED
+    if(devices == AudioSystem::DEVICE_IN_COMMUNICATION) {
+        ALOGV("Create Audio stream Voip \n");
+        AudioStreamInVoip* inVoip = new AudioStreamInVoip();
+        status_t lStatus = NO_ERROR;
+        lStatus =  inVoip->set(this, devices, format, channels, sampleRate, acoustic_flags);
+        if (status) {
+            *status = lStatus;
+        }
+        if (lStatus != NO_ERROR) {
+            ALOGE(" Error creating voip input \n");
+            mLock.unlock();
+            delete inVoip;
+            return 0;
+        }
+        mVoipInputs.add(inVoip);
+        mLock.unlock();
+         if (mVoipOutActive) {
+            inVoip->mSetupDevice = true;
+            setupDeviceforVoipCall(true);
+         }
+        return inVoip;
+    } else
+#endif /*QCOM_VOIP_ENABLED*/
+    {
+        AudioStreamInMSM72xx* in = new AudioStreamInMSM72xx();
+        status_t lStatus = in->set(this, devices, format, channels, sampleRate, acoustic_flags);
+        if (status) {
+            *status = lStatus;
+        }
+        if (lStatus != NO_ERROR) {
+            mLock.unlock();
+            delete in;
+            return 0;
+        }
+
+        mInputs.add(in);
+        mLock.unlock();
+        return in;
+    }
+
+}
+
+void AudioHardware::closeInputStream(AudioStreamIn* in) {
+    Mutex::Autolock lock(mLock);
+
+    ssize_t index = -1;
+    if((index = mInputs.indexOf((AudioStreamInMSM72xx *)in)) >= 0) {
+        ALOGV("closeInputStream AudioStreamInMSM72xx");
+        mLock.unlock();
+        delete mInputs[index];
+        mLock.lock();
+        mInputs.removeAt(index);
+    }
+#ifdef QCOM_VOIP_ENABLED
+    else if ((index = mVoipInputs.indexOf((AudioStreamInVoip *)in)) >= 0) {
+        ALOGV("closeInputStream mVoipInputs");
+        mLock.unlock();
+        delete mVoipInputs[index];
+        mLock.lock();
+        mVoipInputs.removeAt(index);
+    }
+#endif /*QCOM_VOIP_ENABLED*/
+    else {
+        ALOGE("Attempt to close invalid input stream");
+    }
+}
+
+status_t AudioHardware::setMode(int mode)
+{
+    status_t status = AudioHardwareBase::setMode(mode);
+    if (status == NO_ERROR) {
+        // make sure that doAudioRouteOrMute() is called by doRouting()
+        // even if the new device selected is the same as current one.
+        clearCurDevice();
+    }
+    return status;
+}
+
+bool AudioHardware::checkOutputStandby()
+{
+    if (mOutput)
+        if (!mOutput->checkStandby())
+            return false;
+
+    return true;
+}
+
+status_t AudioHardware::setMicMute(bool state)
+{
+    Mutex::Autolock lock(mLock);
+    return setMicMute_nosync(state);
+}
+
+// always call with mutex held
+status_t AudioHardware::setMicMute_nosync(bool state)
+{
+    if (mMicMute != state) {
+        mMicMute = state;
+        return doAudioRouteOrMute(SND_DEVICE_CURRENT);
+    }
+    return NO_ERROR;
+}
+
+status_t AudioHardware::getMicMute(bool* state)
+{
+    *state = mMicMute;
+    return NO_ERROR;
+}
+
+status_t AudioHardware::setParameters(const String8& keyValuePairs)
+{
+    AudioParameter param = AudioParameter(keyValuePairs);
+    String8 value;
+    String8 key;
+
+    const char BT_NREC_KEY[] = "bt_headset_nrec";
+    const char BT_NAME_KEY[] = "bt_headset_name";
+    const char BT_NREC_VALUE_ON[] = "on";
+#ifdef SRS_PROCESSING
+    int to_set=0;
+    ALOGV("setParameters() %s", keyValuePairs.string());
+    if(strncmp("SRS_Buffer", keyValuePairs.string(), 10) == 0) {
+        int SRSptr = 0;
+        String8 keySRSG  = String8("SRS_BufferG"), keySRSW  = String8("SRS_BufferW"),
+          keySRSC  = String8("SRS_BufferC"), keySRSHP = String8("SRS_BufferHP"),
+          keySRSP  = String8("SRS_BufferP"), keySRSHL = String8("SRS_BufferHL");
+        if (param.getInt(keySRSG, SRSptr) == NO_ERROR) {
+            SRSParamsG = (void*)SRSptr;
+            to_set |= SRS_PARAMS_G;
+        } else if (param.getInt(keySRSW, SRSptr) == NO_ERROR) {
+            SRSParamsW = (void*)SRSptr;
+            to_set |= SRS_PARAMS_W;
+        } else if (param.getInt(keySRSC, SRSptr) == NO_ERROR) {
+            SRSParamsC = (void*)SRSptr;
+            to_set |= SRS_PARAMS_C;
+        } else if (param.getInt(keySRSHP, SRSptr) == NO_ERROR) {
+            SRSParamsHP = (void*)SRSptr;
+            to_set |= SRS_PARAMS_HP;
+        } else if (param.getInt(keySRSP, SRSptr) == NO_ERROR) {
+            SRSParamsP = (void*)SRSptr;
+            to_set |= SRS_PARAMS_P;
+        } else if (param.getInt(keySRSHL, SRSptr) == NO_ERROR) {
+            SRSParamsHL = (void*)SRSptr;
+            to_set |= SRS_PARAMS_HL;
+        }
+
+        ALOGD("SetParam SRS flags=0x%x", to_set);
+
+        if(hpcm_playback_in_progress
+#ifdef QCOM_TUNNEL_LPA_ENABLED
+         || lpa_playback_in_progress
+#endif
+        ) {
+            msm72xx_enable_srs(to_set, true);
+        }
+
+        if(SRSptr)
+            return NO_ERROR;
+
+    }
+#endif /*SRS_PROCESSING*/
+    if (keyValuePairs.length() == 0) return BAD_VALUE;
+
+    key = String8(BT_NREC_KEY);
+    if (param.get(key, value) == NO_ERROR) {
+        if (value == BT_NREC_VALUE_ON) {
+            mBluetoothNrec = true;
+        } else {
+            mBluetoothNrec = false;
+            ALOGI("Turning noise reduction and echo cancellation off for BT "
+                 "headset");
+        }
+    }
+    key = String8(BTHEADSET_VGS);
+    if (param.get(key, value) == NO_ERROR) {
+        if (value == BT_NREC_VALUE_ON) {
+            mBluetoothVGS = true;
+        } else {
+            mBluetoothVGS = false;
+        }
+    }
+    key = String8(BT_NAME_KEY);
+    if (param.get(key, value) == NO_ERROR) {
+        mBluetoothId = 0;
+        for (int i = 0; i < mNumCadEndpoints; i++) {
+            if (!strcasecmp(value.string(), mCadEndpoints[i].name)) {
+                mBluetoothId = mCadEndpoints[i].id;
+                ALOGI("Using custom acoustic parameters for %s", value.string());
+                break;
+            }
+        }
+        if (mBluetoothId == 0) {
+            ALOGI("Using default acoustic parameters "
+                 "(%s not in acoustic database)", value.string());
+            doRouting(NULL);
+        }
+    }
+
+    key = String8(DUALMIC_KEY);
+    if (param.get(key, value) == NO_ERROR) {
+        if (value == "true") {
+            mDualMicEnabled = true;
+            ALOGI("DualMike feature Enabled");
+        } else {
+            mDualMicEnabled = false;
+            ALOGI("DualMike feature Disabled");
+        }
+        doRouting(NULL);
+    }
+
+    key = String8(TTY_MODE_KEY);
+    if (param.get(key, value) == NO_ERROR) {
+        if (value == "full") {
+            mTtyMode = TTY_FULL;
+        } else if (value == "hco") {
+            mTtyMode = TTY_HCO;
+        } else if (value == "vco") {
+            mTtyMode = TTY_VCO;
+        } else {
+            mTtyMode = TTY_OFF;
+        }
+        if(mMode != AudioSystem::MODE_IN_CALL){
+           return NO_ERROR;
+        }
+        ALOGI("Changed TTY Mode=%s", value.string());
+        if((mMode == AudioSystem::MODE_IN_CALL) &&
+           (mCurSndDevice == SND_DEVICE_HEADSET))
+           doRouting(NULL);
+    }
+#ifdef QCOM_VOIP_ENABLED
+    key = String8(VOIPRATE_KEY);
+    if (param.get(key, value) == NO_ERROR) {
+        mVoipBitRate = atoi(value);
+        ALOGI("VOIP Bitrate =%d", mVoipBitRate);
+        param.remove(key);
+    }
+#endif /*QCOM_VOIP_ENABLED*/
+    return NO_ERROR;
+}
+#ifdef QCOM_VOIP_ENABLED
+
+uint32_t AudioHardware::getMvsMode(int format)
+{
+    switch(format) {
+    case AudioSystem::PCM_16_BIT:
+         if(rate == AUDIO_HW_VOIP_SAMPLERATE_8K) {
+            return MVS_MODE_PCM;
+        } else if(rate== AUDIO_HW_VOIP_SAMPLERATE_16K) {
+            return MVS_MODE_PCM_WB;
+        } else {
+            return MVS_MODE_PCM;
+        }
+        break;
+    case AudioSystem::AMR_NB:
+        return MVS_MODE_AMR;
+        break;
+    case AudioSystem::AMR_WB:
+        return MVS_MODE_AMR_WB;
+        break;
+    case AudioSystem::EVRC:
+        return   MVS_MODE_IS127;
+        break;
+    case AudioSystem::EVRCB:
+        return MVS_MODE_4GV_NB;
+        break;
+    case AudioSystem::EVRCWB:
+        return MVS_MODE_4GV_WB;
+        break;
+    default:
+        return BAD_INDEX;
+    }
+}
+
+uint32_t AudioHardware::getMvsRateType(uint32_t mvsMode, uint32_t *rateType)
+{
+    int ret = 0;
+
+    switch (mvsMode) {
+    case MVS_MODE_AMR: {
+        switch (mVoipBitRate) {
+        case 4750:
+            *rateType = MVS_AMR_MODE_0475;
+            break;
+        case 5150:
+            *rateType = MVS_AMR_MODE_0515;
+            break;
+        case 5900:
+            *rateType = MVS_AMR_MODE_0590;
+            break;
+        case 6700:
+            *rateType = MVS_AMR_MODE_0670;
+            break;
+        case 7400:
+            *rateType = MVS_AMR_MODE_0740;
+            break;
+        case 7950:
+            *rateType = MVS_AMR_MODE_0795;
+            break;
+        case 10200:
+            *rateType = MVS_AMR_MODE_1020;
+            break;
+        case 12200:
+            *rateType = MVS_AMR_MODE_1220;
+            break;
+        default:
+            ALOGD("wrong rate for AMR NB.\n");
+            ret = -EINVAL;
+        break;
+        }
+        break;
+    }
+    case MVS_MODE_AMR_WB: {
+        switch (mVoipBitRate) {
+        case 6600:
+            *rateType = MVS_AMR_MODE_0660;
+            break;
+        case 8850:
+            *rateType = MVS_AMR_MODE_0885;
+            break;
+        case 12650:
+            *rateType = MVS_AMR_MODE_1265;
+            break;
+        case 14250:
+            *rateType = MVS_AMR_MODE_1425;
+            break;
+        case 15850:
+            *rateType = MVS_AMR_MODE_1585;
+            break;
+        case 18250:
+            *rateType = MVS_AMR_MODE_1825;
+            break;
+        case 19850:
+            *rateType = MVS_AMR_MODE_1985;
+            break;
+        case 23050:
+            *rateType = MVS_AMR_MODE_2305;
+            break;
+        case 23850:
+            *rateType = MVS_AMR_MODE_2385;
+            break;
+        default:
+            ALOGD("wrong rate for AMR_WB.\n");
+            ret = -EINVAL;
+            break;
+        }
+    break;
+    }
+    case MVS_MODE_PCM:
+    case MVS_MODE_PCM_WB:
+        *rateType = 0;
+        break;
+    case MVS_MODE_IS127:
+    case MVS_MODE_4GV_NB:
+    case MVS_MODE_4GV_WB: {
+        switch (mVoipBitRate) {
+        case MVS_VOC_0_RATE:
+        case MVS_VOC_8_RATE:
+        case MVS_VOC_4_RATE:
+        case MVS_VOC_2_RATE:
+        case MVS_VOC_1_RATE:
+            *rateType = mVoipBitRate;
+            break;
+        default:
+            ALOGE("wrong rate for IS127/4GV_NB/WB.\n");
+            ret = -EINVAL;
+            break;
+        }
+        break;
+    }
+        default:
+        ALOGE("wrong mode type.\n");
+        ret = -EINVAL;
+    }
+    ALOGD("mode=%d, rate=%u, rateType=%d\n",
+        mvsMode, mVoipBitRate, *rateType);
+    return ret;
+}
+#endif /*QCOM_VOIP_ENABLED*/
+String8 AudioHardware::getParameters(const String8& keys)
+{
+    AudioParameter param = AudioParameter(keys);
+    String8 value;
+
+    String8 key = String8(DUALMIC_KEY);
+
+    if (param.get(key, value) == NO_ERROR) {
+        value = String8(mDualMicEnabled ? "true" : "false");
+        param.add(key, value);
+    }
+
+    key = String8(BTHEADSET_VGS);
+    if (param.get(key, value) == NO_ERROR) {
+        if(mBluetoothVGS)
+           param.addInt(String8("isVGS"), true);
+    }
+
+    key = String8("tunneled-input-formats");
+    if ( param.get(key,value) == NO_ERROR ) {
+        param.addInt(String8("AMR"), true );
+        if (mMode == AudioSystem::MODE_IN_CALL) {
+            param.addInt(String8("QCELP"), true );
+            param.addInt(String8("EVRC"), true );
+        }
+    }
+#ifdef QCOM_FM_ENABLED
+    key = String8("Fm-radio");
+    if ( param.get(key,value) == NO_ERROR ) {
+        if (IsFmon()||(mCurSndDevice == SND_DEVICE_FM_ANALOG_STEREO_HEADSET)){
+            param.addInt(String8("isFMON"), true );
+        }
+    }
+#endif
+    key = String8(ECHO_SUPRESSION);
+    if (param.get(key, value) == NO_ERROR) {
+        value = String8("yes");
+        param.add(key, value);
+    }
+
+    key = String8(AudioParameter::keyFluenceType);
+    if (param.get(key, value) == NO_ERROR) {
+       if (mDualMicEnabled) {
+            value = String8("fluence");
+            param.add(key, value);
+       } else {
+            value = String8("none");
+            param.add(key, value);
+       }
+    }
+
+    ALOGV("AudioHardware::getParameters() %s", param.toString().string());
+    return param.toString();
+}
+
+
+#ifdef SRS_PROCESSING
+static void msm72xx_enable_srs(int flags, bool state)
+{
+    int fd = open(PCM_CTL_DEVICE, O_RDWR);
+    if (fd < 0) {
+        ALOGE("Cannot open PCM Ctl device for srs params");
+        return;
+    }
+
+    ALOGD("Enable SRS flags=0x%x state= %d",flags,state);
+    if (state == false) {
+        if(post_proc_feature_mask & SRS_ENABLE) {
+            post_proc_feature_mask &= SRS_DISABLE;
+        }
+        if(SRSParamsG) {
+            unsigned short int backup = ((unsigned short int*)SRSParamsG)[2];
+            ((unsigned short int*)SRSParamsG)[2] = 0;
+            ioctl(fd, AUDIO_SET_SRS_TRUMEDIA_PARAM, SRSParamsG);
+            ((unsigned short int*)SRSParamsG)[2] = backup;
+        }
+    } else {
+        post_proc_feature_mask |= SRS_ENABLE;
+        if(SRSParamsW && (flags & SRS_PARAMS_W))
+            ioctl(fd, AUDIO_SET_SRS_TRUMEDIA_PARAM, SRSParamsW);
+        if(SRSParamsC && (flags & SRS_PARAMS_C))
+            ioctl(fd, AUDIO_SET_SRS_TRUMEDIA_PARAM, SRSParamsC);
+        if(SRSParamsHP && (flags & SRS_PARAMS_HP))
+            ioctl(fd, AUDIO_SET_SRS_TRUMEDIA_PARAM, SRSParamsHP);
+        if(SRSParamsP && (flags & SRS_PARAMS_P))
+            ioctl(fd, AUDIO_SET_SRS_TRUMEDIA_PARAM, SRSParamsP);
+        if(SRSParamsHL && (flags & SRS_PARAMS_HL))
+            ioctl(fd, AUDIO_SET_SRS_TRUMEDIA_PARAM, SRSParamsHL);
+        if(SRSParamsG && (flags & SRS_PARAMS_G))
+            ioctl(fd, AUDIO_SET_SRS_TRUMEDIA_PARAM, SRSParamsG);
+    }
+
+    if (ioctl(fd, AUDIO_ENABLE_AUDPP, &post_proc_feature_mask) < 0) {
+        ALOGE("enable audpp error");
+    }
+
+    close(fd);
+}
+
+#endif /*SRS_PROCESSING*/
+
+size_t AudioHardware::getInputBufferSize(uint32_t sampleRate, int format, int channelCount)
+{
+    ALOGD("AudioHardware::getInputBufferSize sampleRate %d format %d channelCount %d"
+            ,sampleRate, format, channelCount);
+    if ( (format != AudioSystem::PCM_16_BIT) &&
+         (format != AudioSystem::AMR_NB)     &&
+         (format != AudioSystem::AMR_WB)     &&
+         (format != AudioSystem::EVRC)       &&
+         (format != AudioSystem::EVRCB)      &&
+         (format != AudioSystem::EVRCWB)     &&
+         (format != AudioSystem::QCELP)      &&
+         (format != AudioSystem::AAC)){
+        ALOGW("getInputBufferSize bad format: 0x%x", format);
+        return 0;
+    }
+    if (channelCount < 1 || channelCount > 2) {
+        ALOGW("getInputBufferSize bad channel count: %d", channelCount);
+        return 0;
+    }
+
+    if(format == AudioSystem::AMR_NB)
+       return 320*channelCount;
+    else if (format == AudioSystem::EVRC)
+       return 230*channelCount;
+    else if (format == AudioSystem::QCELP)
+       return 350*channelCount;
+    else if (format == AudioSystem::AAC)
+       return 2048;
+#ifdef QCOM_VOIP_ENABLED
+    else if (sampleRate == AUDIO_HW_VOIP_SAMPLERATE_8K)
+       return 320*channelCount;
+    else if (sampleRate == AUDIO_HW_VOIP_SAMPLERATE_16K)
+       return 640*channelCount;
+#endif
+    else
+       return 2048*channelCount;
+}
+
+static status_t set_volume_rpc(uint32_t rx_device,
+                               uint32_t tx_device,
+                               uint32_t method,
+                               uint32_t volume,
+                               int m7xsnddriverfd)
+{
+
+    ALOGD("rpc_snd_set_volume(%d, %d, %d, %d)\n", rx_device, tx_device, method, volume);
+    if (rx_device == -1UL && tx_device == -1UL) return NO_ERROR;
+
+    if (m7xsnddriverfd < 0) {
+        ALOGE("Can not open snd device");
+        return -EPERM;
+    }
+    /* rpc_snd_set_volume(
+     *     device,            # Any hardware device enum, including
+     *                        # SND_DEVICE_CURRENT
+     *     method,            # must be SND_METHOD_VOICE to do anything useful
+     *     volume,            # integer volume level, in range [0,5].
+     *                        # note that 0 is audible (not quite muted)
+     *  )
+     * rpc_snd_set_volume only works for in-call sound volume.
+     */
+     struct msm_cad_volume_config args;
+     args.device.rx_device = rx_device;
+     args.device.tx_device = tx_device;
+     args.method = method;
+     args.volume = volume;
+
+     if (ioctl(m7xsnddriverfd, CAD_SET_VOLUME, &args) < 0) {
+         ALOGE("snd_set_volume error.");
+         return -EIO;
+     }
+     return NO_ERROR;
+}
+
+status_t AudioHardware::setVoiceVolume(float v)
+{
+    if (v < 0.0) {
+        ALOGW("setVoiceVolume(%f) under 0.0, assuming 0.0\n", v);
+        v = 0.0;
+    } else if (v > 1.0) {
+        ALOGW("setVoiceVolume(%f) over 1.0, assuming 1.0\n", v);
+        v = 1.0;
+    }
+    // Added 0.4 to current volume, as in voice call Mute cannot be set as minimum volume(0.00)
+    // setting Rx volume level as 2 for minimum and 7 as max level.
+    v = 0.4 + v;
+
+    int vol = lrint(v * 5.0);
+    ALOGD("setVoiceVolume(%f)\n", v);
+    ALOGI("Setting in-call volume to %d (available range is 2 to 7)\n", vol);
+
+    if ((mCurSndDevice != -1) && ((mCurSndDevice == SND_DEVICE_TTY_HEADSET) || (mCurSndDevice == SND_DEVICE_TTY_VCO)))
+    {
+        vol = 1;
+        ALOGI("For TTY device in FULL or VCO mode, the volume level is set to: %d \n", vol);
+    }
+
+    Mutex::Autolock lock(mLock);
+    set_volume_rpc(CAD_HW_DEVICE_ID_CURRENT_RX, CAD_HW_DEVICE_ID_CURRENT_TX, SND_METHOD_VOICE, vol, m7xsnddriverfd);
+    return NO_ERROR;
+}
+
+#ifdef QCOM_FM_ENABLED
+status_t AudioHardware::setFmVolume(float v)
+{
+    if (v < 0.0) {
+        ALOGW("setFmVolume(%f) under 0.0, assuming 0.0\n", v);
+        v = 0.0;
+    } else if (v > 1.0) {
+        ALOGW("setFmVolume(%f) over 1.0, assuming 1.0\n", v);
+        v = 1.0;
+    }
+
+    int vol = lrint(v * 7.5);
+    if (vol > 7)
+        vol = 7;
+    ALOGD("setFmVolume(%f)\n", v);
+    Mutex::Autolock lock(mLock);
+    set_volume_rpc(CAD_HW_DEVICE_ID_CURRENT_RX, CAD_HW_DEVICE_ID_CURRENT_TX, SND_METHOD_VOICE, vol, m7xsnddriverfd);
+    return NO_ERROR;
+}
+#endif
+
+status_t AudioHardware::setMasterVolume(float v)
+{
+    Mutex::Autolock lock(mLock);
+    int vol = ceil(v * 7.0);
+    ALOGI("Set master volume to %d.\n", vol);
+    set_volume_rpc(CAD_HW_DEVICE_ID_HANDSET_SPKR, CAD_HW_DEVICE_ID_HANDSET_MIC, SND_METHOD_VOICE, vol, m7xsnddriverfd);
+    set_volume_rpc(CAD_HW_DEVICE_ID_SPEAKER_PHONE_MONO, CAD_HW_DEVICE_ID_SPEAKER_PHONE_MIC, SND_METHOD_VOICE, vol, m7xsnddriverfd);
+    set_volume_rpc(CAD_HW_DEVICE_ID_BT_SCO_SPKR, CAD_HW_DEVICE_ID_BT_SCO_MIC, SND_METHOD_VOICE, vol, m7xsnddriverfd);
+    set_volume_rpc(CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO, CAD_HW_DEVICE_ID_HEADSET_MIC, SND_METHOD_VOICE, vol, m7xsnddriverfd);
+    set_volume_rpc(CAD_HW_DEVICE_ID_HANDSET_SPKR, CAD_HW_DEVICE_ID_HANDSET_MIC_ENDFIRE, SND_METHOD_VOICE, vol, m7xsnddriverfd);
+    set_volume_rpc(CAD_HW_DEVICE_ID_SPEAKER_PHONE_MONO, CAD_HW_DEVICE_ID_SPEAKER_PHONE_MIC_ENDFIRE, SND_METHOD_VOICE, vol, m7xsnddriverfd);
+    set_volume_rpc(CAD_HW_DEVICE_ID_TTY_HEADSET_SPKR, CAD_HW_DEVICE_ID_TTY_HEADSET_MIC, SND_METHOD_VOICE, 1, m7xsnddriverfd);
+    set_volume_rpc(CAD_HW_DEVICE_ID_TTY_HEADSET_SPKR, CAD_HW_DEVICE_ID_HANDSET_MIC, SND_METHOD_VOICE, 1, m7xsnddriverfd);
+    // We return an error code here to let the audioflinger do in-software
+    // volume on top of the maximum volume that we set through the SND API.
+    // return error - software mixer will handle it
+    return -1;
+}
+
+static status_t do_route_audio_rpc(uint32_t device,
+                                   bool ear_mute, bool mic_mute, int m7xsnddriverfd)
+{
+
+    ALOGW("rpc_snd_set_device(%d, %d, %d)\n", device, ear_mute, mic_mute);
+
+    if (m7xsnddriverfd < 0) {
+        ALOGE("Can not open snd device");
+        return -EPERM;
+    }
+    // RPC call to switch audio path
+    /* rpc_snd_set_device(
+     *     device,            # Hardware device enum to use
+     *     ear_mute,          # Set mute for outgoing voice audio
+     *                        # this should only be unmuted when in-call
+     *     mic_mute,          # Set mute for incoming voice audio
+     *                        # this should only be unmuted when in-call or
+     *                        # recording.
+     *  )
+     */
+    struct msm_cad_device_config args;
+    args.ear_mute = ear_mute ? SND_MUTE_MUTED : SND_MUTE_UNMUTED;
+    args.device.pathtype = CAD_DEVICE_PATH_RX_TX;
+    args.device.rx_device = -1;
+    args.device.tx_device = -1;
+
+    if(device == SND_DEVICE_HANDSET) {
+        args.device.rx_device = CAD_HW_DEVICE_ID_HANDSET_SPKR;
+        args.device.tx_device = CAD_HW_DEVICE_ID_HANDSET_MIC;
+        ALOGV("In HANDSET");
+    }
+    else if(device == SND_DEVICE_SPEAKER) {
+        args.device.rx_device = CAD_HW_DEVICE_ID_SPEAKER_PHONE_MONO;
+        args.device.tx_device = CAD_HW_DEVICE_ID_SPEAKER_PHONE_MIC;
+        ALOGV("In SPEAKER");
+    }
+    else if(device == SND_DEVICE_HEADSET) {
+        args.device.rx_device = CAD_HW_DEVICE_ID_HEADSET_SPKR_STEREO;
+        args.device.tx_device = CAD_HW_DEVICE_ID_HEADSET_MIC;
+        ALOGV("In HEADSET");
+    }
+    else if(device == SND_DEVICE_IN_S_SADC_OUT_HANDSET) {
+        args.device.rx_device = CAD_HW_DEVICE_ID_HANDSET_SPKR;
+	args.device.tx_device = CAD_HW_DEVICE_ID_HANDSET_MIC_ENDFIRE;
+        ALOGV("In DUALMIC_HANDSET");
+    }
+    else if(device == SND_DEVICE_IN_S_SADC_OUT_SPEAKER_PHONE) {
+        args.device.rx_device = CAD_HW_DEVICE_ID_SPEAKER_PHONE_MONO;
+        args.device.tx_device = CAD_HW_DEVICE_ID_SPEAKER_PHONE_MIC_ENDFIRE;
+        ALOGV("In DUALMIC_SPEAKER");
+    }
+    else if(device == SND_DEVICE_TTY_HEADSET) {
+        args.device.rx_device = CAD_HW_DEVICE_ID_TTY_HEADSET_SPKR;
+        args.device.tx_device = CAD_HW_DEVICE_ID_TTY_HEADSET_MIC;
+        ALOGV("In TTY_FULL");
+    }
+    else if(device == SND_DEVICE_TTY_VCO) {
+        args.device.rx_device = CAD_HW_DEVICE_ID_TTY_HEADSET_SPKR;
+        args.device.tx_device = CAD_HW_DEVICE_ID_HANDSET_MIC;
+        ALOGV("In TTY_VCO");
+    }
+    else if(device == SND_DEVICE_TTY_HCO) {
+        args.device.rx_device = CAD_HW_DEVICE_ID_HANDSET_SPKR;
+        args.device.tx_device = CAD_HW_DEVICE_ID_TTY_HEADSET_MIC;
+        ALOGV("In TTY_HCO");
+    }
+    else if(device == SND_DEVICE_BT) {
+        args.device.rx_device = CAD_HW_DEVICE_ID_BT_SCO_SPKR;
+        args.device.tx_device = CAD_HW_DEVICE_ID_BT_SCO_MIC;
+        ALOGV("In BT_HCO");
+    }
+    else if(device == SND_DEVICE_STEREO_HEADSET_AND_SPEAKER) {
+        args.device.rx_device = CAD_HW_DEVICE_ID_HEADSET_STEREO_PLUS_SPKR_MONO_RX;
+        args.device.tx_device = CAD_HW_DEVICE_ID_HEADSET_MIC;
+        ALOGV("In DEVICE_SPEAKER_HEADSET_AND_SPEAKER");
+    }
+    else if(device == SND_DEVICE_FM_ANALOG_STEREO_HEADSET_CODEC) {
+        args.device.rx_device = CAD_HW_DEVICE_ID_LP_FM_HEADSET_SPKR_STEREO_PLUS_HEADSET_SPKR_STEREO_RX;
+        args.device.tx_device = CAD_HW_DEVICE_ID_NONE;
+        ALOGV("In SND_DEVICE_FM_ANALOG_STEREO_HEADSET_CODEC");
+    }
+    else if(device == SND_DEVICE_FM_ANALOG_STEREO_HEADSET) {
+        args.device.rx_device = CAD_HW_DEVICE_ID_LP_FM_HEADSET_SPKR_STEREO_RX;
+        args.device.tx_device = CAD_HW_DEVICE_ID_NONE;
+        ALOGV("In SND_DEVICE_FM_ANALOG_STEREO_HEADSET");
+    }
+    else if (device == SND_DEVICE_FM_DIGITAL_STEREO_HEADSET) {
+        args.device.rx_device = CAD_HW_DEVICE_ID_FM_DIGITAL_HEADSET_SPKR_STEREO;
+        args.device.tx_device = CAD_HW_DEVICE_ID_NONE;
+        ALOGV("In SND_DEVICE_FM_DIGITAL_STEREO_HEADSET");
+    }
+    else if (device == SND_DEVICE_FM_DIGITAL_SPEAKER_PHONE) {
+        args.device.rx_device = CAD_HW_DEVICE_ID_FM_DIGITAL_SPEAKER_PHONE_MONO;
+        args.device.tx_device = CAD_HW_DEVICE_ID_FM_DIGITAL_SPEAKER_PHONE_MIC;
+        ALOGV("In SND_DEVICE_FM_DIGITAL_SPEAKER_PHONE");
+    }
+    else if (device == SND_DEVICE_FM_DIGITAL_BT_A2DP_HEADSET) {
+        args.device.rx_device = CAD_HW_DEVICE_ID_FM_DIGITAL_BT_A2DP_SPKR;
+        args.device.tx_device = CAD_HW_DEVICE_ID_NONE;
+        ALOGV("In SND_DEVICE_FM_DIGITAL_BT_A2DP_HEADSET");
+    }
+    else if(device == SND_DEVICE_CURRENT)
+    {
+        args.device.rx_device = CAD_HW_DEVICE_ID_CURRENT_RX;
+        args.device.tx_device = CAD_HW_DEVICE_ID_CURRENT_TX;
+        ALOGV("In SND_DEVICE_CURRENT");
+    }
+    ALOGW("rpc_snd_set_device(%d, %d, %d, %d)\n", args.device.rx_device, args.device.tx_device, ear_mute, mic_mute);
+
+    if(args.device.rx_device == -1 || args.device.tx_device == -1) {
+	   ALOGE("Error in setting rx and tx device");
+           return -1;
+    }
+
+    CAD_HW_DEVICE_ID_CURRENT_RX = args.device.rx_device;
+    CAD_HW_DEVICE_ID_CURRENT_TX = args.device.tx_device;
+    if((device != SND_DEVICE_CURRENT) && (!mic_mute)
+#ifdef QCOM_FM_ENABLED
+      &&(device != SND_DEVICE_FM_DIGITAL_STEREO_HEADSET)
+      &&(device != SND_DEVICE_FM_DIGITAL_SPEAKER_PHONE)
+      &&(device != SND_DEVICE_FM_DIGITAL_BT_A2DP_HEADSET)
+#endif
+       ) {
+        //Explicitly mute the mic to release DSP resources
+        args.mic_mute = SND_MUTE_MUTED;
+        if (ioctl(m7xsnddriverfd, CAD_SET_DEVICE, &args) < 0) {
+            ALOGE("snd_set_device error.");
+            return -EIO;
+        }
+    }
+    args.mic_mute = mic_mute ? SND_MUTE_MUTED : SND_MUTE_UNMUTED;
+    if (ioctl(m7xsnddriverfd, CAD_SET_DEVICE, &args) < 0) {
+        ALOGE("snd_set_device error.");
+        return -EIO;
+    }
+
+    return NO_ERROR;
+}
+
+// always call with mutex held
+status_t AudioHardware::doAudioRouteOrMute(uint32_t device)
+{
+    int rc;
+    int nEarmute=true;
+#if 0
+    if (device == (uint32_t)SND_DEVICE_BT || device == (uint32_t)SND_DEVICE_CARKIT) {
+        if (mBluetoothId) {
+            device = mBluetoothId;
+        } else if (!mBluetoothNrec) {
+            device = SND_DEVICE_BT_EC_OFF;
+        }
+    }
+#endif
+#ifdef QCOM_FM_ENABLED
+    if(IsFmon()){
+        /* FM needs both Rx path and Tx path to be unmuted */
+        nEarmute = false;
+        mMicMute = false;
+    } else
+#endif
+    if (mMode == AudioSystem::MODE_IN_CALL)
+        nEarmute = false;
+#ifdef QCOM_VOIP_ENABLED
+    else if(mMode == AudioSystem::MODE_IN_COMMUNICATION){
+        nEarmute = false;
+        ALOGW("VoipCall in MODE_IN_COMMUNICATION");
+    }
+#endif
+    rc = do_route_audio_rpc(device,
+                              nEarmute , mMicMute, m7xsnddriverfd);
+#ifdef QCOM_FM_ENABLED
+    if ((
+        (device == SND_DEVICE_FM_DIGITAL_STEREO_HEADSET) ||
+        (device == SND_DEVICE_FM_DIGITAL_SPEAKER_PHONE)  ||
+        (device == SND_DEVICE_FM_DIGITAL_BT_A2DP_HEADSET)) &&
+        (device != mCurSndDevice)) {
+        ALOGV("doAudioRouteOrMute():switch to FM mode");
+        switch_mode(MODE_FM);
+    } else if (((mCurSndDevice == SND_DEVICE_FM_DIGITAL_STEREO_HEADSET) ||
+        (mCurSndDevice == SND_DEVICE_FM_DIGITAL_SPEAKER_PHONE)  ||
+        (mCurSndDevice == SND_DEVICE_FM_DIGITAL_BT_A2DP_HEADSET)) &&
+        (device != mCurSndDevice)) {
+        ALOGV("doAudioRouteOrMute():switch to AUX PCM mode");
+        switch_mode(MODE_BTSCO);
+    }
+#endif
+    return rc;
+}
+
+#ifdef QCOM_FM_ENABLED
+bool AudioHardware::isFMAnalog()
+{
+    char value[PROPERTY_VALUE_MAX];
+    bool isAfm = false;
+
+    if (property_get("hw.fm.isAnalog", value, NULL)
+    && !strcasecmp(value, "true")){
+        isAfm = true;
+    }
+
+    return isAfm;
+}
+#endif
+status_t AudioHardware::doRouting(AudioStreamInMSM72xx *input, int outputDevice)
+{
+    /* currently this code doesn't work without the htc libacoustic */
+
+    Mutex::Autolock lock(mLock);
+    uint32_t outputDevices;
+    status_t ret = NO_ERROR;
+    int new_snd_device = -1;
+#ifdef QCOM_FM_ENABLED
+    bool enableDgtlFmDriver = false;
+#endif
+
+    if (outputDevice)
+        outputDevices = outputDevice;
+    else
+        outputDevices = mOutput->devices();
+
+    //int (*msm72xx_enable_audpp)(int);
+    //msm72xx_enable_audpp = (int (*)(int))::dlsym(acoustic, "msm72xx_enable_audpp");
+
+    if (input != NULL) {
+        uint32_t inputDevice = input->devices();
+        ALOGI("do input routing device %x\n", inputDevice);
+        // ignore routing device information when we start a recording in voice
+        // call
+        // Recording will happen through currently active tx device
+        if(inputDevice == AudioSystem::DEVICE_IN_VOICE_CALL)
+            return NO_ERROR;
+        if (inputDevice != 0) {
+            if (inputDevice & AudioSystem::DEVICE_IN_BLUETOOTH_SCO_HEADSET) {
+                ALOGI("Routing audio to Bluetooth PCM\n");
+                new_snd_device = SND_DEVICE_BT;
+            } else if (inputDevice & AudioSystem::DEVICE_IN_WIRED_HEADSET) {
+                    ALOGI("Routing audio to Wired Headset\n");
+                    new_snd_device = SND_DEVICE_HEADSET;
+#ifdef QCOM_FM_ENABLED
+            } else if (inputDevice & AudioSystem::DEVICE_IN_FM_RX_A2DP) {
+                    ALOGI("Routing audio from FM to Bluetooth A2DP\n");
+                    new_snd_device = SND_DEVICE_FM_DIGITAL_BT_A2DP_HEADSET;
+                    FmA2dpStatus=true;
+            } else if (inputDevice & AudioSystem::DEVICE_IN_FM_RX) {
+                    ALOGI("Routing audio to FM\n");
+                    enableDgtlFmDriver = true;
+#endif
+            } else {
+                if (outputDevices & AudioSystem::DEVICE_OUT_SPEAKER) {
+                    ALOGI("Routing audio to Speakerphone\n");
+                    new_snd_device = SND_DEVICE_SPEAKER;
+                } else {
+                    ALOGI("Routing audio to Handset\n");
+                    new_snd_device = SND_DEVICE_HANDSET;
+                }
+            }
+        }
+    }
+
+    // if inputDevice == 0, restore output routing
+    if (new_snd_device == -1) {
+        if (outputDevices & (outputDevices - 1)) {
+            if ((outputDevices & AudioSystem::DEVICE_OUT_SPEAKER) == 0) {
+                ALOGV("Hardware does not support requested route combination (%#X),"
+                     " picking closest possible route...", outputDevices);
+            }
+        }
+
+        if ((mTtyMode != TTY_OFF) && (mMode == AudioSystem::MODE_IN_CALL) &&
+                (outputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADSET)) {
+            if (mTtyMode == TTY_FULL) {
+                ALOGI("Routing audio to TTY FULL Mode\n");
+                new_snd_device = SND_DEVICE_TTY_HEADSET;
+            } else if (mTtyMode == TTY_VCO) {
+                ALOGI("Routing audio to TTY VCO Mode\n");
+                new_snd_device = SND_DEVICE_TTY_VCO;
+            } else if (mTtyMode == TTY_HCO) {
+                ALOGI("Routing audio to TTY HCO Mode\n");
+                new_snd_device = SND_DEVICE_TTY_HCO;
+            }
+#ifdef COMBO_DEVICE_SUPPORTED
+        } else if ((outputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADSET) &&
+                   (outputDevices & AudioSystem::DEVICE_OUT_SPEAKER)) {
+            ALOGI("Routing audio to Wired Headset and Speaker\n");
+            new_snd_device = SND_DEVICE_STEREO_HEADSET_AND_SPEAKER;
+        } else if ((outputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADPHONE) &&
+                   (outputDevices & AudioSystem::DEVICE_OUT_SPEAKER)) {
+            ALOGI("Routing audio to No microphone Wired Headset and Speaker (%d,%x)\n", mMode, outputDevices);
+            new_snd_device = SND_DEVICE_STEREO_HEADSET_AND_SPEAKER;
+#endif
+#ifdef QCOM_FM_ENABLED
+        } else if ((outputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADSET) &&
+                   (outputDevices & AudioSystem::DEVICE_OUT_FM)) {
+            if( !isFMAnalog() ){
+                ALOGI("Routing FM to Wired Headset\n");
+                new_snd_device = SND_DEVICE_FM_DIGITAL_STEREO_HEADSET;
+                enableDgtlFmDriver = true;
+            } else{
+                ALOGW("Enabling Anlg FM + codec device\n");
+                new_snd_device = SND_DEVICE_FM_ANALOG_STEREO_HEADSET_CODEC;
+                enableDgtlFmDriver = false;
+            }
+        } else if ((outputDevices & AudioSystem::DEVICE_OUT_SPEAKER) &&
+                   (outputDevices & AudioSystem::DEVICE_OUT_FM)) {
+            ALOGI("Routing FM to Speakerphone\n");
+            new_snd_device = SND_DEVICE_FM_DIGITAL_SPEAKER_PHONE;
+            enableDgtlFmDriver = true;
+        } else if ( (outputDevices & AudioSystem::DEVICE_OUT_FM) && isFMAnalog()) {
+            ALOGW("Enabling Anlg FM on wired headset\n");
+            new_snd_device = SND_DEVICE_FM_ANALOG_STEREO_HEADSET;
+            enableDgtlFmDriver = false;
+#endif
+        } else if (outputDevices &
+                   (AudioSystem::DEVICE_OUT_BLUETOOTH_SCO | AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_HEADSET)) {
+            ALOGI("Routing audio to Bluetooth PCM\n");
+            new_snd_device = SND_DEVICE_BT;
+        } else if (outputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADSET) {
+            ALOGI("Routing audio to Wired Headset\n");
+            new_snd_device = SND_DEVICE_HEADSET;
+        } else if (outputDevices & AudioSystem::DEVICE_OUT_SPEAKER) {
+            ALOGI("Routing audio to Speakerphone\n");
+            new_snd_device = SND_DEVICE_SPEAKER;
+        } else if (outputDevices & AudioSystem::DEVICE_OUT_EARPIECE) {
+            ALOGI("Routing audio to Handset\n");
+            new_snd_device = SND_DEVICE_HANDSET;
+        }
+    }
+
+    if (mDualMicEnabled && (mMode == AudioSystem::MODE_IN_CALL || mMode == AudioSystem::MODE_IN_COMMUNICATION)) {
+        if (new_snd_device == SND_DEVICE_HANDSET) {
+            ALOGI("Routing audio to handset with DualMike enabled\n");
+            new_snd_device = SND_DEVICE_IN_S_SADC_OUT_HANDSET;
+        } else if (new_snd_device == SND_DEVICE_SPEAKER) {
+            ALOGI("Routing audio to speakerphone with DualMike enabled\n");
+            new_snd_device = SND_DEVICE_IN_S_SADC_OUT_SPEAKER_PHONE;
+        }
+    }
+#ifdef QCOM_FM_ENABLED
+    if ((mFmFd == -1) && enableDgtlFmDriver ) {
+        enableFM();
+    } else if ((mFmFd != -1) && !enableDgtlFmDriver ) {
+        disableFM();
+    }
+
+    if((outputDevices  == 0) && (FmA2dpStatus == true))
+       new_snd_device = SND_DEVICE_FM_DIGITAL_BT_A2DP_HEADSET;
+#endif
+
+    if (new_snd_device != -1 && new_snd_device != mCurSndDevice) {
+        ret = doAudioRouteOrMute(new_snd_device);
+
+        //disable post proc first for previous session
+        if(hpcm_playback_in_progress
+#ifdef QCOM_TUNNEL_LPA_ENABLED
+         || lpa_playback_in_progress
+#endif
+         ) {
+#ifdef SRS_PROCESSING
+            msm72xx_enable_srs(SRS_PARAMS_ALL, false);
+#endif /*SRS_PROCESSING*/
+        }
+
+        //enable post proc for new device
+        snd_device = new_snd_device;
+
+        if(hpcm_playback_in_progress
+#ifdef QCOM_TUNNEL_LPA_ENABLED
+         || lpa_playback_in_progress
+#endif
+         ){
+#ifdef SRS_PROCESSING
+            msm72xx_enable_srs(SRS_PARAMS_ALL, true);
+#endif /*SRS_PROCESSING*/
+        }
+
+        mCurSndDevice = new_snd_device;
+    }
+
+    return ret;
+}
+
+#ifdef QCOM_FM_ENABLED
+status_t AudioHardware::enableFM()
+{
+    ALOGD("enableFM");
+    status_t status = NO_INIT;
+    status = ::open(FM_DEVICE, O_RDWR);
+    if (status < 0) {
+           ALOGE("Cannot open FM_DEVICE errno: %d", errno);
+           goto Error;
+    }
+    mFmFd = status;
+
+    status = ioctl(mFmFd, AUDIO_START, 0);
+
+    if (status < 0) {
+            ALOGE("Cannot do AUDIO_START");
+            goto Error;
+    }
+    return NO_ERROR;
+
+    Error:
+    if (mFmFd >= 0) {
+        ::close(mFmFd);
+        mFmFd = -1;
+    }
+    return NO_ERROR;
+}
+
+
+status_t AudioHardware::disableFM()
+{
+    int status;
+    ALOGD("disableFM");
+    if (mFmFd >= 0) {
+        status = ioctl(mFmFd, AUDIO_STOP, 0);
+        if (status < 0) {
+                ALOGE("Cannot do AUDIO_STOP");
+        }
+        ::close(mFmFd);
+        mFmFd = -1;
+    }
+
+    return NO_ERROR;
+}
+#endif
+status_t AudioHardware::checkMicMute()
+{
+    Mutex::Autolock lock(mLock);
+    if (mMode != AudioSystem::MODE_IN_CALL) {
+        setMicMute_nosync(true);
+    }
+
+    return NO_ERROR;
+}
+
+status_t AudioHardware::dumpInternals(int fd, const Vector<String16>& args)
+{
+    const size_t SIZE = 256;
+    char buffer[SIZE];
+    String8 result;
+    result.append("AudioHardware::dumpInternals\n");
+    snprintf(buffer, SIZE, "\tmInit: %s\n", mInit? "true": "false");
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmMicMute: %s\n", mMicMute? "true": "false");
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmBluetoothNrec: %s\n", mBluetoothNrec? "true": "false");
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmBluetoothId: %d\n", mBluetoothId);
+    result.append(buffer);
+    ::write(fd, result.string(), result.size());
+    return NO_ERROR;
+}
+
+status_t AudioHardware::dump(int fd, const Vector<String16>& args)
+{
+    dumpInternals(fd, args);
+    for (size_t index = 0; index < mInputs.size(); index++) {
+        mInputs[index]->dump(fd, args);
+    }
+
+    if (mOutput) {
+        mOutput->dump(fd, args);
+    }
+    return NO_ERROR;
+}
+
+uint32_t AudioHardware::getInputSampleRate(uint32_t sampleRate)
+{
+    uint32_t i;
+    uint32_t prevDelta;
+    uint32_t delta;
+
+    for (i = 0, prevDelta = 0xFFFFFFFF; i < sizeof(inputSamplingRates)/sizeof(uint32_t); i++, prevDelta = delta) {
+        delta = abs(sampleRate - inputSamplingRates[i]);
+        if (delta > prevDelta) break;
+    }
+    // i is always > 0 here
+    return inputSamplingRates[i-1];
+}
+
+// getActiveInput_l() must be called with mLock held
+AudioHardware::AudioStreamInMSM72xx *AudioHardware::getActiveInput_l()
+{
+    for (size_t i = 0; i < mInputs.size(); i++) {
+        // return first input found not being in standby mode
+        // as only one input can be in this state
+        if (mInputs[i]->state() > AudioStreamInMSM72xx::AUDIO_INPUT_CLOSED) {
+            return mInputs[i];
+        }
+    }
+
+    return NULL;
+}
+#ifdef QCOM_VOIP_ENABLED
+status_t AudioHardware::setupDeviceforVoipCall(bool value)
+{
+
+    int mode = (value ? AudioSystem::MODE_IN_COMMUNICATION : AudioSystem::MODE_NORMAL);
+    if (setMode(mode) != NO_ERROR) {
+        ALOGV("setMode fails");
+        return UNKNOWN_ERROR;
+    }
+
+    doRouting(NULL);
+
+    if (setMicMute(!value) != NO_ERROR) {
+        ALOGV("MicMute fails");
+        return UNKNOWN_ERROR;
+    }
+
+    ALOGD("Device setup sucess for VOIP call");
+
+    return NO_ERROR;
+}
+#endif /*QCOM_VOIP_ENABLED*/
+// ----------------------------------------------------------------------------
+
+
+//  VOIP stream class
+//.----------------------------------------------------------------------------
+#ifdef QCOM_VOIP_ENABLED
+AudioHardware::AudioStreamInVoip::AudioStreamInVoip() :
+    mHardware(0), mFd(-1), mState(AUDIO_INPUT_CLOSED), mRetryCount(0),
+    mFormat(AUDIO_HW_IN_FORMAT), mChannels(AUDIO_HW_IN_CHANNELS),
+    mSampleRate(AUDIO_HW_VOIP_SAMPLERATE_8K), mBufferSize(AUDIO_HW_VOIP_BUFFERSIZE_8K),
+    mAcoustics((AudioSystem::audio_in_acoustics)0), mDevices(0), mSetupDevice(false)
+{
+}
+
+
+status_t AudioHardware::AudioStreamInVoip::set(
+        AudioHardware* hw, uint32_t devices, int *pFormat, uint32_t *pChannels, uint32_t *pRate,
+        AudioSystem::audio_in_acoustics acoustic_flags)
+{
+    ALOGD("AudioStreamInVoip::set devices = %u format = %x pChannels = %u Rate = %u \n",
+         devices, *pFormat, *pChannels, *pRate);
+    if ((pFormat == 0) || BAD_INDEX == hw->getMvsMode(*pFormat)) {
+        ALOGE("Audio Format (%x) not supported \n",*pFormat);
+        return BAD_VALUE;
+    }
+
+    if (*pFormat == AudioSystem::PCM_16_BIT){
+    if (pRate == 0) {
+        return BAD_VALUE;
+    }
+    uint32_t rate = hw->getInputSampleRate(*pRate);
+    if (rate != *pRate) {
+        *pRate = rate;
+        ALOGE(" sample rate does not match\n");
+        return BAD_VALUE;
+    }
+
+    if (pChannels == 0 || (*pChannels & (AudioSystem::CHANNEL_IN_MONO)) == 0) {
+        *pChannels = AUDIO_HW_IN_CHANNELS;
+        ALOGE(" Channle count does not match\n");
+        return BAD_VALUE;
+    }
+
+    if(*pRate == AUDIO_HW_VOIP_SAMPLERATE_8K)
+       mBufferSize = 320;
+    else if(*pRate == AUDIO_HW_VOIP_SAMPLERATE_16K)
+       mBufferSize = 640;
+    else
+    {
+       ALOGE(" unsupported sample rate");
+       return -1;
+    }
+
+    }
+    mHardware = hw;
+
+    ALOGD("AudioStreamInVoip::set(%d, %d, %u)", *pFormat, *pChannels, *pRate);
+
+    status_t status = NO_INIT;
+    // open driver
+    ALOGV("Check if driver is open");
+    if(mHardware->mVoipFd >= 0) {
+        mFd = mHardware->mVoipFd;
+    } else {
+        ALOGE("open mvs driver");
+        status = ::open(MVS_DEVICE, /*O_WRONLY*/ O_RDWR);
+        if (status < 0) {
+            ALOGE("Cannot open %s errno: %d",MVS_DEVICE, errno);
+            goto Error;
+        }
+        mFd = status;
+        ALOGV("VOPIstreamin : Save the fd %d \n",mFd);
+        mHardware->mVoipFd = mFd;
+        // Increment voip stream count
+
+        // configuration
+        ALOGV("get mvs config");
+        struct msm_audio_mvs_config mvs_config;
+        status = ioctl(mFd, AUDIO_GET_MVS_CONFIG, &mvs_config);
+        if (status < 0) {
+           ALOGE("Cannot read mvs config");
+           goto Error;
+        }
+
+        mvs_config.mvs_mode = mHardware->getMvsMode(*pFormat);
+        status = mHardware->getMvsRateType(mvs_config.mvs_mode ,&mvs_config.rate_type);
+        ALOGD("set mvs config mode %d rate_type %d", mvs_config.mvs_mode, mvs_config.rate_type);
+        if (status < 0) {
+            ALOGE("Incorrect mvs type");
+            goto Error;
+        }
+        status = ioctl(mFd, AUDIO_SET_MVS_CONFIG, &mvs_config);
+        if (status < 0) {
+            ALOGE("Cannot set mvs config");
+            goto Error;
+        }
+
+        ALOGV("start mvs");
+        status = ioctl(mFd, AUDIO_START, 0);
+        if (status < 0) {
+            ALOGE("Cannot start mvs driver");
+            goto Error;
+        }
+    }
+    mFormat =  *pFormat;
+    mChannels = *pChannels;
+    mSampleRate = *pRate;
+    if(mSampleRate == AUDIO_HW_VOIP_SAMPLERATE_8K)
+       mBufferSize = 320;
+    else if(mSampleRate == AUDIO_HW_VOIP_SAMPLERATE_16K)
+       mBufferSize = 640;
+    else
+    {
+       ALOGE(" unsupported sample rate");
+       return -1;
+    }
+
+    ALOGV(" AudioHardware::AudioStreamInVoip::set after configuring devices\
+            = %u format = %d pChannels = %u Rate = %u \n",
+             devices, mFormat, mChannels, mSampleRate);
+
+    ALOGV(" Set state  AUDIO_INPUT_OPENED\n");
+    mState = AUDIO_INPUT_OPENED;
+
+    mHardware->mVoipInActive = true;
+
+    if (!acoustic)
+        return NO_ERROR;
+
+     return NO_ERROR;
+
+Error:
+    if (mFd >= 0) {
+        ::close(mFd);
+        mFd = -1;
+        mHardware->mVoipFd = -1;
+    }
+    ALOGE("Error : ret status \n");
+    return status;
+}
+
+
+AudioHardware::AudioStreamInVoip::~AudioStreamInVoip()
+{
+    ALOGV("AudioStreamInVoip destructor");
+    mHardware->mVoipInActive = false;
+    standby();
+}
+
+
+
+ssize_t AudioHardware::AudioStreamInVoip::read( void* buffer, ssize_t bytes)
+{
+//    ALOGV("AudioStreamInVoip::read(%p, %ld)", buffer, bytes);
+    if (!mHardware) return -1;
+
+    size_t count = bytes;
+    size_t totalBytesRead = 0;
+
+    if (mState < AUDIO_INPUT_OPENED) {
+       ALOGE(" reopen the device \n");
+        AudioHardware *hw = mHardware;
+        hw->mLock.lock();
+        status_t status = set(hw, mDevices, &mFormat, &mChannels, &mSampleRate, mAcoustics);
+        if (status != NO_ERROR) {
+            hw->mLock.unlock();
+            return -1;
+        }
+        hw->mLock.unlock();
+        mState = AUDIO_INPUT_STARTED;
+        bytes = 0;
+    } else {
+      ALOGV("AudioStreamInVoip::read : device is already open \n");
+    }
+
+    if(count < mBufferSize) {
+      ALOGE("read:: read size requested is less than min input buffer size");
+      return 0;
+    }
+    
+    if (!mSetupDevice) {
+        mSetupDevice = true;
+        mHardware->setupDeviceforVoipCall(true);
+    }
+    struct msm_audio_mvs_frame audio_mvs_frame;
+    memset(&audio_mvs_frame, 0, sizeof(audio_mvs_frame));
+    if(mFormat == AudioSystem::PCM_16_BIT) {
+    audio_mvs_frame.frame_type = 0;
+       while (count >= mBufferSize) {
+           audio_mvs_frame.len = mBufferSize;
+           ALOGV("Calling read count = %u mBufferSize = %u \n", count, mBufferSize);
+           int bytesRead = ::read(mFd, &audio_mvs_frame, sizeof(audio_mvs_frame));
+           ALOGV("PCM read_bytes = %d mvs\n", bytesRead);
+           if (bytesRead > 0) {
+                   memcpy(buffer+totalBytesRead, &audio_mvs_frame.voc_pkt, mBufferSize);
+                   count -= mBufferSize;
+                   totalBytesRead += mBufferSize;
+                   if(!mFirstread) {
+                       mFirstread = true;
+                       break;
+                   }
+               } else {
+                   ALOGE("retry read count = %d buffersize = %d\n", count, mBufferSize);
+                   if (errno != EAGAIN) return bytesRead;
+                   mRetryCount++;
+                   ALOGW("EAGAIN - retrying");
+               }
+       }
+    }else{
+        struct msm_audio_mvs_frame *mvsFramePtr = (msm_audio_mvs_frame *)buffer;
+        int bytesRead = ::read(mFd, &audio_mvs_frame, sizeof(audio_mvs_frame));
+        ALOGV("Non PCM read_bytes = %d frame type %d len %d\n", bytesRead, audio_mvs_frame.frame_type, audio_mvs_frame.len);
+        mvsFramePtr->frame_type = audio_mvs_frame.frame_type;
+        mvsFramePtr->len = audio_mvs_frame.len;
+        memcpy(&mvsFramePtr->voc_pkt, &audio_mvs_frame.voc_pkt, audio_mvs_frame.len);
+        totalBytesRead = bytes;
+    }
+  return bytes;
+}
+
+status_t AudioHardware::AudioStreamInVoip::standby()
+{
+    ALOGD("AudioStreamInVoip::standby");
+    Mutex::Autolock lock(mHardware->mVoipLock);
+
+    if (!mHardware) return -1;
+    ALOGE("VoipOut %d driver fd %d", mHardware->mVoipOutActive, mHardware->mVoipFd);
+    mHardware->mVoipInActive = false;
+    if (mState > AUDIO_INPUT_CLOSED && !mHardware->mVoipOutActive) {
+         int ret = 0;
+         if (mHardware->mVoipFd >= 0) {
+            ret = ioctl(mHardware->mVoipFd, AUDIO_STOP, NULL);
+            ALOGD("MVS stop returned %d %d %d\n", ret, __LINE__, mHardware->mVoipFd);
+            ::close(mFd);
+            mFd = mHardware->mVoipFd = -1;
+            mSetupDevice = false;
+            mHardware->setupDeviceforVoipCall(false);
+            ALOGD("MVS driver closed %d mFd %d", __LINE__, mHardware->mVoipFd);
+        }
+        mState = AUDIO_INPUT_CLOSED;
+    } else
+        ALOGE("Not closing MVS driver");
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioStreamInVoip::dump(int fd, const Vector<String16>& args)
+{
+    const size_t SIZE = 256;
+    char buffer[SIZE];
+    String8 result;
+    result.append("AudioStreamInVoip::dump\n");
+    snprintf(buffer, SIZE, "\tsample rate: %d\n", sampleRate());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tbuffer size: %d\n", bufferSize());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tchannels: %d\n", channels());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tformat: %d\n", format());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmHardware: %p\n", mHardware);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmFd count: %d\n", mFd);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmState: %d\n", mState);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmRetryCount: %d\n", mRetryCount);
+    result.append(buffer);
+    ::write(fd, result.string(), result.size());
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioStreamInVoip::setParameters(const String8& keyValuePairs)
+{
+    AudioParameter param = AudioParameter(keyValuePairs);
+    String8 key = String8(AudioParameter::keyRouting);
+    status_t status = NO_ERROR;
+    int device;
+    ALOGV("AudioStreamInVoip::setParameters() %s", keyValuePairs.string());
+
+    if (param.getInt(key, device) == NO_ERROR) {
+        ALOGV("set input routing %x", device);
+        if (device & (device - 1)) {
+            status = BAD_VALUE;
+        } else {
+            mDevices = device;
+            status = mHardware->doRouting(this);
+        }
+        param.remove(key);
+    }
+
+    if (param.size()) {
+        status = BAD_VALUE;
+    }
+    return status;
+}
+
+String8 AudioHardware::AudioStreamInVoip::getParameters(const String8& keys)
+{
+    AudioParameter param = AudioParameter(keys);
+    String8 value;
+    String8 key = String8(AudioParameter::keyRouting);
+
+    if (param.get(key, value) == NO_ERROR) {
+        ALOGV("get routing %x", mDevices);
+        param.addInt(key, (int)mDevices);
+    }
+
+    key = String8("voip_flag");
+    if (param.get(key, value) == NO_ERROR) {
+        param.addInt(key, true);
+    }
+
+    ALOGV("AudioStreamInVoip::getParameters() %s", param.toString().string());
+    return param.toString();
+}
+
+// getActiveInput_l() must be called with mLock held
+AudioHardware::AudioStreamInVoip*AudioHardware::getActiveVoipInput_l()
+{
+    for (size_t i = 0; i < mVoipInputs.size(); i++) {
+        // return first input found not being in standby mode
+        // as only one input can be in this state
+        if (mVoipInputs[i]->state() > AudioStreamInVoip::AUDIO_INPUT_CLOSED) {
+            return mVoipInputs[i];
+        }
+    }
+
+    return NULL;
+}
+#endif /*QCOM_VOIP_ENABLED*/
+// ---------------------------------------------------------------------------
+//  VOIP stream class end
+
+
+// ----------------------------------------------------------------------------
+
+AudioHardware::AudioStreamOutMSM72xx::AudioStreamOutMSM72xx() :
+    mHardware(0), mFd(-1), mStartCount(0), mRetryCount(0), mStandby(true), mDevices(0)
+{
+}
+
+status_t AudioHardware::AudioStreamOutMSM72xx::set(
+        AudioHardware* hw, uint32_t devices, int *pFormat, uint32_t *pChannels, uint32_t *pRate)
+{
+    int lFormat = pFormat ? *pFormat : 0;
+    uint32_t lChannels = pChannels ? *pChannels : 0;
+    uint32_t lRate = pRate ? *pRate : 0;
+
+    mHardware = hw;
+
+    // fix up defaults
+    if (lFormat == 0) lFormat = format();
+    if (lChannels == 0) lChannels = channels();
+    if (lRate == 0) lRate = sampleRate();
+
+    // check values
+    if ((lFormat != format()) ||
+        (lChannels != channels()) ||
+        (lRate != sampleRate())) {
+        if (pFormat) *pFormat = format();
+        if (pChannels) *pChannels = channels();
+        if (pRate) *pRate = sampleRate();
+        ALOGE("AudioStreamOutMSM72xx: Setting up correct values");
+        return NO_ERROR;
+    }
+
+    if (pFormat) *pFormat = lFormat;
+    if (pChannels) *pChannels = lChannels;
+    if (pRate) *pRate = lRate;
+
+    mDevices = devices;
+
+    return NO_ERROR;
+}
+
+AudioHardware::AudioStreamOutMSM72xx::~AudioStreamOutMSM72xx()
+{
+    if (mFd >= 0) close(mFd);
+}
+
+ssize_t AudioHardware::AudioStreamOutMSM72xx::write(const void* buffer, size_t bytes)
+{
+    //ALOGE("AudioStreamOutMSM72xx::write(%p, %u)", buffer, bytes);
+    status_t status = NO_INIT;
+    size_t count = bytes;
+    const uint8_t* p = static_cast<const uint8_t*>(buffer);
+
+    if (mStandby) {
+
+        // open driver
+        ALOGV("open driver");
+        status = ::open("/dev/msm_pcm_out", O_RDWR);
+        if (status < 0) {
+            ALOGE("Cannot open /dev/msm_pcm_out errno: %d", errno);
+            goto Error;
+        }
+        mFd = status;
+
+        // configuration
+        ALOGV("get config");
+        struct msm_audio_config config;
+        status = ioctl(mFd, AUDIO_GET_CONFIG, &config);
+        if (status < 0) {
+            ALOGE("Cannot read config");
+            goto Error;
+        }
+
+        ALOGV("set config");
+        config.channel_count = AudioSystem::popCount(channels());
+        config.sample_rate = sampleRate();
+        config.buffer_size = bufferSize();
+        config.buffer_count = AUDIO_HW_NUM_OUT_BUF;
+        config.type = CODEC_TYPE_PCM;
+        status = ioctl(mFd, AUDIO_SET_CONFIG, &config);
+        if (status < 0) {
+            ALOGE("Cannot set config");
+            goto Error;
+        }
+
+        ALOGV("buffer_size: %u", config.buffer_size);
+        ALOGV("buffer_count: %u", config.buffer_count);
+        ALOGV("channel_count: %u", config.channel_count);
+        ALOGV("sample_rate: %u", config.sample_rate);
+
+        // fill 2 buffers before AUDIO_START
+        mStartCount = AUDIO_HW_NUM_OUT_BUF;
+        mStandby = false;
+    }
+
+    while (count) {
+        ssize_t written = ::write(mFd, p, count);
+        if (written >= 0) {
+            count -= written;
+            p += written;
+        } else {
+            if (errno != EAGAIN) return written;
+            mRetryCount++;
+            ALOGW("EAGAIN - retry");
+        }
+    }
+
+    // start audio after we fill 2 buffers
+    if (mStartCount) {
+        if (--mStartCount == 0) {
+            ioctl(mFd, AUDIO_START, 0);
+            hpcm_playback_in_progress = true;
+#ifdef SRS_PROCESSING
+            msm72xx_enable_srs(SRS_PARAMS_ALL, true);
+#endif /*SRS_PROCESSING*/
+        }
+    }
+    return bytes;
+
+Error:
+    if (mFd >= 0) {
+        ::close(mFd);
+        mFd = -1;
+    }
+    // Simulate audio output timing in case of error
+    usleep(bytes * 1000000 / frameSize() / sampleRate());
+
+    return status;
+}
+
+status_t AudioHardware::AudioStreamOutMSM72xx::standby()
+{
+    status_t status = NO_ERROR;
+    if (!mStandby && mFd >= 0) {
+        //disable post processing
+        hpcm_playback_in_progress = false;
+#ifdef QCOM_TUNNEL_LPA_ENABLED
+        if(!lpa_playback_in_progress)
+#endif
+        {
+#ifdef SRS_PROCESSING
+            msm72xx_enable_srs(SRS_PARAMS_ALL, false);
+#endif /*SRS_PROCESSING*/
+        }
+        ::close(mFd);
+        mFd = -1;
+    }
+    mStandby = true;
+    return status;
+}
+
+status_t AudioHardware::AudioStreamOutMSM72xx::dump(int fd, const Vector<String16>& args)
+{
+    const size_t SIZE = 256;
+    char buffer[SIZE];
+    String8 result;
+    result.append("AudioStreamOutMSM72xx::dump\n");
+    snprintf(buffer, SIZE, "\tsample rate: %d\n", sampleRate());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tbuffer size: %d\n", bufferSize());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tchannels: %d\n", channels());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tformat: %d\n", format());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmHardware: %p\n", mHardware);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmFd: %d\n", mFd);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmStartCount: %d\n", mStartCount);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmRetryCount: %d\n", mRetryCount);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmStandby: %s\n", mStandby? "true": "false");
+    result.append(buffer);
+    ::write(fd, result.string(), result.size());
+    return NO_ERROR;
+}
+
+bool AudioHardware::AudioStreamOutMSM72xx::checkStandby()
+{
+    return mStandby;
+}
+
+
+status_t AudioHardware::AudioStreamOutMSM72xx::setParameters(const String8& keyValuePairs)
+{
+    AudioParameter param = AudioParameter(keyValuePairs);
+    String8 key = String8(AudioParameter::keyRouting);
+    status_t status = NO_ERROR;
+    int device;
+    ALOGV("AudioStreamOutMSM72xx::setParameters() %s", keyValuePairs.string());
+
+    if (param.getInt(key, device) == NO_ERROR) {
+        mDevices = device;
+        ALOGV("set output routing %x", mDevices);
+        status = mHardware->doRouting(NULL);
+        param.remove(key);
+    }
+
+    if (param.size()) {
+        status = BAD_VALUE;
+    }
+    return status;
+}
+
+String8 AudioHardware::AudioStreamOutMSM72xx::getParameters(const String8& keys)
+{
+    AudioParameter param = AudioParameter(keys);
+    String8 value;
+    String8 key = String8(AudioParameter::keyRouting);
+
+    if (param.get(key, value) == NO_ERROR) {
+        ALOGV("get routing %x", mDevices);
+        param.addInt(key, (int)mDevices);
+    }
+
+    ALOGV("AudioStreamOutMSM72xx::getParameters() %s", param.toString().string());
+    return param.toString();
+}
+
+status_t AudioHardware::AudioStreamOutMSM72xx::getRenderPosition(uint32_t *dspFrames)
+{
+    //TODO: enable when supported by driver
+    return INVALID_OPERATION;
+}
+
+#ifdef QCOM_VOIP_ENABLED
+AudioHardware::AudioStreamOutDirect::AudioStreamOutDirect() :
+    mHardware(0), mFd(-1), mStartCount(0), mRetryCount(0), mStandby(true), mDevices(0),mChannels(AudioSystem::CHANNEL_OUT_MONO),
+    mSampleRate(AUDIO_HW_VOIP_SAMPLERATE_8K), mBufferSize(AUDIO_HW_VOIP_BUFFERSIZE_8K), mFormat(AudioSystem::PCM_16_BIT)
+{
+}
+
+status_t AudioHardware::AudioStreamOutDirect::set(
+        AudioHardware* hw, uint32_t devices, int *pFormat, uint32_t *pChannels, uint32_t *pRate)
+{
+    int lFormat = pFormat ? *pFormat : 0;
+    uint32_t lChannels = pChannels ? *pChannels : 0;
+    uint32_t lRate = pRate ? *pRate : 0;
+
+    ALOGD("AudioStreamOutDirect::set  lFormat = %x lChannels= %u lRate = %u\n",
+        lFormat, lChannels, lRate );
+
+    if ((pFormat == 0) || BAD_INDEX == hw->getMvsMode(*pFormat)) {
+        ALOGE("Audio Format (%x) not supported \n",*pFormat);
+        return BAD_VALUE;
+    }
+
+
+    if (*pFormat == AudioSystem::PCM_16_BIT){
+        // fix up defaults
+        if (lFormat == 0) lFormat = format();
+        if (lChannels == 0) lChannels = channels();
+        if (lRate == 0) lRate = sampleRate();
+
+        // check values
+        if ((lFormat != format()) ||
+            (lChannels != channels()) ||
+            (lRate != sampleRate())) {
+            if (pFormat) *pFormat = format();
+            if (pChannels) *pChannels = channels();
+            if (pRate) *pRate = sampleRate();
+            ALOGE("  AudioStreamOutDirect::set return bad values\n");
+            return BAD_VALUE;
+        }
+
+        if (pFormat) *pFormat = lFormat;
+        if (pChannels) *pChannels = lChannels;
+        if (pRate) *pRate = lRate;
+
+        if(lRate == AUDIO_HW_VOIP_SAMPLERATE_8K) {
+            mBufferSize = AUDIO_HW_VOIP_BUFFERSIZE_8K;
+        } else if(lRate== AUDIO_HW_VOIP_SAMPLERATE_16K) {
+            mBufferSize = AUDIO_HW_VOIP_BUFFERSIZE_16K;
+        } else {
+            ALOGE("  AudioStreamOutDirect::set return bad values\n");
+            return BAD_VALUE;
+        }
+    }
+
+    mHardware = hw;
+
+    // check values
+    mFormat =  lFormat;
+    mChannels = lChannels;
+    mSampleRate = lRate;
+
+
+    mDevices = devices;
+    mHardware->mVoipOutActive = true;
+
+    return NO_ERROR;
+}
+
+AudioHardware::AudioStreamOutDirect::~AudioStreamOutDirect()
+{
+    ALOGV("AudioStreamOutDirect destructor");
+    mHardware->mVoipOutActive = false;
+    standby();
+}
+
+ssize_t AudioHardware::AudioStreamOutDirect::write(const void* buffer, size_t bytes)
+{
+//    ALOGE("AudioStreamOutDirect::write(%p, %u)", buffer, bytes);
+    status_t status = NO_INIT;
+    size_t count = bytes;
+    const uint8_t* p = static_cast<const uint8_t*>(buffer);
+
+    if (mStandby) {
+        if(mHardware->mVoipFd >= 0) {
+            mFd = mHardware->mVoipFd;
+
+            mHardware->mVoipOutActive = true;
+            if (mHardware->mVoipInActive)
+                mHardware->setupDeviceforVoipCall(true);
+
+            mStandby = false;
+        } else {
+            // open driver
+            ALOGE("open mvs driver");
+            status = ::open(MVS_DEVICE, /*O_WRONLY*/ O_RDWR);
+            if (status < 0) {
+                ALOGE("Cannot open %s errno: %d",MVS_DEVICE, errno);
+                goto Error;
+            }
+            mFd = status;
+            mHardware->mVoipFd = mFd;
+            // configuration
+            ALOGV("get mvs config");
+            struct msm_audio_mvs_config mvs_config;
+            status = ioctl(mFd, AUDIO_GET_MVS_CONFIG, &mvs_config);
+            if (status < 0) {
+               ALOGE("Cannot read mvs config");
+               goto Error;
+            }
+
+            mvs_config.mvs_mode = mHardware->getMvsMode(mFormat);
+            status = mHardware->getMvsRateType(mvs_config.mvs_mode ,&mvs_config.rate_type);
+            ALOGD("set mvs config mode %d rate_type %d", mvs_config.mvs_mode, mvs_config.rate_type);
+            if (status < 0) {
+                ALOGE("Incorrect mvs type");
+                goto Error;
+            }
+            status = ioctl(mFd, AUDIO_SET_MVS_CONFIG, &mvs_config);
+            if (status < 0) {
+                ALOGE("Cannot set mvs config");
+                goto Error;
+            }
+
+            ALOGV("start mvs config");
+            status = ioctl(mFd, AUDIO_START, 0);
+            if (status < 0) {
+                ALOGE("Cannot start mvs driver");
+                goto Error;
+            }
+            mHardware->mVoipOutActive = true;
+            if (mHardware->mVoipInActive)
+                mHardware->setupDeviceforVoipCall(true);
+
+            mStandby = false;
+        }
+    }
+    struct msm_audio_mvs_frame audio_mvs_frame;
+    memset(&audio_mvs_frame, 0, sizeof(audio_mvs_frame));
+    if (mFormat == AudioSystem::PCM_16_BIT) {
+        audio_mvs_frame.frame_type = 0;
+        while (count) {
+            audio_mvs_frame.len = mBufferSize;
+            memcpy(&audio_mvs_frame.voc_pkt, p, mBufferSize);
+            // TODO - this memcpy is rendundant can be removed.
+            ALOGV("write mvs bytes");
+            size_t written = ::write(mFd, &audio_mvs_frame, sizeof(audio_mvs_frame));
+            ALOGV(" mvs bytes written : %d \n", written);
+            if (written == 0) {
+                count -= mBufferSize;
+                p += mBufferSize;
+            } else {
+                if (errno != EAGAIN) return written;
+                mRetryCount++;
+                ALOGW("EAGAIN - retry");
+            }
+        }
+    }
+    else {
+        struct msm_audio_mvs_frame *mvsFramePtr = (msm_audio_mvs_frame *)buffer;
+        audio_mvs_frame.frame_type = mvsFramePtr->frame_type;
+        audio_mvs_frame.len = mvsFramePtr->len;
+        ALOGV("Write Frametype %d, Frame len %d", audio_mvs_frame.frame_type, audio_mvs_frame.len);
+        if(audio_mvs_frame.len < 0)
+            goto Error;
+        memcpy(&audio_mvs_frame.voc_pkt, &mvsFramePtr->voc_pkt, audio_mvs_frame.len);
+        size_t written =::write(mFd, &audio_mvs_frame, sizeof(audio_mvs_frame));
+        ALOGV(" mvs bytes written : %d bytes %d \n", written,bytes);
+    }
+
+    return bytes;
+
+Error:
+ALOGE("  write Error \n");
+    if (mFd >= 0) {
+        ::close(mFd);
+        mFd = -1;
+        mHardware->mVoipFd = -1;
+    }
+    // Simulate audio output timing in case of error
+//    usleep(bytes * 1000000 / frameSize() / sampleRate());
+
+    return status;
+}
+
+
+
+status_t AudioHardware::AudioStreamOutDirect::standby()
+{
+    ALOGD("AudioStreamOutDirect::standby()");
+    Mutex::Autolock lock(mHardware->mVoipLock);
+    status_t status = NO_ERROR;
+    int ret = 0;
+
+    ALOGD("Voipin %d driver fd %d", mHardware->mVoipInActive, mHardware->mVoipFd);
+    mHardware->mVoipOutActive = false;
+    if (mHardware->mVoipFd >= 0 && !mHardware->mVoipInActive) {
+       ret = ioctl(mHardware->mVoipFd, AUDIO_STOP, NULL);
+       ALOGD("MVS stop returned %d %d %d \n", ret, __LINE__, mHardware->mVoipFd);
+       ::close(mFd);
+       mFd = mHardware->mVoipFd = -1;
+       mHardware->setupDeviceforVoipCall(false);
+       ALOGD("MVS driver closed %d mFd %d", __LINE__, mHardware->mVoipFd);
+   } else
+        ALOGE("Not closing MVS driver");
+
+
+    mStandby = true;
+    return status;
+}
+
+status_t AudioHardware::AudioStreamOutDirect::dump(int fd, const Vector<String16>& args)
+{
+    const size_t SIZE = 256;
+    char buffer[SIZE];
+    String8 result;
+    result.append("AudioStreamOutDirect::dump\n");
+    snprintf(buffer, SIZE, "\tsample rate: %d\n", sampleRate());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tbuffer size: %d\n", bufferSize());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tchannels: %d\n", channels());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tformat: %d\n", format());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmHardware: %p\n", mHardware);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmFd: %d\n", mFd);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmStartCount: %d\n", mStartCount);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmRetryCount: %d\n", mRetryCount);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmStandby: %s\n", mStandby? "true": "false");
+    result.append(buffer);
+    ::write(fd, result.string(), result.size());
+    return NO_ERROR;
+}
+
+bool AudioHardware::AudioStreamOutDirect::checkStandby()
+{
+    return mStandby;
+}
+
+
+status_t AudioHardware::AudioStreamOutDirect::setParameters(const String8& keyValuePairs)
+{
+    AudioParameter param = AudioParameter(keyValuePairs);
+    String8 key = String8(AudioParameter::keyRouting);
+    status_t status = NO_ERROR;
+    int device;
+    ALOGV("AudioStreamOutDirect::setParameters() %s", keyValuePairs.string());
+
+    if (param.getInt(key, device) == NO_ERROR) {
+        mDevices = device;
+        ALOGV("set output routing %x", mDevices);
+        status = mHardware->doRouting(NULL);
+        param.remove(key);
+    }
+
+    if (param.size()) {
+        status = BAD_VALUE;
+    }
+    return status;
+}
+
+String8 AudioHardware::AudioStreamOutDirect::getParameters(const String8& keys)
+{
+    AudioParameter param = AudioParameter(keys);
+    String8 value;
+    String8 key = String8(AudioParameter::keyRouting);
+
+    if (param.get(key, value) == NO_ERROR) {
+        ALOGV("get routing %x", mDevices);
+        param.addInt(key, (int)mDevices);
+    }
+
+    key = String8("voip_flag");
+    if (param.get(key, value) == NO_ERROR) {
+        param.addInt(key, true);
+    }
+
+    ALOGV("AudioStreamOutDirect::getParameters() %s", param.toString().string());
+    return param.toString();
+}
+
+status_t AudioHardware::AudioStreamOutDirect::getRenderPosition(uint32_t *dspFrames)
+{
+    //TODO: enable when supported by driver
+    return INVALID_OPERATION;
+}
+#endif /*QCOM_VOIP_ENABLED*/
+
+// End AudioStreamOutDirect
+
+//.----------------------------------------------------------------------------
+int AudioHardware::AudioStreamInMSM72xx::InstanceCount = 0;
+AudioHardware::AudioStreamInMSM72xx::AudioStreamInMSM72xx() :
+    mHardware(0), mFd(-1), mState(AUDIO_INPUT_CLOSED), mRetryCount(0),
+    mFormat(AUDIO_HW_IN_FORMAT), mChannels(AUDIO_HW_IN_CHANNELS),
+    mSampleRate(AUDIO_HW_IN_SAMPLERATE), mBufferSize(AUDIO_HW_IN_BUFFERSIZE),
+    mAcoustics((AudioSystem::audio_in_acoustics)0), mDevices(0)
+{
+    AudioStreamInMSM72xx::InstanceCount++;
+}
+
+status_t AudioHardware::AudioStreamInMSM72xx::set(
+        AudioHardware* hw, uint32_t devices, int *pFormat, uint32_t *pChannels, uint32_t *pRate,
+        AudioSystem::audio_in_acoustics acoustic_flags)
+{
+    if(AudioStreamInMSM72xx::InstanceCount > 1)
+    {
+        ALOGE("More than one instance of recording not supported");
+        return -EBUSY;
+    }
+
+    if ((pFormat == 0) ||
+        ((*pFormat != AUDIO_HW_IN_FORMAT) &&
+         (*pFormat != AudioSystem::AMR_NB) &&
+         (*pFormat != AudioSystem::EVRC) &&
+         (*pFormat != AudioSystem::QCELP) &&
+         (*pFormat != AudioSystem::AAC)))
+    {
+        *pFormat = AUDIO_HW_IN_FORMAT;
+        ALOGE("audio format bad value");
+        return BAD_VALUE;
+    }
+    if (pRate == 0) {
+        return BAD_VALUE;
+    }
+    uint32_t rate = hw->getInputSampleRate(*pRate);
+    if (rate != *pRate) {
+        *pRate = rate;
+        ALOGE(" sample rate does not match\n");
+        return BAD_VALUE;
+    }
+
+    if (pChannels == 0 || (*pChannels & (AudioSystem::CHANNEL_IN_MONO | AudioSystem::CHANNEL_IN_STEREO)) == 0)
+    {
+        *pChannels = AUDIO_HW_IN_CHANNELS;
+        ALOGE(" Channel count does not match\n");
+        return BAD_VALUE;
+    }
+
+    mHardware = hw;
+
+    ALOGV("AudioStreamInMSM72xx::set(%d, %d, %u)", *pFormat, *pChannels, *pRate);
+    if (mFd >= 0) {
+        ALOGE("Audio record already open");
+        return -EPERM;
+    }
+
+    struct msm_audio_config config;
+    struct msm_audio_voicememo_config gcfg;
+    memset(&gcfg,0,sizeof(gcfg));
+    status_t status = 0;
+    if(*pFormat == AUDIO_HW_IN_FORMAT)
+    {
+    // open audio input device
+        status = ::open(PCM_IN_DEVICE, O_RDWR);
+        if (status < 0) {
+            ALOGE("Cannot open %s errno: %d", PCM_IN_DEVICE, errno);
+            goto Error;
+        }
+        mFd = status;
+
+        // configuration
+        status = ioctl(mFd, AUDIO_GET_CONFIG, &config);
+        if (status < 0) {
+            ALOGE("Cannot read config");
+           goto Error;
+        }
+
+    ALOGV("set config");
+    config.channel_count = AudioSystem::popCount(*pChannels);
+    config.sample_rate = *pRate;
+    config.buffer_size = bufferSize();
+    config.buffer_count = 2;
+        config.type = CODEC_TYPE_PCM;
+    status = ioctl(mFd, AUDIO_SET_CONFIG, &config);
+    if (status < 0) {
+        ALOGE("Cannot set config");
+        if (ioctl(mFd, AUDIO_GET_CONFIG, &config) == 0) {
+            if (config.channel_count == 1) {
+                *pChannels = AudioSystem::CHANNEL_IN_MONO;
+            } else {
+                *pChannels = AudioSystem::CHANNEL_IN_STEREO;
+            }
+            *pRate = config.sample_rate;
+        }
+        goto Error;
+    }
+
+    ALOGV("confirm config");
+    status = ioctl(mFd, AUDIO_GET_CONFIG, &config);
+    if (status < 0) {
+        ALOGE("Cannot read config");
+        goto Error;
+    }
+    ALOGV("buffer_size: %u", config.buffer_size);
+    ALOGV("buffer_count: %u", config.buffer_count);
+    ALOGV("channel_count: %u", config.channel_count);
+    ALOGV("sample_rate: %u", config.sample_rate);
+    ALOGV("input device: %x", devices);
+
+    mDevices = devices;
+    mFormat = AUDIO_HW_IN_FORMAT;
+    mChannels = *pChannels;
+    mSampleRate = config.sample_rate;
+    mBufferSize = config.buffer_size;
+    }
+    else if( (*pFormat == AudioSystem::AMR_NB) ||
+             (*pFormat == AudioSystem::EVRC) ||
+             (*pFormat == AudioSystem::QCELP))
+           {
+
+      // open vocie memo input device
+      status = ::open(VOICE_MEMO_DEVICE, O_RDWR);
+      if (status < 0) {
+          ALOGE("Cannot open Voice Memo device for read");
+          goto Error;
+      }
+      mFd = status;
+      /* Config param */
+      if(ioctl(mFd, AUDIO_GET_CONFIG, &config))
+      {
+        ALOGE(" Error getting buf config param AUDIO_GET_CONFIG \n");
+        goto  Error;
+      }
+
+      ALOGV("The Config buffer size is %d", config.buffer_size);
+      ALOGV("The Config buffer count is %d", config.buffer_count);
+      ALOGV("The Config Channel count is %d", config.channel_count);
+      ALOGV("The Config Sample rate is %d", config.sample_rate);
+
+      mDevices = devices;
+      mChannels = *pChannels;
+      mSampleRate = config.sample_rate;
+
+      if (mDevices == AudioSystem::DEVICE_IN_VOICE_CALL)
+      {
+        if ((mChannels & AudioSystem::CHANNEL_IN_VOICE_DNLINK) &&
+            (mChannels & AudioSystem::CHANNEL_IN_VOICE_UPLINK)) {
+          ALOGI("Recording Source: Voice Call Both Uplink and Downlink");
+          gcfg.rec_type = RPC_VOC_REC_BOTH;
+        } else if (mChannels & AudioSystem::CHANNEL_IN_VOICE_DNLINK) {
+          ALOGI("Recording Source: Voice Call DownLink");
+          gcfg.rec_type = RPC_VOC_REC_FORWARD;
+        } else if (mChannels & AudioSystem::CHANNEL_IN_VOICE_UPLINK) {
+          ALOGI("Recording Source: Voice Call UpLink");
+          gcfg.rec_type = RPC_VOC_REC_REVERSE;
+        }
+      }
+      else {
+        ALOGI("Recording Source: Mic/Headset");
+        gcfg.rec_type = RPC_VOC_REC_REVERSE;
+      }
+
+      gcfg.rec_interval_ms = 0; // AV sync
+      gcfg.auto_stop_ms = 0;
+
+      switch (*pFormat)
+      {
+        case AudioSystem::AMR_NB:
+        {
+          ALOGI("Recording Format: AMR_NB");
+          gcfg.capability = RPC_VOC_CAP_AMR; // RPC_VOC_CAP_AMR (64)
+          gcfg.max_rate = RPC_VOC_AMR_RATE_1220; // Max rate (Fixed frame)
+          gcfg.min_rate = RPC_VOC_AMR_RATE_1220; // Min rate (Fixed frame length)
+          gcfg.frame_format = RPC_VOC_PB_AMR; // RPC_VOC_PB_AMR
+          mFormat = AudioSystem::AMR_NB;
+          mBufferSize = 320;
+          break;
+        }
+
+        case AudioSystem::EVRC:
+        {
+          ALOGI("Recording Format: EVRC");
+          gcfg.capability = RPC_VOC_CAP_IS127;
+          gcfg.max_rate = RPC_VOC_1_RATE; // Max rate (Fixed frame)
+          gcfg.min_rate = RPC_VOC_1_RATE; // Min rate (Fixed frame length)
+          gcfg.frame_format = RPC_VOC_PB_NATIVE_QCP;
+          mFormat = AudioSystem::EVRC;
+          mBufferSize = 230;
+          break;
+        }
+
+        case AudioSystem::QCELP:
+        {
+          ALOGI("Recording Format: QCELP");
+          gcfg.capability = RPC_VOC_CAP_IS733; // RPC_VOC_CAP_AMR (64)
+          gcfg.max_rate = RPC_VOC_1_RATE; // Max rate (Fixed frame)
+          gcfg.min_rate = RPC_VOC_1_RATE; // Min rate (Fixed frame length)
+          gcfg.frame_format = RPC_VOC_PB_NATIVE_QCP;
+          mFormat = AudioSystem::QCELP;
+          mBufferSize = 350;
+          break;
+        }
+
+        default:
+        break;
+      }
+
+      gcfg.dtx_enable = 0;
+      gcfg.data_req_ms = 20;
+
+      /* Set Via  config param */
+      if (ioctl(mFd, AUDIO_SET_VOICEMEMO_CONFIG, &gcfg))
+      {
+        ALOGE("Error: AUDIO_SET_VOICEMEMO_CONFIG failed\n");
+        goto  Error;
+      }
+
+      if (ioctl(mFd, AUDIO_GET_VOICEMEMO_CONFIG, &gcfg))
+      {
+        ALOGE("Error: AUDIO_GET_VOICEMEMO_CONFIG failed\n");
+        goto  Error;
+      }
+
+      ALOGV("After set rec_type = 0x%8x\n",gcfg.rec_type);
+      ALOGV("After set rec_interval_ms = 0x%8x\n",gcfg.rec_interval_ms);
+      ALOGV("After set auto_stop_ms = 0x%8x\n",gcfg.auto_stop_ms);
+      ALOGV("After set capability = 0x%8x\n",gcfg.capability);
+      ALOGV("After set max_rate = 0x%8x\n",gcfg.max_rate);
+      ALOGV("After set min_rate = 0x%8x\n",gcfg.min_rate);
+      ALOGV("After set frame_format = 0x%8x\n",gcfg.frame_format);
+      ALOGV("After set dtx_enable = 0x%8x\n",gcfg.dtx_enable);
+      ALOGV("After set data_req_ms = 0x%8x\n",gcfg.data_req_ms);
+    }
+    else if(*pFormat == AudioSystem::AAC) {
+      // open AAC input device
+               status = ::open(PCM_IN_DEVICE, O_RDWR);
+               if (status < 0) {
+                     ALOGE("Cannot open AAC input  device for read");
+                     goto Error;
+               }
+               mFd = status;
+
+      /* Config param */
+               if(ioctl(mFd, AUDIO_GET_CONFIG, &config))
+               {
+                     ALOGE(" Error getting buf config param AUDIO_GET_CONFIG \n");
+                     goto  Error;
+               }
+
+      ALOGV("The Config buffer size is %d", config.buffer_size);
+      ALOGV("The Config buffer count is %d", config.buffer_count);
+      ALOGV("The Config Channel count is %d", config.channel_count);
+      ALOGV("The Config Sample rate is %d", config.sample_rate);
+
+      mDevices = devices;
+      mChannels = *pChannels;
+      mSampleRate = *pRate;
+      mBufferSize = 2048;
+      mFormat = *pFormat;
+
+      config.channel_count = AudioSystem::popCount(*pChannels);
+      config.sample_rate = *pRate;
+      config.type = 1; // Configuring PCM_IN_DEVICE to AAC format
+
+      if (ioctl(mFd, AUDIO_SET_CONFIG, &config)) {
+             ALOGE(" Error in setting config of msm_pcm_in device \n");
+                   goto Error;
+        }
+    }
+
+    //mHardware->setMicMute_nosync(false);
+    mState = AUDIO_INPUT_OPENED;
+
+    //if (!acoustic)
+    //    return NO_ERROR;
+
+    return NO_ERROR;
+
+Error:
+    if (mFd >= 0) {
+        ::close(mFd);
+        mFd = -1;
+    }
+    return status;
+}
+
+
+// ----------------------------------------------------------------------------
+// Audio Stream from LPA output
+// Start AudioSessionOutLPA
+// ----------------------------------------------------------------------------
+
+AudioHardware::AudioSessionOutLPA::AudioSessionOutLPA( AudioHardware *hw,
+                                         uint32_t   devices,
+                                         int        format,
+                                         uint32_t   channels,
+                                         uint32_t   samplingRate,
+                                         int        type,
+                                         status_t   *status)
+{
+    Mutex::Autolock autoLock(mLock);
+    // Default initilization
+    mHardware = hw;
+    ALOGE("AudioSessionOutLPA constructor");
+    mFormat             = format;
+    mSampleRate         = samplingRate;
+    mChannels           = popcount(channels);
+    mBufferSize         = LPA_BUFFER_SIZE; //TODO to check what value is correct
+    *status             = BAD_VALUE;
+
+    mPaused             = false;
+    mIsDriverStarted    = false;
+    mGenerateEOS        = true;
+    mSeeking            = false;
+    mReachedEOS         = false;
+    mSkipWrite          = false;
+    timeStarted = 0;
+    timePlayed = 0;
+
+    mInputBufferSize    = LPA_BUFFER_SIZE;
+    mInputBufferCount   = BUFFER_COUNT;
+    efd = -1;
+    mEosEventReceived   =false;
+
+    mEventThread        = NULL;
+    mEventThreadAlive   = false;
+    mKillEventThread    = false;
+    mObserver           = NULL;
+    if((format == AUDIO_FORMAT_PCM_16_BIT) && (mChannels == 0 || mChannels > 2)) {
+        ALOGE("Invalid number of channels %d", channels);
+        return;
+    }
+
+    *status = openAudioSessionDevice();
+
+    //Creates the event thread to poll events from LPA Driver
+    if(*status == NO_ERROR)
+          createEventThread();
+}
+
+AudioHardware::AudioSessionOutLPA::~AudioSessionOutLPA()
+{
+    ALOGV("AudioSessionOutLPA destructor");
+    mSkipWrite = true;
+    mWriteCv.signal();
+
+    //TODO: This might need to be Locked using Parent lock
+    reset();
+    //standby();//TODO Do we really need standby?
+
+}
+
+status_t AudioHardware::AudioSessionOutLPA::setParameters(const String8& keyValuePairs)
+{
+    AudioParameter param = AudioParameter(keyValuePairs);
+    String8 key = String8(AudioParameter::keyRouting);
+    status_t status = NO_ERROR;
+    int device;
+    ALOGV("AudioSessionOutLPA::setParameters() %s", keyValuePairs.string());
+
+    if (param.getInt(key, device) == NO_ERROR) {
+        mDevices = device;
+        ALOGV("set output routing %x", mDevices);
+        status = mHardware->doRouting(NULL, device);
+        param.remove(key);
+    }
+
+    if (param.size()) {
+        status = BAD_VALUE;
+    }
+    return status;
+}
+String8 AudioHardware::AudioSessionOutLPA::getParameters(const String8& keys)
+{
+    AudioParameter param = AudioParameter(keys);
+    String8 value;
+    String8 key = String8(AudioParameter::keyRouting);
+
+    if (param.get(key, value) == NO_ERROR) {
+        ALOGV("get routing %x", mDevices);
+        param.addInt(key, (int)mDevices);
+    }
+
+    ALOGV("AudioSessionOutLPA::getParameters() %s", param.toString().string());
+    return param.toString();
+}
+
+ssize_t AudioHardware::AudioSessionOutLPA::write(const void* buffer, size_t bytes)
+{
+    Mutex::Autolock autoLock(mLock);
+    int err;
+    ALOGV("write Empty Queue size() = %d, Filled Queue size() = %d ",
+         mEmptyQueue.size(),mFilledQueue.size());
+
+    if (mSkipWrite) {
+        mSkipWrite = false;
+        if (bytes < LPA_BUFFER_SIZE)
+            bytes = 0;
+        else
+            return 0;
+    }
+
+    if (mSkipWrite)
+        mSkipWrite = false;
+
+    //2.) Dequeue the buffer from empty buffer queue. Copy the data to be
+    //    written into the buffer. Then Enqueue the buffer to the filled
+    //    buffer queue
+    mEmptyQueueMutex.lock();
+    List<BuffersAllocated>::iterator it = mEmptyQueue.begin();
+    BuffersAllocated buf = *it;
+    mEmptyQueue.erase(it);
+    mEmptyQueueMutex.unlock();
+
+    memset(buf.memBuf, 0, bytes);
+    memcpy(buf.memBuf, buffer, bytes);
+    buf.bytesToWrite = bytes;
+
+    struct msm_audio_aio_buf aio_buf_local;
+    if ( buf.bytesToWrite > 0) {
+        memset(&aio_buf_local, 0, sizeof(msm_audio_aio_buf));
+        aio_buf_local.buf_addr = buf.memBuf;
+        aio_buf_local.buf_len = buf.bytesToWrite;
+        aio_buf_local.data_len = buf.bytesToWrite;
+        aio_buf_local.private_data = (void*) buf.memFd;
+
+        if ( (buf.bytesToWrite % 2) != 0 ) {
+            ALOGV("Increment for even bytes");
+            aio_buf_local.data_len += 1;
+        }
+        if (timeStarted == 0)
+            timeStarted = nanoseconds_to_microseconds(systemTime(SYSTEM_TIME_MONOTONIC));
+    } else {
+        /* Put the buffer back into requestQ */
+        ALOGV("mEmptyQueueMutex locking: %d", __LINE__);
+        mEmptyQueueMutex.lock();
+        ALOGV("mEmptyQueueMutex locked: %d", __LINE__);
+        mEmptyQueue.push_back(buf);
+        ALOGV("mEmptyQueueMutex unlocking: %d", __LINE__);
+        mEmptyQueueMutex.unlock();
+        ALOGV("mEmptyQueueMutex unlocked: %d", __LINE__);
+        //Post EOS in case the filled queue is empty and EOS is reached.
+        mReachedEOS = true;
+        mFilledQueueMutex.lock();
+        if (mFilledQueue.empty() && !mEosEventReceived) {
+            ALOGV("mEosEventReceived made true");
+            mEosEventReceived = true;
+            if (mObserver != NULL) {
+                ALOGV("mObserver: posting EOS");
+                mObserver->postEOS(0);
+            }
+        }
+        mFilledQueueMutex.unlock();
+        return NO_ERROR;
+    }
+    mFilledQueueMutex.lock();
+    mFilledQueue.push_back(buf);
+    mFilledQueueMutex.unlock();
+
+    ALOGV("PCM write start");
+    //3.) Write the buffer to the Driver
+    if(mIsDriverStarted) {
+       if (ioctl(afd, AUDIO_ASYNC_WRITE, &aio_buf_local) < 0 ) {
+           ALOGE("error on async write\n");
+       }
+    }
+    ALOGV("PCM write complete");
+
+    if (bytes < LPA_BUFFER_SIZE) {
+        ALOGV("Last buffer case");
+        mLock.unlock();
+        if (fsync(afd) != 0) {
+            ALOGE("fsync failed.");
+        }
+        mLock.lock();
+        mReachedEOS = true;
+    }
+
+    return NO_ERROR; //TODO Do wee need to send error
+}
+
+
+status_t AudioHardware::AudioSessionOutLPA::standby()
+{
+    ALOGD("AudioSessionOutLPA::standby()");
+    status_t status = NO_ERROR;
+    //TODO  Do we really need standby()
+    return status;
+}
+
+
+status_t AudioHardware::AudioSessionOutLPA::dump(int fd, const Vector<String16>& args)
+{
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioSessionOutLPA::setVolume(float left, float right)
+{
+   float v = (left + right) / 2;
+    if (v < 0.0) {
+        ALOGW("AudioSessionOutLPA::setVolume(%f) under 0.0, assuming 0.0\n", v);
+        v = 0.0;
+    } else if (v > 1.0) {
+        ALOGW("AudioSessionOutLPA::setVolume(%f) over 1.0, assuming 1.0\n", v);
+        v = 1.0;
+    }
+
+    // Ensure to convert the log volume back to linear for LPA
+    long vol = v * 10000;
+    ALOGV("AudioSessionOutLPA::setVolume(%f)\n", v);
+    ALOGV("Setting session volume to %ld (available range is 0 to 100)\n", vol);
+
+
+    if (ioctl(afd,AUDIO_SET_VOLUME, vol)< 0)
+        ALOGE("LPA volume set failed");
+
+    ALOGV("LPA volume set (%f) succeeded",vol);
+
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioSessionOutLPA::openAudioSessionDevice( )
+{
+    status_t status = NO_ERROR;
+
+    //It opens LPA driver
+    ALOGE("Opening LPA pcm_dec driver");
+    afd = open("/dev/msm_pcm_lp_dec", O_WRONLY | O_NONBLOCK);
+    if ( afd < 0 ) {
+        ALOGE("pcm_lp_dec: cannot open pcm_dec device and the error is %d", errno);
+        //initCheck = false;
+        return UNKNOWN_ERROR;
+    } else {
+        //initCheck = true;
+        ALOGV("pcm_lp_dec: pcm_lp_dec Driver opened");
+        lpa_playback_in_progress = true;
+    }
+
+    start();
+    bufferAlloc();
+
+    return status;
+}
+
+void AudioHardware::AudioSessionOutLPA::bufferAlloc( )
+{
+    // Allocate ION buffers
+    void *ion_buf; int32_t ion_fd;
+    struct msm_audio_ion_info ion_info;
+    //1. Open the ion_audio
+    ionfd = open("/dev/ion", O_RDONLY | O_SYNC);
+    if (ionfd < 0) {
+        ALOGE("/dev/ion open failed \n");
+        return;
+    }
+    for (int i = 0; i < mInputBufferCount; i++) {
+        ion_buf = memBufferAlloc(mInputBufferSize, &ion_fd);
+        memset(&ion_info, 0, sizeof(msm_audio_ion_info));
+        ALOGE("Registering ION with fd %d and address as %p", ion_fd, ion_buf);
+        ion_info.fd = ion_fd;
+        ion_info.vaddr = ion_buf;
+        if ( ioctl(afd, AUDIO_REGISTER_ION, &ion_info) < 0 ) {
+            ALOGE("Registration of ION with the Driver failed with fd %d and memory %x",
+                 ion_info.fd, (unsigned int)ion_info.vaddr);
+        }
+    }
+}
+
+
+void* AudioHardware::AudioSessionOutLPA::memBufferAlloc(int nSize, int32_t *ion_fd)
+{
+    void  *ion_buf = NULL;
+    void  *local_buf = NULL;
+    struct ion_fd_data fd_data;
+    struct ion_allocation_data alloc_data;
+
+    alloc_data.len =   nSize;
+    alloc_data.align = 0x1000;
+    alloc_data.flags = ION_HEAP(ION_AUDIO_HEAP_ID);
+    int rc = ioctl(ionfd, ION_IOC_ALLOC, &alloc_data);
+    if (rc) {
+        ALOGE("ION_IOC_ALLOC ioctl failed\n");
+        return ion_buf;
+    }
+    fd_data.handle = alloc_data.handle;
+
+    rc = ioctl(ionfd, ION_IOC_SHARE, &fd_data);
+    if (rc) {
+        ALOGE("ION_IOC_SHARE ioctl failed\n");
+        rc = ioctl(ionfd, ION_IOC_FREE, &(alloc_data.handle));
+        if (rc) {
+            ALOGE("ION_IOC_FREE ioctl failed\n");
+        }
+        return ion_buf;
+    }
+
+    // 2. MMAP to get the virtual address
+    ion_buf = mmap(NULL, nSize, PROT_READ | PROT_WRITE, MAP_SHARED, fd_data.fd, 0);
+    if(MAP_FAILED == ion_buf) {
+        ALOGE("mmap() failed \n");
+        close(fd_data.fd);
+        rc = ioctl(ionfd, ION_IOC_FREE, &(alloc_data.handle));
+        if (rc) {
+            ALOGE("ION_IOC_FREE ioctl failed\n");
+        }
+        return ion_buf;
+    }
+
+    local_buf = malloc(nSize);
+    if (NULL == local_buf) {
+        // unmap the corresponding ION buffer and close the fd
+        munmap(ion_buf, mInputBufferSize);
+        close(fd_data.fd);
+        rc = ioctl(ionfd, ION_IOC_FREE, &(alloc_data.handle));
+        if (rc) {
+            ALOGE("ION_IOC_FREE ioctl failed\n");
+        }
+        return NULL;
+    }
+
+    // 3. Store this information for internal mapping / maintanence
+    BuffersAllocated buf(local_buf, ion_buf, nSize, fd_data.fd, alloc_data.handle);
+    mEmptyQueue.push_back(buf);
+
+    // 4. Send the mem fd information
+    *ion_fd = fd_data.fd;
+    ALOGV("IONBufferAlloc calling with required size %d", nSize);
+    ALOGV("ION allocated is %d, fd_data.fd %d and buffer is %x", *ion_fd, fd_data.fd, (unsigned int)ion_buf);
+
+    // 5. Return the virtual address
+    return ion_buf;
+}
+
+void AudioHardware::AudioSessionOutLPA::bufferDeAlloc()
+{
+    // De-Allocate ION buffers
+    int rc = 0;
+    //Remove all the buffers from empty queue
+    mEmptyQueueMutex.lock();
+    while (!mEmptyQueue.empty())  {
+        List<BuffersAllocated>::iterator it = mEmptyQueue.begin();
+        BuffersAllocated &ionBuffer = *it;
+        struct msm_audio_ion_info ion_info;
+        ion_info.vaddr = (*it).memBuf;
+        ion_info.fd = (*it).memFd;
+        if (ioctl(afd, AUDIO_DEREGISTER_ION, &ion_info) < 0) {
+            ALOGE("ION deregister failed");
+        }
+        ALOGV("Ion Unmapping the address %p, size %d, fd %d from empty",ionBuffer.memBuf,ionBuffer.bytesToWrite,ionBuffer.memFd);
+        munmap(ionBuffer.memBuf, mInputBufferSize);
+        ALOGV("closing the ion shared fd");
+        close(ionBuffer.memFd);
+        rc = ioctl(ionfd, ION_IOC_FREE, &ionBuffer.ion_handle);
+        if (rc) {
+            ALOGE("ION_IOC_FREE ioctl failed\n");
+        }
+        // free the local buffer corresponding to ion buffer
+        free(ionBuffer.localBuf);
+        ALOGE("Removing from empty Q");
+        mEmptyQueue.erase(it);
+    }
+    mEmptyQueueMutex.unlock();
+
+    //Remove all the buffers from Filled queue
+    mFilledQueueMutex.lock();
+    while(!mFilledQueue.empty()){
+        List<BuffersAllocated>::iterator it = mFilledQueue.begin();
+        BuffersAllocated &ionBuffer = *it;
+        struct msm_audio_ion_info ion_info;
+        ion_info.vaddr = (*it).memBuf;
+        ion_info.fd = (*it).memFd;
+        if (ioctl(afd, AUDIO_DEREGISTER_ION, &ion_info) < 0) {
+            ALOGE("ION deregister failed");
+        }
+        ALOGV("Ion Unmapping the address %p, size %d, fd %d from Request",ionBuffer.memBuf,ionBuffer.bytesToWrite,ionBuffer.memFd);
+        munmap(ionBuffer.memBuf, mInputBufferSize);
+        ALOGV("closing the ion shared fd");
+        close(ionBuffer.memFd);
+        rc = ioctl(ionfd, ION_IOC_FREE, &ionBuffer.ion_handle);
+        if (rc) {
+            ALOGE("ION_IOC_FREE ioctl failed\n");
+        }
+        // free the local buffer corresponding to ion buffer
+        free(ionBuffer.localBuf);
+        ALOGV("Removing from Filled Q");
+        mFilledQueue.erase(it);
+    }
+    mFilledQueueMutex.unlock();
+    if (ionfd >= 0) {
+        close(ionfd);
+        ionfd = -1;
+    }
+}
+
+uint32_t AudioHardware::AudioSessionOutLPA::latency() const
+{
+    // Android wants latency in milliseconds.
+    return 1000;//TODO to correct the value
+}
+
+void AudioHardware::AudioSessionOutLPA::requestAndWaitForEventThreadExit()
+{
+    if (!mEventThreadAlive)
+        return;
+    mKillEventThread = true;
+    if (ioctl(afd, AUDIO_ABORT_GET_EVENT, 0) < 0) {
+        ALOGE("Audio Abort event failed");
+    }
+    pthread_join(mEventThread,NULL);
+}
+
+void * AudioHardware::AudioSessionOutLPA::eventThreadWrapper(void *me)
+{
+    static_cast<AudioSessionOutLPA *>(me)->eventThreadEntry();
+    return NULL;
+}
+
+void  AudioHardware::AudioSessionOutLPA::eventThreadEntry()
+{
+    struct msm_audio_event cur_pcmdec_event;
+    mEventThreadAlive = true;
+    int rc = 0;
+    //2.) Set the priority for the event thread
+    pid_t tid  = gettid();
+    androidSetThreadPriority(tid, ANDROID_PRIORITY_AUDIO);
+    prctl(PR_SET_NAME, (unsigned long)"HAL Audio EventThread", 0, 0, 0);
+    ALOGV("event thread created ");
+    if (mKillEventThread) {
+        mEventThreadAlive = false;
+        ALOGV("Event Thread is dying.");
+        return;
+    }
+    while (1) {
+        //Wait for an event to occur
+        rc = ioctl(afd, AUDIO_GET_EVENT, &cur_pcmdec_event);
+        ALOGE("pcm dec Event Thread rc = %d and errno is %d",rc, errno);
+
+        if ( (rc < 0) && ((errno == ENODEV) || (errno == EBADF)) ) {
+            ALOGV("AUDIO__GET_EVENT called. Exit the thread");
+            break;
+        }
+
+        switch ( cur_pcmdec_event.event_type ) {
+        case AUDIO_EVENT_WRITE_DONE:
+            {
+                ALOGE("WRITE_DONE: addr %p len %d and fd is %d\n",
+                     cur_pcmdec_event.event_payload.aio_buf.buf_addr,
+                     cur_pcmdec_event.event_payload.aio_buf.data_len,
+                     (int32_t) cur_pcmdec_event.event_payload.aio_buf.private_data);
+                Mutex::Autolock autoLock(mLock);
+                mFilledQueueMutex.lock();
+                BuffersAllocated buf = *(mFilledQueue.begin());
+                for (List<BuffersAllocated>::iterator it = mFilledQueue.begin();
+                    it != mFilledQueue.end(); ++it) {
+                    if (it->memBuf == cur_pcmdec_event.event_payload.aio_buf.buf_addr) {
+                        buf = *it;
+                        mFilledQueue.erase(it);
+                        // Post buffer to Empty Q
+                        ALOGV("mEmptyQueueMutex locking: %d", __LINE__);
+                        mEmptyQueueMutex.lock();
+                        ALOGV("mEmptyQueueMutex locked: %d", __LINE__);
+                        mEmptyQueue.push_back(buf);
+                        ALOGV("mEmptyQueueMutex unlocking: %d", __LINE__);
+                        mEmptyQueueMutex.unlock();
+                        ALOGV("mEmptyQueueMutex unlocked: %d", __LINE__);
+                        if (mFilledQueue.empty() && mReachedEOS && mGenerateEOS) {
+                            ALOGV("Posting the EOS to the observer player %p", mObserver);
+                            mEosEventReceived = true;
+                            if (mObserver != NULL) {
+                                ALOGV("mObserver: posting EOS");
+                                mObserver->postEOS(0);
+                            }
+                        }
+                        break;
+                    }
+                }
+                mFilledQueueMutex.unlock();
+                 mWriteCv.signal();
+            }
+            break;
+        case AUDIO_EVENT_SUSPEND:
+            {
+                struct msm_audio_stats stats;
+                int nBytesConsumed = 0;
+
+                ALOGV("AUDIO_EVENT_SUSPEND received\n");
+                if (!mPaused) {
+                    ALOGV("Not in paused, no need to honor SUSPEND event");
+                    break;
+                }
+                // 1. Get the Byte count that is consumed
+                if ( ioctl(afd, AUDIO_GET_STATS, &stats)  < 0 ) {
+                    ALOGE("AUDIO_GET_STATUS failed");
+                } else {
+                    ALOGV("Number of bytes consumed by DSP is %u", stats.byte_count);
+                    nBytesConsumed = stats.byte_count;
+                    }
+                    // Reset eosflag to resume playback where we actually paused
+                    mReachedEOS = false;
+                    // 3. Call AUDIO_STOP on the Driver.
+                    ALOGV("Received AUDIO_EVENT_SUSPEND and calling AUDIO_STOP");
+                    if ( ioctl(afd, AUDIO_STOP, 0) < 0 ) {
+                         ALOGE("AUDIO_STOP failed");
+                    }
+                    mIsDriverStarted = false;
+                    break;
+            }
+            break;
+        case AUDIO_EVENT_RESUME:
+            {
+                ALOGV("AUDIO_EVENT_RESUME received\n");
+            }
+            break;
+        default:
+            ALOGE("Received Invalid Event from driver\n");
+            break;
+        }
+    }
+    mEventThreadAlive = false;
+    ALOGV("Event Thread is dying.");
+}
+
+
+void AudioHardware::AudioSessionOutLPA::createEventThread()
+{
+    ALOGV("Creating Event Thread");
+    mKillEventThread = false;
+    mEventThreadAlive = true;
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+    pthread_create(&mEventThread, &attr, eventThreadWrapper, this);
+    ALOGV("Event Thread created");
+}
+
+status_t AudioHardware::AudioSessionOutLPA::start( ) //TODO YM LPA removed start time
+{
+
+    ALOGV("LPA playback start");
+    if (mPaused && mIsDriverStarted) {
+        mPaused = false;
+        if (ioctl(afd, AUDIO_PAUSE, 0) < 0) {
+            ALOGE("Resume:: LPA driver resume failed");
+            return UNKNOWN_ERROR;
+        }
+    } else {
+	    //get config, set config and AUDIO_START LPA driver
+	    int sessionId = 0;
+            mPaused = false;
+	    if ( afd >= 0 ) {
+		    struct msm_audio_config config;
+		    if ( ioctl(afd, AUDIO_GET_CONFIG, &config) < 0 ) {
+                         ALOGE("could not get config");
+                         close(afd);
+                         afd = -1;
+                         return BAD_VALUE;
+                     }
+
+                    config.sample_rate = mSampleRate;
+                    config.channel_count = mChannels;
+                    ALOGV("sample_rate=%d and channel count=%d \n", mSampleRate, mChannels);
+                    if ( ioctl(afd, AUDIO_SET_CONFIG, &config) < 0 ) {
+                         ALOGE("could not set config");
+                         close(afd);
+                         afd = -1;
+                         return BAD_VALUE;
+                 }
+            }
+	    //Start the Driver
+            if (ioctl(afd, AUDIO_START,0) < 0) {
+                 ALOGE("Driver start failed!");
+                 return BAD_VALUE;
+            }
+            mIsDriverStarted = true;
+            if (timeStarted == 0)
+                timeStarted = nanoseconds_to_microseconds(systemTime(SYSTEM_TIME_MONOTONIC));// Needed
+    }
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioSessionOutLPA::pause()
+{
+    ALOGV("LPA playback pause");
+    if (ioctl(afd, AUDIO_PAUSE, 1) < 0) {
+    ALOGE("Audio Pause failed");
+    }
+    mPaused = true;
+	timePlayed += (nanoseconds_to_microseconds(systemTime(SYSTEM_TIME_MONOTONIC)) - timeStarted);//needed
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioSessionOutLPA::drain()
+{
+    ALOGV("LPA playback EOS");
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioSessionOutLPA::flush()
+{
+	Mutex::Autolock autoLock(mLock);
+    ALOGV("LPA playback flush ");
+    int err;
+    // 2.) Add all the available buffers to Empty Queue (Maintain order)
+    mFilledQueueMutex.lock();
+    mEmptyQueueMutex.lock();
+    while (!mFilledQueue.empty()) {
+        List<BuffersAllocated>::iterator it = mFilledQueue.begin();
+        BuffersAllocated buf = *it;
+        buf.bytesToWrite = 0;
+        mEmptyQueue.push_back(buf);
+        mFilledQueue.erase(it);
+    }
+    mEmptyQueueMutex.unlock();
+    mFilledQueueMutex.unlock();
+    ALOGV("Transferred all the buffers from Filled queue to "
+          "Empty queue to handle seek");
+    ALOGV("mPaused %d mEosEventReceived %d", mPaused, mEosEventReceived);
+    mReachedEOS = false;
+    if (!mPaused) {
+        if(!mEosEventReceived) {
+            if (ioctl(afd, AUDIO_PAUSE, 1) < 0) {
+                ALOGE("Audio Pause failed");
+                return UNKNOWN_ERROR;
+            }
+            mSkipWrite = true;
+            if (ioctl(afd, AUDIO_FLUSH, 0) < 0) {
+                ALOGE("Audio Flush failed");
+                return UNKNOWN_ERROR;
+            }
+        }
+    } else {
+        timeStarted = 0;
+        mSkipWrite = true;
+        if (ioctl(afd, AUDIO_FLUSH, 0) < 0) {
+            ALOGE("Audio Flush failed");
+            return UNKNOWN_ERROR;
+        }
+        if (ioctl(afd, AUDIO_PAUSE, 1) < 0) {
+            ALOGE("Audio Pause failed");
+            return UNKNOWN_ERROR;
+        }
+    }
+    mEosEventReceived = false;
+    //4.) Skip the current write from the decoder and signal to the Write get
+    //   the next set of data from the decoder
+    mWriteCv.signal();
+    return NO_ERROR;
+}
+status_t AudioHardware::AudioSessionOutLPA::stop()
+{
+    Mutex::Autolock autoLock(mLock);
+    ALOGV("AudioSessionOutLPA- stop");
+    // close all the existing PCM devices
+    mSkipWrite = true;
+    mWriteCv.signal();
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioSessionOutLPA::setObserver(void *observer)
+{
+    ALOGV("Registering the callback \n");
+    mObserver = reinterpret_cast<AudioEventObserver *>(observer);
+    return NO_ERROR;
+}
+
+status_t  AudioHardware::AudioSessionOutLPA::getNextWriteTimestamp(int64_t *timestamp)
+{
+
+    *timestamp = nanoseconds_to_microseconds(systemTime(SYSTEM_TIME_MONOTONIC)) - timeStarted + timePlayed;//needed
+    ALOGV("Timestamp returned = %lld\n", *timestamp);
+    return NO_ERROR;
+}
+
+void AudioHardware::AudioSessionOutLPA::reset()
+{
+    ALOGD("AudioSessionOutLPA::reset()");
+    mGenerateEOS = false;
+    //Close the LPA driver
+    ioctl(afd,AUDIO_STOP,0);
+    mIsDriverStarted = false;
+    requestAndWaitForEventThreadExit();
+    status_t status = NO_ERROR;
+    bufferDeAlloc();
+    ::close(afd);
+    lpa_playback_in_progress = false;
+    ALOGD("AudioSessionOutLPA::reset() complete");
+}
+
+status_t AudioHardware::AudioSessionOutLPA::getRenderPosition(uint32_t *dspFrames)
+{
+    //TODO: enable when supported by driver
+    return INVALID_OPERATION;
+}
+
+
+status_t AudioHardware::AudioSessionOutLPA::getBufferInfo(buf_info **buf) {
+
+    buf_info *tempbuf = (buf_info *)malloc(sizeof(buf_info) + mInputBufferCount*sizeof(int *));
+    ALOGV("Get buffer info");
+    tempbuf->bufsize = LPA_BUFFER_SIZE;
+    tempbuf->nBufs = mInputBufferCount;
+    tempbuf->buffers = (int **)((char*)tempbuf + sizeof(buf_info));
+    List<BuffersAllocated>::iterator it = mEmptyQueue.begin();
+    for (int i = 0; i < mInputBufferCount; i++) {
+        tempbuf->buffers[i] = (int *)it->memBuf;
+        it++;
+    }
+    *buf = tempbuf;
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioSessionOutLPA::isBufferAvailable(int *isAvail) {
+
+    Mutex::Autolock autoLock(mLock);
+    ALOGV("isBufferAvailable Empty Queue size() = %d, Filled Queue size() = %d ",
+          mEmptyQueue.size(),mFilledQueue.size());
+    *isAvail = false;
+    // 1.) Wait till a empty buffer is available in the Empty buffer queue
+    mEmptyQueueMutex.lock();
+    if (mEmptyQueue.empty()) {
+        ALOGV("Write: waiting on mWriteCv");
+        mLock.unlock();
+        mWriteCv.wait(mEmptyQueueMutex);
+        mEmptyQueueMutex.unlock();
+        mLock.lock();
+        if (mSkipWrite) {
+            ALOGV("Write: Flushing the previous write buffer");
+            mSkipWrite = false;
+            return NO_ERROR;
+        }
+        ALOGV("Write: received a signal to wake up");
+        } else {
+       ALOGV("Buffer available in empty queue");
+       mEmptyQueueMutex.unlock();
+    }
+
+    *isAvail = true;
+    return NO_ERROR;
+}
+
+// End AudioSessionOutLPA
+//.----------------------------------------------------------------------------
+
+//.----------------------------------------------------------------------------
+AudioHardware::AudioStreamInMSM72xx::~AudioStreamInMSM72xx()
+{
+    ALOGV("AudioStreamInMSM72xx destructor");
+    AudioStreamInMSM72xx::InstanceCount--;
+    standby();
+}
+
+ssize_t AudioHardware::AudioStreamInMSM72xx::read( void* buffer, ssize_t bytes)
+{
+//    ALOGV("AudioStreamInMSM72xx::read(%p, %ld)", buffer, bytes);
+    if (!mHardware) return -1;
+
+    size_t count = bytes;
+    size_t  aac_framesize= bytes;
+    uint8_t* p = static_cast<uint8_t*>(buffer);
+    uint32_t* recogPtr = (uint32_t *)p;
+    uint16_t* frameCountPtr;
+    uint16_t* frameSizePtr;
+
+    if (mState < AUDIO_INPUT_OPENED) {
+        AudioHardware *hw = mHardware;
+        hw->mLock.lock();
+        status_t status = set(hw, mDevices, &mFormat, &mChannels, &mSampleRate, mAcoustics);
+        hw->mLock.unlock();
+        if (status != NO_ERROR) {
+            return -1;
+        }
+        mFirstread = false;
+    }
+
+    if (mState < AUDIO_INPUT_STARTED) {
+        mState = AUDIO_INPUT_STARTED;
+        // force routing to input device
+#ifdef QCOM_FM_ENABLED
+        if (mDevices != AudioSystem::DEVICE_IN_FM_RX) {
+            mHardware->clearCurDevice();
+            mHardware->doRouting(this);
+        }
+#endif
+        if (ioctl(mFd, AUDIO_START, 0)) {
+            ALOGE("Error starting record");
+            standby();
+            return -1;
+        }
+    }
+
+    // Resetting the bytes value, to return the appropriate read value
+    bytes = 0;
+    if (mFormat == AudioSystem::AAC)
+    {
+        *((uint32_t*)recogPtr) = 0x51434F4D ;// ('Q','C','O', 'M') Number to identify format as AAC by higher layers
+        recogPtr++;
+        frameCountPtr = (uint16_t*)recogPtr;
+        *frameCountPtr = 0;
+        p += 3*sizeof(uint16_t);
+        count -= 3*sizeof(uint16_t);
+    }
+    while (count > 0) {
+
+        if (mFormat == AudioSystem::AAC) {
+            frameSizePtr = (uint16_t *)p;
+            p += sizeof(uint16_t);
+            if(!(count > 2)) break;
+            count -= sizeof(uint16_t);
+        }
+
+        ssize_t bytesRead = ::read(mFd, p, count);
+        if (bytesRead > 0) {
+            count -= bytesRead;
+            p += bytesRead;
+            bytes += bytesRead;
+
+            if (mFormat == AudioSystem::AAC){
+                *frameSizePtr =  bytesRead;
+                (*frameCountPtr)++;
+            }
+
+            if(!mFirstread)
+            {
+               mFirstread = true;
+               break;
+            }
+
+        }
+        else if(bytesRead == 0)
+        {
+         ALOGI("Bytes Read = %d ,Buffer no longer sufficient",bytesRead);
+         break;
+        } else {
+            if (errno != EAGAIN) return bytesRead;
+            mRetryCount++;
+            ALOGW("EAGAIN - retrying");
+        }
+    }
+    if (mFormat == AudioSystem::AAC)
+         return aac_framesize;
+
+    return bytes;
+}
+
+status_t AudioHardware::AudioStreamInMSM72xx::standby()
+{
+    if (mState > AUDIO_INPUT_CLOSED) {
+        if (mFd >= 0) {
+            ::close(mFd);
+            mFd = -1;
+        }
+        mState = AUDIO_INPUT_CLOSED;
+    }
+    if (!mHardware) return -1;
+    // restore output routing if necessary
+#ifdef QCOM_FM_ENABLED
+    if (!mHardware->IsFmon())
+#endif
+    {
+        mHardware->clearCurDevice();
+        mHardware->doRouting(this);
+    }
+#ifdef QCOM_FM_ENABLED
+    if(mHardware->IsFmA2dpOn())
+        mHardware->SwitchOffFmA2dp();
+#endif
+
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioStreamInMSM72xx::dump(int fd, const Vector<String16>& args)
+{
+    const size_t SIZE = 256;
+    char buffer[SIZE];
+    String8 result;
+    result.append("AudioStreamInMSM72xx::dump\n");
+    snprintf(buffer, SIZE, "\tsample rate: %d\n", sampleRate());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tbuffer size: %d\n", bufferSize());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tchannels: %d\n", channels());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tformat: %d\n", format());
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmHardware: %p\n", mHardware);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmFd count: %d\n", mFd);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmState: %d\n", mState);
+    result.append(buffer);
+    snprintf(buffer, SIZE, "\tmRetryCount: %d\n", mRetryCount);
+    result.append(buffer);
+    ::write(fd, result.string(), result.size());
+    return NO_ERROR;
+}
+
+status_t AudioHardware::AudioStreamInMSM72xx::setParameters(const String8& keyValuePairs)
+{
+    AudioParameter param = AudioParameter(keyValuePairs);
+    String8 key = String8(AudioParameter::keyRouting);
+    status_t status = NO_ERROR;
+    int device;
+    ALOGV("AudioStreamInMSM72xx::setParameters() %s", keyValuePairs.string());
+
+    if (param.getInt(key, device) == NO_ERROR) {
+        ALOGD("set input routing %x", device);
+        if (device & (device - 1)) {
+            status = BAD_VALUE;
+        } else {
+            mDevices = device;
+            status = mHardware->doRouting(this);
+        }
+        param.remove(key);
+    }
+
+    if (param.size()) {
+        status = BAD_VALUE;
+    }
+    return status;
+}
+
+String8 AudioHardware::AudioStreamInMSM72xx::getParameters(const String8& keys)
+{
+    AudioParameter param = AudioParameter(keys);
+    String8 value;
+    String8 key = String8(AudioParameter::keyRouting);
+
+    if (param.get(key, value) == NO_ERROR) {
+        ALOGV("get routing %x", mDevices);
+        param.addInt(key, (int)mDevices);
+    }
+
+    ALOGV("AudioStreamInMSM72xx::getParameters() %s", param.toString().string());
+    return param.toString();
+}
+
+// ----------------------------------------------------------------------------
+
+extern "C" AudioHardwareInterface* createAudioHardware(void) {
+    return new AudioHardware();
+}
+
+}; // namespace android
diff --git a/audio/AudioPolicyManager.cpp b/audio/AudioPolicyManager.cpp
new file mode 100644
index 0000000..6f8aeea
--- /dev/null
+++ b/audio/AudioPolicyManager.cpp
@@ -0,0 +1,1541 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "AudioPolicyManager7627a"
+//#define LOG_NDEBUG 0
+
+//#define VERY_VERBOSE_LOGGING
+#ifdef VERY_VERBOSE_LOGGING
+#define ALOGVV ALOGV
+#else
+#define ALOGVV(a...) do { } while(0)
+#endif
+
+// A device mask for all audio input devices that are considered "virtual" when evaluating
+// active inputs in getActiveInput()
+#define APM_AUDIO_IN_DEVICE_VIRTUAL_ALL  AUDIO_DEVICE_IN_REMOTE_SUBMIX
+// A device mask for all audio output devices that are considered "remote" when evaluating
+// active output devices in isStreamActiveRemotely()
+#define APM_AUDIO_OUT_DEVICE_REMOTE_ALL  AUDIO_DEVICE_OUT_REMOTE_SUBMIX
+
+#include <utils/Log.h>
+#include "AudioPolicyManager.h"
+#include <hardware/audio_effect.h>
+#include <media/mediarecorder.h>
+#include <hardware/audio.h>
+#include <math.h>
+#include <hardware_legacy/audio_policy_conf.h>
+#include <fcntl.h>
+#include <cutils/properties.h> // for property_get
+
+namespace android_audio_legacy {
+
+
+// ----------------------------------------------------------------------------
+// AudioPolicyManager for msm7k platform
+// Common audio policy manager code is implemented in AudioPolicyManagerBase class
+// ----------------------------------------------------------------------------
+
+// ---  class factory
+
+
+extern "C" AudioPolicyInterface* createAudioPolicyManager(AudioPolicyClientInterface *clientInterface)
+{
+    return new AudioPolicyManager(clientInterface);
+}
+
+extern "C" void destroyAudioPolicyManager(AudioPolicyInterface *interface)
+{
+    delete interface;
+}
+
+audio_io_handle_t AudioPolicyManager::getOutput(AudioSystem::stream_type stream,
+                                    uint32_t samplingRate,
+                                    uint32_t format,
+                                    uint32_t channelMask,
+                                    AudioSystem::output_flags flags,
+                                    const audio_offload_info_t *offloadInfo)
+{
+    audio_io_handle_t output = 0;
+    uint32_t latency = 0;
+    routing_strategy strategy = getStrategy((AudioSystem::stream_type)stream);
+    audio_devices_t device = getDeviceForStrategy(strategy, false /*fromCache*/);
+    ALOGV("getOutput() device %d, stream %d, samplingRate %d, format %d, channelMask %x, flags %x",
+          device, stream, samplingRate, format, channelMask, flags);
+
+#ifdef AUDIO_POLICY_TEST
+    if (mCurOutput != 0) {
+        ALOGV("getOutput() test output mCurOutput %d, samplingRate %d, format %d, channelMask %x, mDirectOutput %d",
+                mCurOutput, mTestSamplingRate, mTestFormat, mTestChannels, mDirectOutput);
+
+        if (mTestOutputs[mCurOutput] == 0) {
+            ALOGV("getOutput() opening test output");
+            AudioOutputDescriptor *outputDesc = new AudioOutputDescriptor(NULL);
+            outputDesc->mDevice = mTestDevice;
+            outputDesc->mSamplingRate = mTestSamplingRate;
+            outputDesc->mFormat = mTestFormat;
+            outputDesc->mChannelMask = mTestChannels;
+            outputDesc->mLatency = mTestLatencyMs;
+            outputDesc->mFlags = (audio_output_flags_t)(mDirectOutput ? AudioSystem::OUTPUT_FLAG_DIRECT : 0);
+            outputDesc->mRefCount[stream] = 0;
+            mTestOutputs[mCurOutput] = mpClientInterface->openOutput(0, &outputDesc->mDevice,
+                                            &outputDesc->mSamplingRate,
+                                            &outputDesc->mFormat,
+                                            &outputDesc->mChannelMask,
+                                            &outputDesc->mLatency,
+                                            outputDesc->mFlags,
+                                            offloadInfo);
+            if (mTestOutputs[mCurOutput]) {
+                AudioParameter outputCmd = AudioParameter();
+                outputCmd.addInt(String8("set_id"),mCurOutput);
+                mpClientInterface->setParameters(mTestOutputs[mCurOutput],outputCmd.toString());
+                addOutput(mTestOutputs[mCurOutput], outputDesc);
+            }
+        }
+        return mTestOutputs[mCurOutput];
+    }
+#endif //AUDIO_POLICY_TEST
+
+    // open a direct output if required by specified parameters
+    // force direct flag if offload flag is set: offloading implies a direct output stream
+    // and all common behaviors are driven by checking only the direct flag
+    // this should normally be set appropriately in the policy configuration file
+    if ((flags & AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) != 0) {
+        flags = (AudioSystem::output_flags)(flags | AUDIO_OUTPUT_FLAG_DIRECT);
+    }
+
+    IOProfile *profile = NULL;
+    if (flags & AUDIO_OUTPUT_FLAG_DIRECT) {
+        profile = getProfileForDirectOutput(device,
+                                            samplingRate,
+                                            format,
+                                            channelMask,
+                                            (audio_output_flags_t)flags);
+    }
+    if (profile != NULL) {
+        AudioOutputDescriptor *outputDesc = NULL;
+
+        for (size_t i = 0; i < mOutputs.size(); i++) {
+            AudioOutputDescriptor *desc = mOutputs.valueAt(i);
+            if (!desc->isDuplicated() && (profile == desc->mProfile)) {
+                outputDesc = desc;
+                // reuse direct output if currently open and configured with same parameters
+                if ((samplingRate == outputDesc->mSamplingRate) &&
+                        (format == outputDesc->mFormat) &&
+                        (channelMask == outputDesc->mChannelMask)) {
+                    outputDesc->mDirectOpenCount++;
+                    ALOGV("getOutput() reusing direct output %d", mOutputs.keyAt(i));
+                    return mOutputs.keyAt(i);
+                }
+            }
+        }
+        // close direct output if currently open and configured with different parameters
+        if (outputDesc != NULL) {
+            closeOutput(outputDesc->mId);
+        }
+        outputDesc = new AudioOutputDescriptor(profile);
+        outputDesc->mDevice = device;
+        outputDesc->mSamplingRate = samplingRate;
+        outputDesc->mFormat = (audio_format_t)format;
+        outputDesc->mChannelMask = (audio_channel_mask_t)channelMask;
+        outputDesc->mLatency = 0;
+        outputDesc->mFlags = (audio_output_flags_t) (outputDesc->mFlags | flags);
+        outputDesc->mRefCount[stream] = 0;
+        outputDesc->mStopTime[stream] = 0;
+        outputDesc->mDirectOpenCount = 1;
+        output = mpClientInterface->openOutput(profile->mModule->mHandle,
+                                        &outputDesc->mDevice,
+                                        &outputDesc->mSamplingRate,
+                                        &outputDesc->mFormat,
+                                        &outputDesc->mChannelMask,
+                                        &outputDesc->mLatency,
+                                        outputDesc->mFlags,
+                                        offloadInfo);
+
+        // only accept an output with the requested parameters
+        if (output == 0 ||
+            (samplingRate != 0 && samplingRate != outputDesc->mSamplingRate) ||
+            (format != 0 && format != outputDesc->mFormat) ||
+            (channelMask != 0 && channelMask != outputDesc->mChannelMask)) {
+            ALOGV("getOutput() failed opening direct output: output %d samplingRate %d %d,"
+                    "format %d %d, channelMask %04x %04x", output, samplingRate,
+                    outputDesc->mSamplingRate, format, outputDesc->mFormat, channelMask,
+                    outputDesc->mChannelMask);
+            if (output != 0) {
+                mpClientInterface->closeOutput(output);
+            }
+            delete outputDesc;
+            return 0;
+        }
+        addOutput(output, outputDesc);
+        mPreviousOutputs = mOutputs;
+        ALOGV("getOutput() returns new direct output %d", output);
+        return output;
+    }
+
+    // ignoring channel mask due to downmix capability in mixer
+
+    // for non direct outputs, only PCM is supported
+    if (audio_is_linear_pcm((audio_format_t)format)) {
+        // get which output is suitable for the specified stream. The actual
+        // routing change will happen when startOutput() will be called
+        SortedVector<audio_io_handle_t> outputs = getOutputsForDevice(device, mOutputs);
+
+        output = selectOutput(outputs, flags);
+    }
+
+    ALOGW_IF((output ==0), "getOutput() could not find output for stream %d, samplingRate %d,"
+            "format %d, channels %x, flags %x", stream, samplingRate, format, channelMask, flags);
+
+    ALOGV("getOutput() returns output %d", output);
+
+    return output;
+}
+
+void AudioPolicyManager::releaseOutput(audio_io_handle_t output)
+{
+    ALOGV("releaseOutput() %d", output);
+    ssize_t index = mOutputs.indexOfKey(output);
+    if (index < 0) {
+        ALOGW("releaseOutput() releasing unknown output %d", output);
+        return;
+    }
+
+    AudioOutputDescriptor *desc = mOutputs.valueAt(index);
+    if (desc->mFlags & AudioSystem::OUTPUT_FLAG_DIRECT) {
+        if ((desc->mDirectOpenCount <= 0) && !(desc->mFlags & AUDIO_OUTPUT_FLAG_LPA || desc->mFlags & AUDIO_OUTPUT_FLAG_TUNNEL ||
+                desc->mFlags & AUDIO_OUTPUT_FLAG_VOIP_RX)) {
+            ALOGW("releaseOutput() invalid open count %d for output %d",
+                                                              desc->mDirectOpenCount, output);
+            return;
+        }
+        if ((--desc->mDirectOpenCount == 0) || ((desc->mFlags & AUDIO_OUTPUT_FLAG_LPA || desc->mFlags & AUDIO_OUTPUT_FLAG_TUNNEL ||
+                desc->mFlags & AUDIO_OUTPUT_FLAG_VOIP_RX))) {
+            ALOGV("releaseOutput() closing output");
+            closeOutput(output);
+        }
+    }
+
+}
+
+audio_devices_t AudioPolicyManager::getDeviceForStrategy(routing_strategy strategy, bool fromCache)
+{
+    uint32_t device = 0;
+
+    if (fromCache) {
+        ALOGV("getDeviceForStrategy() from cache strategy %d, device %x",
+              strategy, mDeviceForStrategy[strategy]);
+        return mDeviceForStrategy[strategy];
+    }
+
+    switch (strategy) {
+
+    case STRATEGY_SONIFICATION_RESPECTFUL:
+        if (isInCall()) {
+            device = getDeviceForStrategy(STRATEGY_SONIFICATION, false /*fromCache*/);
+        } else if (isStreamActiveRemotely(AudioSystem::MUSIC,
+                SONIFICATION_RESPECTFUL_AFTER_MUSIC_DELAY)) {
+            // while media is playing on a remote device, use the the sonification behavior.
+            // Note that we test this usecase before testing if media is playing because
+            //   the isStreamActive() method only informs about the activity of a stream, not
+            //   if it's for local playback. Note also that we use the same delay between both tests
+            device = getDeviceForStrategy(STRATEGY_SONIFICATION, false /*fromCache*/);
+        } else if (isStreamActive(AudioSystem::MUSIC, SONIFICATION_RESPECTFUL_AFTER_MUSIC_DELAY)) {
+            // while media is playing (or has recently played), use the same device
+            device = getDeviceForStrategy(STRATEGY_MEDIA, false /*fromCache*/);
+        } else {
+            // when media is not playing anymore, fall back on the sonification behavior
+            device = getDeviceForStrategy(STRATEGY_SONIFICATION, false /*fromCache*/);
+        }
+
+        break;
+
+    case STRATEGY_DTMF:
+        if (!isInCall()) {
+            // when off call, DTMF strategy follows the same rules as MEDIA strategy
+            device = getDeviceForStrategy(STRATEGY_MEDIA, false /*fromCache*/);
+            break;
+        }
+        // when in call, DTMF and PHONE strategies follow the same rules
+        // FALL THROUGH
+
+    case STRATEGY_PHONE:
+        // for phone strategy, we first consider the forced use and then the available devices by order
+        // of priority
+        switch (mForceUse[AudioSystem::FOR_COMMUNICATION]) {
+        case AudioSystem::FORCE_BT_SCO:
+            if (!isInCall() || strategy != STRATEGY_DTMF) {
+                device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
+                if (device) break;
+            }
+            device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
+            if (device) break;
+            device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_SCO;
+            if (device) break;
+            // if SCO device is requested but no SCO device is available, fall back to default case
+            // FALL THROUGH
+
+        default:    // FORCE_NONE
+            // when not in a phone call, phone strategy should route STREAM_VOICE_CALL to A2DP
+            if (mHasA2dp && !isInCall() &&
+                    (mForceUse[AudioSystem::FOR_MEDIA] != AudioSystem::FORCE_NO_BT_A2DP) &&
+                    (getA2dpOutput() != 0) && !mA2dpSuspended) {
+                device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP;
+                if (device) break;
+                device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES;
+                if (device) break;
+            }
+            device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADPHONE;
+            if (device) break;
+            device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADSET;
+            if (device) break;
+            device = mAvailableOutputDevices & AUDIO_DEVICE_OUT_USB_DEVICE;
+            if (device) break;
+            device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_DGTL_DOCK_HEADSET;
+            if (device) break;
+            device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_AUX_DIGITAL;
+            if (device) break;
+            device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_ANLG_DOCK_HEADSET;
+            if (device) break;
+            device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_EARPIECE;
+            if (device) break;
+            device = mDefaultOutputDevice;
+            if (device == AUDIO_DEVICE_NONE) {
+                ALOGE("getDeviceForStrategy() no device found for STRATEGY_PHONE");
+            }
+            break;
+
+        case AudioSystem::FORCE_SPEAKER:
+            // when not in a phone call, phone strategy should route STREAM_VOICE_CALL to
+            // A2DP speaker when forcing to speaker output
+            if (mHasA2dp && !isInCall() &&
+                    (mForceUse[AudioSystem::FOR_MEDIA] != AudioSystem::FORCE_NO_BT_A2DP) &&
+                    (getA2dpOutput() != 0) && !mA2dpSuspended) {
+                device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER;
+                if (device) break;
+            }
+            device = mAvailableOutputDevices & AUDIO_DEVICE_OUT_USB_DEVICE;
+            if (device) break;
+            device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_DGTL_DOCK_HEADSET;
+            if (device) break;
+            device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_AUX_DIGITAL;
+            if (device) break;
+            device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_ANLG_DOCK_HEADSET;
+            if (device) break;
+            device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_SPEAKER;
+            if (device) break;
+            device = mDefaultOutputDevice;
+            if (device == AUDIO_DEVICE_NONE) {
+                ALOGE("getDeviceForStrategy() no device found for STRATEGY_PHONE, FORCE_SPEAKER");
+            }
+            break;
+        }
+    break;
+
+    case STRATEGY_SONIFICATION:
+
+        // If incall, just select the STRATEGY_PHONE device: The rest of the behavior is handled by
+        // handleIncallSonification().
+        if (isInCall()) {
+            device = getDeviceForStrategy(STRATEGY_PHONE, false /*fromCache*/);
+            break;
+        }
+        // FALL THROUGH
+
+    case STRATEGY_ENFORCED_AUDIBLE:
+        // strategy STRATEGY_ENFORCED_AUDIBLE uses same routing policy as STRATEGY_SONIFICATION
+        // except:
+        //   - when in call where it doesn't default to STRATEGY_PHONE behavior
+        //   - in countries where not enforced in which case it follows STRATEGY_MEDIA
+
+        if (strategy == STRATEGY_SONIFICATION ||
+                !mStreams[AUDIO_STREAM_ENFORCED_AUDIBLE].mCanBeMuted) {
+            device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_SPEAKER;
+            if (device == AUDIO_DEVICE_NONE) {
+                ALOGE("getDeviceForStrategy() speaker device not found for STRATEGY_SONIFICATION");
+            }
+        }
+        // The second device used for sonification is the same as the device used by media strategy
+        // FALL THROUGH
+
+        // for analog FM alerts should be played on the speaker only
+        if(FM_ANALOG == getFMMode())
+            break;
+    case STRATEGY_MEDIA: {
+        uint32_t device2 = 0;
+        switch (mForceUse[AudioSystem::FOR_MEDIA]) {
+        default:{
+        if ((mHasA2dp && (mForceUse[AudioSystem::FOR_MEDIA] != AudioSystem::FORCE_NO_BT_A2DP) &&
+                (getA2dpOutput() != 0) && !mA2dpSuspended ) && !(FM_ANALOG == getFMMode())) {
+            device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP;
+            if (device2 == 0) {
+                device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES;
+            }
+            if (device2 == 0) {
+                device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER;
+            }
+        }
+        if (device2 == 0) {
+            device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADPHONE;
+        }
+        if (device2 == 0) {
+            device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADSET;
+        }
+        if (device2 == 0) {
+            device2 = mAvailableOutputDevices & AUDIO_DEVICE_OUT_USB_ACCESSORY;
+        }
+        if (device2 == 0) {
+            device2 = mAvailableOutputDevices & AUDIO_DEVICE_OUT_USB_DEVICE;
+        }
+        if (device2 == 0) {
+            device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_DGTL_DOCK_HEADSET;
+        }
+        if (device2 == 0) {
+            device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_AUX_DIGITAL;
+        }
+        if (device2 == 0) {
+            device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_ANLG_DOCK_HEADSET;
+        }
+        if (device2 == 0) {
+            device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_SPEAKER;
+        }
+
+        // device is DEVICE_OUT_SPEAKER if we come from case STRATEGY_SONIFICATION or
+        // STRATEGY_ENFORCED_AUDIBLE, 0 otherwise
+        device |= device2;
+        if (device) break;
+        device = mDefaultOutputDevice;
+      }
+      case AudioSystem::FORCE_SPEAKER:
+          device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_SPEAKER;
+          break;
+      }
+#ifdef QCOM_FM_ENABLED
+      if (mAvailableOutputDevices & AudioSystem::DEVICE_OUT_FM) {
+         device |= AudioSystem::DEVICE_OUT_FM;
+         if(FM_ANALOG == getFMMode()){
+           if (device == (AudioSystem::DEVICE_OUT_SPEAKER | AudioSystem::DEVICE_OUT_WIRED_HEADSET | AudioSystem::DEVICE_OUT_FM))
+                device = AudioSystem::DEVICE_OUT_SPEAKER;
+           else if(device & AudioSystem::DEVICE_OUT_WIRED_HEADSET)
+                device &= ~(device & AudioSystem::DEVICE_OUT_WIRED_HEADSET);
+         }
+      }
+#endif
+      // Do not play media stream if in call and the requested device would change the hardware
+      // output routing
+      if (mPhoneState == AudioSystem::MODE_IN_CALL &&
+         !AudioSystem::isA2dpDevice((AudioSystem::audio_devices)device) &&
+           device != getDeviceForStrategy(STRATEGY_PHONE) &&
+           strategy == STRATEGY_ENFORCED_AUDIBLE) {
+          if (!mStreams[AUDIO_STREAM_ENFORCED_AUDIBLE].mCanBeMuted) {
+              ALOGV("getDeviceForStrategy() do not change to phone device for ENFORCED_AUDIBLE");
+          } else {
+              device = getDeviceForStrategy(STRATEGY_PHONE);
+              ALOGV("getDeviceForStrategy() incompatible media and phone devices");
+          }
+      }
+      if (device == AUDIO_DEVICE_NONE) {
+        ALOGE("getDeviceForStrategy() no device found for STRATEGY_MEDIA");
+      }
+    } break;
+
+    default:
+        ALOGW("getDeviceForStrategy() unknown strategy: %d", strategy);
+        break;
+    }
+
+    ALOGV("getDeviceForStrategy() strategy %d, device %x", strategy, device);
+    return (audio_devices_t)device;
+}
+
+uint32_t AudioPolicyManager::checkDeviceMuteStrategies(AudioOutputDescriptor *outputDesc,
+                                                       audio_devices_t prevDevice,
+                                                       uint32_t delayMs)
+{
+    // mute/unmute strategies using an incompatible device combination
+    // if muting, wait for the audio in pcm buffer to be drained before proceeding
+    // if unmuting, unmute only after the specified delay
+    if (outputDesc->isDuplicated()) {
+        return 0;
+    }
+
+    uint32_t muteWaitMs = 0;
+    audio_devices_t device = outputDesc->device();
+#ifdef QCOM_FM_ENABLED
+    bool shouldMute = outputDesc->isActive() &&
+                    (AudioSystem::popCount(device) >= (device & AUDIO_DEVICE_OUT_FM ? 3 : 2));
+#else
+    bool shouldMute = outputDesc->isActive();
+#endif
+    // temporary mute output if device selection changes to avoid volume bursts due to
+    // different per device volumes
+    bool tempMute = outputDesc->isActive() && (getDeviceForVolume(device) != getDeviceForVolume(prevDevice));
+
+    for (size_t i = 0; i < NUM_STRATEGIES; i++) {
+        audio_devices_t curDevice = getDeviceForStrategy((routing_strategy)i, false /*fromCache*/);
+        bool mute = shouldMute && (curDevice & device) && (curDevice != device);
+        bool doMute = false;
+
+        if (mute && !outputDesc->mStrategyMutedByDevice[i]) {
+            doMute = true;
+            outputDesc->mStrategyMutedByDevice[i] = true;
+        } else if (!mute && outputDesc->mStrategyMutedByDevice[i]){
+            doMute = true;
+            outputDesc->mStrategyMutedByDevice[i] = false;
+        }
+        if (doMute || tempMute) {
+            for (size_t j = 0; j < mOutputs.size(); j++) {
+                AudioOutputDescriptor *desc = mOutputs.valueAt(j);
+                if ((desc->supportedDevices() & outputDesc->supportedDevices()) == AUDIO_DEVICE_NONE) {
+                    continue;
+                }
+                audio_io_handle_t curOutput = mOutputs.keyAt(j);
+                ALOGVV("checkDeviceMuteStrategies() %s strategy %d (curDevice %04x) on output %d",
+                      mute ? "muting" : "unmuting", i, curDevice, curOutput);
+                setStrategyMute((routing_strategy)i, mute, curOutput, mute ? 0 : delayMs);
+                if (desc->isStrategyActive((routing_strategy)i)) {
+                    if (tempMute && (desc == outputDesc)) {
+                        setStrategyMute((routing_strategy)i, true, curOutput);
+                        setStrategyMute((routing_strategy)i, false, curOutput,
+                                            desc->latency() * 2, device);
+                    }
+                    if ((tempMute && (desc == outputDesc)) || mute) {
+                        if (muteWaitMs < desc->latency()) {
+                            muteWaitMs = desc->latency();
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    // FIXME: should not need to double latency if volume could be applied immediately by the
+    // audioflinger mixer. We must account for the delay between now and the next time
+    // the audioflinger thread for this output will process a buffer (which corresponds to
+    // one buffer size, usually 1/2 or 1/4 of the latency).
+    muteWaitMs *= 2;
+    // wait for the PCM output buffers to empty before proceeding with the rest of the command
+    if (muteWaitMs > delayMs) {
+        muteWaitMs -= delayMs;
+        usleep(muteWaitMs * 1000);
+        return muteWaitMs;
+    }
+    return 0;
+}
+
+status_t AudioPolicyManager::setDeviceConnectionState(audio_devices_t device,
+                                                      AudioSystem::device_connection_state state,
+                                                      const char *device_address)
+{
+    SortedVector <audio_io_handle_t> outputs;
+
+    ALOGV("setDeviceConnectionState() device: %x, state %d, address %s", device, state, device_address);
+    // connect/disconnect only 1 device at a time
+    if (!audio_is_output_device(device) && !audio_is_input_device(device)) return BAD_VALUE;
+
+    if (strlen(device_address) >= MAX_DEVICE_ADDRESS_LEN) {
+        ALOGE("setDeviceConnectionState() invalid address: %s", device_address);
+        return BAD_VALUE;
+    }
+
+    // handle output devices
+    if (audio_is_output_device(device)) {
+        if (!mHasA2dp && audio_is_a2dp_device(device)) {
+            ALOGE("setDeviceConnectionState() invalid A2DP device: %x", device);
+            return BAD_VALUE;
+        }
+        if (!mHasUsb && audio_is_usb_device(device)) {
+            ALOGE("setDeviceConnectionState() invalid USB audio device: %x", device);
+            return BAD_VALUE;
+        }
+        if (!mHasRemoteSubmix && audio_is_remote_submix_device((audio_devices_t)device)) {
+            ALOGE("setDeviceConnectionState() invalid remote submix audio device: %x", device);
+            return BAD_VALUE;
+        }
+
+        // save a copy of the opened output descriptors before any output is opened or closed
+        // by checkOutputsForDevice(). This will be needed by checkOutputForAllStrategies()
+        mPreviousOutputs = mOutputs;
+        switch (state)
+        {
+        // handle output device connection
+        case AudioSystem::DEVICE_STATE_AVAILABLE:
+#ifdef QCOM_FM_ENABLED
+            if(device == AudioSystem::DEVICE_OUT_FM){
+                char value[PROPERTY_VALUE_MAX];
+                fm_modes fmMode = FM_DIGITAL;
+
+                if (property_get("hw.fm.isAnalog", value, NULL)
+                && !strcasecmp(value, "true")){
+                    fmMode = FM_ANALOG ;
+                }
+
+                ALOGD("Current FM mode %d, New Fm Mode %d",getFMMode(),fmMode);
+
+                if (fmMode == getFMMode()){
+                    ALOGE("FM is already connected in %d Mode",fmMode);
+                    return INVALID_OPERATION;
+                } else if (FM_NONE != getFMMode()){
+                    ALOGE("Rejctng dev conction:Anlg FM & Dgtl FM Mutuly xclusve");
+                    return INVALID_OPERATION;
+                }else{
+                    setFmMode(fmMode);
+                    ALOGW("FM started in %d Mode",fmMode);
+                }
+            }
+#endif
+            if (mAvailableOutputDevices & device) {
+                ALOGW("setDeviceConnectionState() device already connected: %x", device);
+                return INVALID_OPERATION;
+            }
+            ALOGV("setDeviceConnectionState() connecting device %x", device);
+
+            if (checkOutputsForDevice(device, state, outputs) != NO_ERROR) {
+                return INVALID_OPERATION;
+            }
+            ALOGV("setDeviceConnectionState() checkOutputsForDevice() returned %d outputs",
+                  outputs.size());
+            // register new device as available
+            mAvailableOutputDevices = (audio_devices_t)(mAvailableOutputDevices | device);
+            ALOGV("setDeviceConnectionState() connecting device %x", mAvailableOutputDevices);
+
+            if (!outputs.isEmpty()) {
+                String8 paramStr;
+                if (mHasA2dp && audio_is_a2dp_device(device)) {
+                    // handle A2DP device connection
+                    AudioParameter param;
+                    param.add(String8(AUDIO_PARAMETER_A2DP_SINK_ADDRESS), String8(device_address));
+                    paramStr = param.toString();
+                    mA2dpDeviceAddress = String8(device_address, MAX_DEVICE_ADDRESS_LEN);
+                    mA2dpSuspended = false;
+                } else if (audio_is_bluetooth_sco_device(device)) {
+                    // handle SCO device connection
+                    mScoDeviceAddress = String8(device_address, MAX_DEVICE_ADDRESS_LEN);
+                } else if (mHasUsb && audio_is_usb_device(device)) {
+                    // handle USB device connection
+                    mUsbCardAndDevice = String8(device_address, MAX_DEVICE_ADDRESS_LEN);
+                    paramStr = mUsbCardAndDevice;
+                }
+                if (!paramStr.isEmpty()) {
+                    for (size_t i = 0; i < outputs.size(); i++) {
+                        mpClientInterface->setParameters(outputs[i], paramStr);
+                    }
+                }
+            }
+            break;
+        // handle output device disconnection
+        case AudioSystem::DEVICE_STATE_UNAVAILABLE: {
+#ifdef QCOM_FM_ENABLED
+            if(device == AudioSystem::DEVICE_OUT_FM){
+                uint32_t newDevice;
+                fm_modes prevFmMode = getFMMode();
+
+                ALOGD("turning off Fm device in Mode %d",getFMMode());
+                setFmMode(FM_NONE);
+                newDevice = getDeviceForStrategy(STRATEGY_MEDIA, false);
+                if((FM_ANALOG == prevFmMode) && ((newDevice & AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP) ||
+                   (newDevice & AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES)||
+                   (newDevice & AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER))) {
+                    ALOGW("setDeviceConnectionState() FM off, switch to Wired Headset");
+                    setOutputDevice(mPrimaryOutput, AUDIO_DEVICE_OUT_WIRED_HEADSET, true);
+                }
+            }
+#endif
+            if (!(mAvailableOutputDevices & device)) {
+                ALOGW("setDeviceConnectionState() device not connected: %x", device);
+                return INVALID_OPERATION;
+            }
+
+            ALOGV("setDeviceConnectionState() disconnecting device %x", device);
+            // remove device from available output devices
+            mAvailableOutputDevices = (audio_devices_t)(mAvailableOutputDevices & ~device);
+
+            checkOutputsForDevice((audio_devices_t)device, state, outputs);
+            if (mHasA2dp && audio_is_a2dp_device(device)) {
+                // handle A2DP device disconnection
+                mA2dpDeviceAddress = "";
+                mA2dpSuspended = false;
+            } else if (audio_is_bluetooth_sco_device(device)) {
+                // handle SCO device disconnection
+                mScoDeviceAddress = "";
+            } else if (mHasUsb && audio_is_usb_device(device)) {
+                // handle USB device disconnection
+                mUsbCardAndDevice = "";
+            }
+        } break;
+
+        default:
+            ALOGE("setDeviceConnectionState() invalid state: %x", state);
+            return BAD_VALUE;
+        }
+
+        audio_devices_t newDevice = AudioPolicyManagerBase::getNewDevice(mPrimaryOutput, false /*fromCache*/);
+#ifdef QCOM_FM_ENABLED
+        if (device == AudioSystem::DEVICE_OUT_FM) {
+            if (state == AudioSystem::DEVICE_STATE_AVAILABLE) {
+                mOutputs.valueFor(mPrimaryOutput)->changeRefCount(AudioSystem::FM, 1);
+            }
+            else {
+                mOutputs.valueFor(mPrimaryOutput)->changeRefCount(AudioSystem::FM, -1);
+            }
+            if (newDevice == 0) {
+                newDevice = getDeviceForStrategy(STRATEGY_MEDIA, false);
+            }
+        }
+#endif
+        setOutputDevice(mPrimaryOutput, newDevice);
+        checkA2dpSuspend();
+        AudioPolicyManagerBase::checkOutputForAllStrategies();
+        // outputs must be closed after checkOutputForAllStrategies() is executed
+        if (!outputs.isEmpty()) {
+            for (size_t i = 0; i < outputs.size(); i++) {
+                 AudioOutputDescriptor *desc = mOutputs.valueFor(outputs[i]);
+                 // close unused outputs after device disconnection or direct outputs that have been
+                 // opened by checkOutputsForDevice() to query dynamic parameters
+                 if ((state == AudioSystem::DEVICE_STATE_UNAVAILABLE) ||
+                         (((desc->mFlags & AUDIO_OUTPUT_FLAG_DIRECT) != 0) &&
+                          (desc->mDirectOpenCount == 0))) {
+                     closeOutput(outputs[i]);
+                 }
+            }
+        }
+
+        updateDevicesAndOutputs();
+        for (size_t i = 0; i < mOutputs.size(); i++) {
+            // do not force device change on duplicated output because if device is 0, it will
+            // also force a device 0 for the two outputs it is duplicated to which may override
+            // a valid device selection on those outputs.
+            setOutputDevice(mOutputs.keyAt(i), getNewDevice(mOutputs.keyAt(i), true /*fromCache*/),
+                            !mOutputs.valueAt(i)->isDuplicated(),
+                            0);
+        }
+
+        if (device == AUDIO_DEVICE_OUT_WIRED_HEADSET) {
+            device = AUDIO_DEVICE_IN_WIRED_HEADSET;
+        } else if (device == AUDIO_DEVICE_OUT_BLUETOOTH_SCO ||
+                   device == AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET ||
+                   device == AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT) {
+            device = AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET;
+        } else {
+            return NO_ERROR;
+        }
+    }
+    // handle input devices
+    if (audio_is_input_device(device)) {
+
+        switch (state)
+        {
+        // handle input device connection
+        case AudioSystem::DEVICE_STATE_AVAILABLE: {
+            if (mAvailableInputDevices & device) {
+                ALOGW("setDeviceConnectionState() device already connected: %d", device);
+                return INVALID_OPERATION;
+            }
+            mAvailableInputDevices = mAvailableInputDevices | (device & ~AUDIO_DEVICE_BIT_IN);
+            }
+            break;
+
+        // handle input device disconnection
+        case AudioSystem::DEVICE_STATE_UNAVAILABLE: {
+            if (!(mAvailableInputDevices & device)) {
+                ALOGW("setDeviceConnectionState() device not connected: %d", device);
+                return INVALID_OPERATION;
+            }
+            mAvailableInputDevices = (audio_devices_t) (mAvailableInputDevices & ~device);
+            } break;
+
+        default:
+            ALOGE("setDeviceConnectionState() invalid state: %x", state);
+            return BAD_VALUE;
+        }
+
+        audio_io_handle_t activeInput = getActiveInput();
+        if (activeInput != 0) {
+            AudioInputDescriptor *inputDesc = mInputs.valueFor(activeInput);
+            audio_devices_t newDevice = getDeviceForInputSource(inputDesc->mInputSource);
+            if ((newDevice != AUDIO_DEVICE_NONE) && (newDevice != inputDesc->mDevice)) {
+                ALOGV("setDeviceConnectionState() changing device from %x to %x for input %d",
+                        inputDesc->mDevice, newDevice, activeInput);
+                inputDesc->mDevice = newDevice;
+                AudioParameter param = AudioParameter();
+                param.addInt(String8(AudioParameter::keyRouting), (int)newDevice);
+                mpClientInterface->setParameters(activeInput, param.toString());
+            }
+        }
+
+        return NO_ERROR;
+    }
+
+    ALOGW("setDeviceConnectionState() invalid device: %x", device);
+    return BAD_VALUE;
+}
+
+void AudioPolicyManager::setForceUse(AudioSystem::force_use usage, AudioSystem::forced_config config)
+{
+    ALOGV("setForceUse() usage %d, config %d, mPhoneState %d", usage, config, mPhoneState);
+
+    bool forceVolumeReeval = false;
+    switch(usage) {
+    case AudioSystem::FOR_COMMUNICATION:
+        if (config != AudioSystem::FORCE_SPEAKER && config != AudioSystem::FORCE_BT_SCO &&
+            config != AudioSystem::FORCE_NONE) {
+            ALOGW("setForceUse() invalid config %d for FOR_COMMUNICATION", config);
+            return;
+        }
+        forceVolumeReeval = true;
+        mForceUse[usage] = config;
+        break;
+    case AudioSystem::FOR_MEDIA:
+        if (config != AudioSystem::FORCE_HEADPHONES && config != AudioSystem::FORCE_BT_A2DP &&
+            config != AudioSystem::FORCE_WIRED_ACCESSORY &&
+            config != AudioSystem::FORCE_ANALOG_DOCK &&
+            config != AudioSystem::FORCE_DIGITAL_DOCK && config != AudioSystem::FORCE_NONE &&
+            config != AudioSystem::FORCE_NO_BT_A2DP) {
+            ALOGW("setForceUse() invalid config %d for FOR_MEDIA", config);
+            return;
+        }
+        mForceUse[usage] = config;
+        break;
+    case AudioSystem::FOR_RECORD:
+        if (config != AudioSystem::FORCE_BT_SCO && config != AudioSystem::FORCE_WIRED_ACCESSORY &&
+            config != AudioSystem::FORCE_NONE) {
+            ALOGW("setForceUse() invalid config %d for FOR_RECORD", config);
+            return;
+        }
+        mForceUse[usage] = config;
+        break;
+    case AudioSystem::FOR_DOCK:
+        if (config != AudioSystem::FORCE_NONE && config != AudioSystem::FORCE_BT_CAR_DOCK &&
+            config != AudioSystem::FORCE_BT_DESK_DOCK &&
+            config != AudioSystem::FORCE_WIRED_ACCESSORY &&
+            config != AudioSystem::FORCE_ANALOG_DOCK &&
+            config != AudioSystem::FORCE_DIGITAL_DOCK) {
+            ALOGW("setForceUse() invalid config %d for FOR_DOCK", config);
+        }
+        forceVolumeReeval = true;
+        mForceUse[usage] = config;
+        break;
+    case AudioSystem::FOR_SYSTEM:
+        if (config != AudioSystem::FORCE_NONE &&
+            config != AudioSystem::FORCE_SYSTEM_ENFORCED) {
+            ALOGW("setForceUse() invalid config %d for FOR_SYSTEM", config);
+        }
+        forceVolumeReeval = true;
+        mForceUse[usage] = config;
+        break;
+    default:
+        ALOGW("setForceUse() invalid usage %d", usage);
+        break;
+    }
+
+    // check for device and output changes triggered by new force usage
+    checkA2dpSuspend();
+    checkOutputForAllStrategies();
+    updateDevicesAndOutputs();
+    for (size_t i = 0; i < mOutputs.size(); i++) {
+        audio_io_handle_t output = mOutputs.keyAt(i);
+        audio_devices_t newDevice = getNewDevice(output, true /*fromCache*/);
+        setOutputDevice(output, newDevice, (newDevice != AUDIO_DEVICE_NONE));
+        if (forceVolumeReeval && (newDevice != AUDIO_DEVICE_NONE)) {
+            applyStreamVolumes(output, newDevice, 0, true);
+        }
+    }
+
+    audio_io_handle_t activeInput = getActiveInput();
+    if (activeInput != 0) {
+        AudioInputDescriptor *inputDesc = mInputs.valueFor(activeInput);
+        audio_devices_t newDevice = getDeviceForInputSource(inputDesc->mInputSource);
+        if ((newDevice != AUDIO_DEVICE_NONE) && (newDevice != inputDesc->mDevice)) {
+            ALOGV("setForceUse() changing device from %x to %x for input %d",
+                    inputDesc->mDevice, newDevice, activeInput);
+            inputDesc->mDevice = newDevice;
+            AudioParameter param = AudioParameter();
+            param.addInt(String8(AudioParameter::keyRouting), (int)newDevice);
+            mpClientInterface->setParameters(activeInput, param.toString());
+        }
+    }
+
+}
+
+
+AudioPolicyManagerBase::IOProfile *AudioPolicyManager::getProfileForDirectOutput(
+                                                               audio_devices_t device,
+                                                               uint32_t samplingRate,
+                                                               uint32_t format,
+                                                               uint32_t channelMask,
+                                                               audio_output_flags_t flags)
+{
+
+
+    for (size_t i = 0; i < mHwModules.size(); i++) {
+        if (mHwModules[i]->mHandle == 0) {
+            continue;
+        }
+        for (size_t j = 0; j < mHwModules[i]->mOutputProfiles.size(); j++) {
+           AudioPolicyManagerBase::IOProfile *profile = mHwModules[i]->mOutputProfiles[j];
+            if (flags & AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) {
+                if (profile->isCompatibleProfile(device, samplingRate, format,
+                                           channelMask,
+                                           AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD)) {
+                    if (mAvailableOutputDevices & profile->mSupportedDevices) {
+                        return mHwModules[i]->mOutputProfiles[j];
+                    }
+                }
+            } else if (flags & AUDIO_OUTPUT_FLAG_DIRECT) {
+                if (profile->isCompatibleProfile(device, samplingRate, format,
+                                           channelMask,
+                                           AUDIO_OUTPUT_FLAG_DIRECT)) {
+                    if (mAvailableOutputDevices & profile->mSupportedDevices) {
+                        return mHwModules[i]->mOutputProfiles[j];
+                    }
+                }
+            }
+        }
+    }
+    return 0;
+}
+
+
+bool AudioPolicyManager::isCompatibleProfile(AudioPolicyManagerBase::IOProfile *profile,
+                                             audio_devices_t device,
+                                             uint32_t samplingRate,
+                                             uint32_t format,
+                                             uint32_t channelMask,
+                                            audio_output_flags_t flags)
+{
+    if ((profile->mSupportedDevices & device) != device) {
+        return false;
+    }
+    if (profile->mFlags != flags) {
+        return false;
+    }
+    if (samplingRate != 0) {
+        size_t i;
+        for (i = 0; i < profile->mSamplingRates.size(); i++)
+        {
+            if (profile->mSamplingRates[i] == samplingRate) {
+                break;
+            }
+        }
+        if (i == profile->mSamplingRates.size()) {
+            return false;
+        }
+    }
+    if (format != 0) {
+        size_t i;
+        for (i = 0; i < profile->mFormats.size(); i++)
+        {
+            if (profile->mFormats[i] == format) {
+                break;
+            }
+        }
+        if (i == profile->mFormats.size()) {
+            return false;
+        }
+    }
+    if (channelMask != 0) {
+        size_t i;
+       for (i = 0; i < profile->mChannelMasks.size(); i++)
+        {
+            if (profile->mChannelMasks[i] == channelMask) {
+                break;
+            }
+        }
+        if (i == profile->mChannelMasks.size()) {
+            return false;
+        }
+    }
+    ALOGD(" profile found: device %x, flags %x, samplingrate %d,\
+            format %x, channelMask %d",
+            device, flags, samplingRate, format, channelMask);
+    return true;
+}
+
+status_t AudioPolicyManager::checkOutputsForDevice(audio_devices_t device,
+                                                       AudioSystem::device_connection_state state,
+                                                       SortedVector<audio_io_handle_t>& outputs)
+{
+    AudioOutputDescriptor *desc;
+
+    if (state == AudioSystem::DEVICE_STATE_AVAILABLE) {
+        // first list already open outputs that can be routed to this device
+        for (size_t i = 0; i < mOutputs.size(); i++) {
+            desc = mOutputs.valueAt(i);
+            if (!desc->isDuplicated() && (desc->mProfile->mSupportedDevices & device)) {
+                ALOGV("checkOutputsForDevice(): adding opened output %d", mOutputs.keyAt(i));
+                outputs.add(mOutputs.keyAt(i));
+            }
+        }
+        // then look for output profiles that can be routed to this device
+        SortedVector<IOProfile *> profiles;
+        for (size_t i = 0; i < mHwModules.size(); i++)
+        {
+            if (mHwModules[i]->mHandle == 0) {
+                continue;
+            }
+            for (size_t j = 0; j < mHwModules[i]->mOutputProfiles.size(); j++)
+            {
+                if (mHwModules[i]->mOutputProfiles[j]->mSupportedDevices & device) {
+                    ALOGV("checkOutputsForDevice(): adding profile %d from module %d", j, i);
+                    profiles.add(mHwModules[i]->mOutputProfiles[j]);
+                }
+            }
+        }
+
+        if (profiles.isEmpty() && outputs.isEmpty()) {
+            ALOGW("checkOutputsForDevice(): No output available for device %04x", device);
+            return BAD_VALUE;
+        }
+
+        // open outputs for matching profiles if needed. Direct outputs are also opened to
+        // query for dynamic parameters and will be closed later by setDeviceConnectionState()
+        for (ssize_t profile_index = 0; profile_index < (ssize_t)profiles.size(); profile_index++) {
+            IOProfile *profile = profiles[profile_index];
+
+            // nothing to do if one output is already opened for this profile
+            size_t j;
+            for (j = 0; j < mOutputs.size(); j++) {
+                desc = mOutputs.valueAt(j);
+                if (!desc->isDuplicated() && desc->mProfile == profile) {
+                    break;
+                }
+            }
+            if (j != mOutputs.size()) {
+                continue;
+            }
+
+            ALOGV("opening output for device %08x", device);
+            desc = new AudioOutputDescriptor(profile);
+            desc->mDevice = device;
+            audio_io_handle_t output = 0;
+            if (!(desc->mFlags & AUDIO_OUTPUT_FLAG_LPA || desc->mFlags & AUDIO_OUTPUT_FLAG_TUNNEL ||
+                desc->mFlags & AUDIO_OUTPUT_FLAG_VOIP_RX)) {
+                output =  mpClientInterface->openOutput(profile->mModule->mHandle,
+                                                        &desc->mDevice,
+                                                        &desc->mSamplingRate,
+                                                        &desc->mFormat,
+                                                        &desc->mChannelMask,
+                                                        &desc->mLatency,
+                                                        desc->mFlags);
+            }
+            if (output != 0) {
+                if (desc->mFlags & AUDIO_OUTPUT_FLAG_DIRECT) {
+                    String8 reply;
+                    char *value;
+                    if (profile->mSamplingRates[0] == 0) {
+                        reply = mpClientInterface->getParameters(output,
+                                                String8(AUDIO_PARAMETER_STREAM_SUP_SAMPLING_RATES));
+                        ALOGV("checkOutputsForDevice() direct output sup sampling rates %s",
+                                  reply.string());
+                        value = strpbrk((char *)reply.string(), "=");
+                        if (value != NULL) {
+                            loadSamplingRates(value + 1, profile);
+                        }
+                    }
+                    if (profile->mFormats[0] == 0) {
+                        reply = mpClientInterface->getParameters(output,
+                                                       String8(AUDIO_PARAMETER_STREAM_SUP_FORMATS));
+                        ALOGV("checkOutputsForDevice() direct output sup formats %s",
+                                  reply.string());
+                        value = strpbrk((char *)reply.string(), "=");
+                        if (value != NULL) {
+                            loadFormats(value + 1, profile);
+                        }
+                    }
+                    if (profile->mChannelMasks[0] == 0) {
+                        reply = mpClientInterface->getParameters(output,
+                                                      String8(AUDIO_PARAMETER_STREAM_SUP_CHANNELS));
+                        ALOGV("checkOutputsForDevice() direct output sup channel masks %s",
+                                  reply.string());
+                        value = strpbrk((char *)reply.string(), "=");
+                        if (value != NULL) {
+                            loadOutChannels(value + 1, profile);
+                        }
+                    }
+                    if (((profile->mSamplingRates[0] == 0) &&
+                             (profile->mSamplingRates.size() < 2)) ||
+                         ((profile->mFormats[0] == 0) &&
+                             (profile->mFormats.size() < 2)) ||
+                         ((profile->mFormats[0] == 0) &&
+                             (profile->mChannelMasks.size() < 2))) {
+                        ALOGW("checkOutputsForDevice() direct output missing param");
+                        mpClientInterface->closeOutput(output);
+                        output = 0;
+                    } else {
+                        addOutput(output, desc);
+                    }
+                } else {
+                    audio_io_handle_t duplicatedOutput = 0;
+                    // add output descriptor
+                    addOutput(output, desc);
+                    // set initial stream volume for device
+                    applyStreamVolumes(output, device, 0, true);
+
+                    //TODO: configure audio effect output stage here
+
+                    // open a duplicating output thread for the new output and the primary output
+                    duplicatedOutput = mpClientInterface->openDuplicateOutput(output,
+                                                                              mPrimaryOutput);
+                    if (duplicatedOutput != 0) {
+                        // add duplicated output descriptor
+                        AudioOutputDescriptor *dupOutputDesc = new AudioOutputDescriptor(NULL);
+                        dupOutputDesc->mOutput1 = mOutputs.valueFor(mPrimaryOutput);
+                        dupOutputDesc->mOutput2 = mOutputs.valueFor(output);
+                        dupOutputDesc->mSamplingRate = desc->mSamplingRate;
+                        dupOutputDesc->mFormat = desc->mFormat;
+                        dupOutputDesc->mChannelMask = desc->mChannelMask;
+                        dupOutputDesc->mLatency = desc->mLatency;
+                        addOutput(duplicatedOutput, dupOutputDesc);
+                        applyStreamVolumes(duplicatedOutput, device, 0, true);
+                    } else {
+                        ALOGW("checkOutputsForDevice() could not open dup output for %d and %d",
+                                mPrimaryOutput, output);
+                        mpClientInterface->closeOutput(output);
+                        mOutputs.removeItem(output);
+                        output = 0;
+                    }
+                }
+            }
+            if (output == 0) {
+                ALOGW("checkOutputsForDevice() could not open output for device %x", device);
+                delete desc;
+                profiles.removeAt(profile_index);
+                profile_index--;
+            } else {
+                outputs.add(output);
+                ALOGV("checkOutputsForDevice(): adding output %d", output);
+            }
+        }
+
+        if (profiles.isEmpty()) {
+            ALOGW("checkOutputsForDevice(): No output available for device %04x", device);
+            return BAD_VALUE;
+        }
+    } else {
+        // check if one opened output is not needed any more after disconnecting one device
+        for (size_t i = 0; i < mOutputs.size(); i++) {
+            desc = mOutputs.valueAt(i);
+            if (!desc->isDuplicated() &&
+                    !(desc->mProfile->mSupportedDevices & mAvailableOutputDevices)) {
+                ALOGV("checkOutputsForDevice(): disconnecting adding output %d", mOutputs.keyAt(i));
+                outputs.add(mOutputs.keyAt(i));
+            }
+        }
+        for (size_t i = 0; i < mHwModules.size(); i++)
+        {
+            if (mHwModules[i]->mHandle == 0) {
+                continue;
+            }
+            for (size_t j = 0; j < mHwModules[i]->mOutputProfiles.size(); j++)
+            {
+                IOProfile *profile = mHwModules[i]->mOutputProfiles[j];
+                if ((profile->mSupportedDevices & device) &&
+                        (profile->mFlags & AUDIO_OUTPUT_FLAG_DIRECT)) {
+                    ALOGV("checkOutputsForDevice(): clearing direct output profile %d on module %d",
+                          j, i);
+                    if (profile->mSamplingRates[0] == 0) {
+                        profile->mSamplingRates.clear();
+                        profile->mSamplingRates.add(0);
+                    }
+                    if (profile->mFormats[0] == 0) {
+                        profile->mFormats.clear();
+                        profile->mFormats.add((audio_format_t)0);
+                    }
+                    if (profile->mChannelMasks[0] == 0) {
+                        profile->mChannelMasks.clear();
+                        profile->mChannelMasks.add((audio_channel_mask_t)0);
+                    }
+                }
+            }
+        }
+    }
+    return NO_ERROR;
+}
+
+audio_devices_t AudioPolicyManager::getDeviceForInputSource(int inputSource)
+{
+    uint32_t device = AUDIO_DEVICE_NONE;
+
+    switch(inputSource) {
+    case AUDIO_SOURCE_VOICE_UPLINK:
+      if (mAvailableInputDevices & AUDIO_DEVICE_IN_VOICE_CALL) {
+          device = AUDIO_DEVICE_IN_VOICE_CALL;
+          break;
+      }
+      // FALL THROUGH
+    case AUDIO_SOURCE_DEFAULT:
+    case AUDIO_SOURCE_MIC:
+    case AUDIO_SOURCE_VOICE_RECOGNITION:
+    case AUDIO_SOURCE_HOTWORD:
+    case AUDIO_SOURCE_VOICE_COMMUNICATION:
+        if (mForceUse[AudioSystem::FOR_RECORD] == AudioSystem::FORCE_BT_SCO &&
+            mAvailableInputDevices & AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET) {
+            device = AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET;
+        } else if (mAvailableInputDevices & AUDIO_DEVICE_IN_WIRED_HEADSET) {
+            device = AUDIO_DEVICE_IN_WIRED_HEADSET;
+        } else if (mAvailableInputDevices & AUDIO_DEVICE_IN_BUILTIN_MIC) {
+            device = AUDIO_DEVICE_IN_BUILTIN_MIC;
+        }
+        break;
+    case AUDIO_SOURCE_CAMCORDER:
+        if (mAvailableInputDevices & AUDIO_DEVICE_IN_BACK_MIC) {
+            device = AUDIO_DEVICE_IN_BACK_MIC;
+        } else if (mAvailableInputDevices & AUDIO_DEVICE_IN_BUILTIN_MIC) {
+            device = AUDIO_DEVICE_IN_BUILTIN_MIC;
+        }
+        break;
+    case AUDIO_SOURCE_VOICE_DOWNLINK:
+    case AUDIO_SOURCE_VOICE_CALL:
+        if (mAvailableInputDevices & AUDIO_DEVICE_IN_VOICE_CALL) {
+            device = AUDIO_DEVICE_IN_VOICE_CALL;
+        }
+        break;
+    case AUDIO_SOURCE_REMOTE_SUBMIX:
+        if (mAvailableInputDevices & AUDIO_DEVICE_IN_REMOTE_SUBMIX) {
+            device = AUDIO_DEVICE_IN_REMOTE_SUBMIX;
+        }
+        break;
+
+#ifdef QCOM_FM_ENABLED
+    case AUDIO_SOURCE_FM_RX:
+        device = AudioSystem::DEVICE_IN_FM_RX;
+        break;
+    case AUDIO_SOURCE_FM_RX_A2DP:
+        device = AudioSystem::DEVICE_IN_FM_RX_A2DP;
+        break;
+#endif
+    default:
+        ALOGW("getDeviceForInputSource() invalid input source %d", inputSource);
+        break;
+    }
+    ALOGV("getDeviceForInputSource()input source %d, device %08x", inputSource, device);
+    return device;
+}
+
+status_t AudioPolicyManager::startOutput(audio_io_handle_t output,
+                                             AudioSystem::stream_type stream,
+                                             int session)
+{
+    ALOGV("startOutput() output %d, stream %d, session %d", output, stream, session);
+    ssize_t index = mOutputs.indexOfKey(output);
+    if (index < 0) {
+        ALOGW("startOutput() unknow output %d", output);
+        return BAD_VALUE;
+    }
+
+    AudioOutputDescriptor *outputDesc = mOutputs.valueAt(index);
+
+    // increment usage count for this stream on the requested output:
+    // NOTE that the usage count is the same for duplicated output and hardware output which is
+    // necessary for a correct control of hardware output routing by startOutput() and stopOutput()
+    outputDesc->changeRefCount(stream, 1);
+
+    if (outputDesc->mRefCount[stream] == 1) {
+        audio_devices_t newDevice = AudioPolicyManagerBase::getNewDevice(output, false /*fromCache*/);
+        routing_strategy strategy = AudioPolicyManagerBase::getStrategy(stream);
+        bool shouldWait = (strategy == STRATEGY_SONIFICATION) ||
+                            (strategy == STRATEGY_SONIFICATION_RESPECTFUL);
+        uint32_t waitMs = 0;
+        bool force = false;
+        uint32_t muteWaitMs;
+        for (size_t i = 0; i < mOutputs.size(); i++) {
+            AudioOutputDescriptor *desc = mOutputs.valueAt(i);
+            if (desc != outputDesc) {
+                // force a device change if any other output is managed by the same hw
+                // module and has a current device selection that differs from selected device.
+                // In this case, the audio HAL must receive the new device selection so that it can
+                // change the device currently selected by the other active output.
+                if (outputDesc->sharesHwModuleWith(desc) &&
+                    desc->device() != newDevice) {
+                    force = true;
+                }
+                // wait for audio on other active outputs to be presented when starting
+                // a notification so that audio focus effect can propagate.
+                uint32_t latency = desc->latency();
+                if (shouldWait && desc->isActive(latency * 2) && (waitMs < latency)) {
+                    waitMs = latency;
+                }
+            }
+        }
+    uint32_t NewDevice = (uint32_t)AudioPolicyManagerBase::getNewDevice(output, true);
+#ifdef QCOM_FM_ENABLED
+    if((stream == AudioSystem::SYSTEM) && (FM_ANALOG == getFMMode())
+    && (NewDevice == AudioSystem::DEVICE_OUT_FM))
+    {
+        NewDevice |= AudioSystem::DEVICE_OUT_WIRED_HEADSET;
+        ALOGE("Selecting AnlgFM + CODEC device %x",NewDevice);
+        muteWaitMs = setOutputDevice(output, (audio_devices_t)NewDevice, true);
+    }
+    else
+#endif
+        muteWaitMs = setOutputDevice(output, (audio_devices_t)NewDevice, force);
+
+        // handle special case for sonification while in call
+        if (isInCall()) {
+            AudioPolicyManagerBase::handleIncallSonification(stream, true, false);
+        }
+
+        // apply volume rules for current stream and device if necessary
+        checkAndSetVolume(stream,
+                          mStreams[stream].getVolumeIndex(newDevice),
+                          output,
+                          newDevice);
+
+        // update the outputs if starting an output with a stream that can affect notification
+        // routing
+        handleNotificationRoutingForStream(stream);
+        if (waitMs > muteWaitMs) {
+            usleep((waitMs - muteWaitMs) * 2 * 1000);
+        }
+    }
+    return NO_ERROR;
+}
+
+status_t AudioPolicyManager::stopOutput(audio_io_handle_t output,
+                                            AudioSystem::stream_type stream,
+                                            int session)
+{
+    ALOGV("stopOutput() output %d, stream %d, session %d", output, stream, session);
+    ssize_t index = mOutputs.indexOfKey(output);
+    if (index < 0) {
+        ALOGW("stopOutput() unknow output %d", output);
+        return BAD_VALUE;
+    }
+
+    AudioOutputDescriptor *outputDesc = mOutputs.valueAt(index);
+
+    // handle special case for sonification while in call
+    if (isInCall()) {
+        handleIncallSonification(stream, false, false);
+    }
+
+    if (outputDesc->mRefCount[stream] > 0) {
+        // decrement usage count of this stream on the output
+        outputDesc->changeRefCount(stream, -1);
+        // store time at which the stream was stopped - see isStreamActive()
+        if (outputDesc->mRefCount[stream] == 0) {
+            outputDesc->mStopTime[stream] = systemTime();
+            audio_devices_t newDevice = getNewDevice(output, false /*fromCache*/);
+            // delay the device switch by twice the latency because stopOutput() is executed when
+            // the track stop() command is received and at that time the audio track buffer can
+            // still contain data that needs to be drained. The latency only covers the audio HAL
+            // and kernel buffers. Also the latency does not always include additional delay in the
+            // audio path (audio DSP, CODEC ...)
+         if(FM_ANALOG == getFMMode())
+            setOutputDevice(output, newDevice,true);
+        else
+            setOutputDevice(output, newDevice, false, outputDesc->mLatency*2);
+
+            // force restoring the device selection on other active outputs if it differs from the
+            // one being selected for this output
+            for (size_t i = 0; i < mOutputs.size(); i++) {
+                audio_io_handle_t curOutput = mOutputs.keyAt(i);
+                AudioOutputDescriptor *desc = mOutputs.valueAt(i);
+                if (curOutput != output &&
+                        desc->isActive() &&
+                        outputDesc->sharesHwModuleWith(desc) &&
+                        (newDevice != desc->device())) {
+                    setOutputDevice(curOutput,
+                                    getNewDevice(curOutput, false /*fromCache*/),
+                                    true,
+                                    outputDesc->mLatency*2);
+                }
+            }
+            // update the outputs if stopping one with a stream that can affect notification routing
+            handleNotificationRoutingForStream(stream);
+        }
+        return NO_ERROR;
+    } else {
+        ALOGW("stopOutput() refcount is already 0 for output %d", output);
+        return INVALID_OPERATION;
+    }
+}
+
+
+uint32_t AudioPolicyManager::setOutputDevice(audio_io_handle_t output, audio_devices_t device, bool force, int delayMs)
+{
+    ALOGV("setOutputDevice() output %d device %04x delayMs %d", output, device, delayMs);
+    uint32_t muteWaitMs;
+    AudioOutputDescriptor *outputDesc = mOutputs.valueFor(output);
+    AudioParameter param;
+
+    if (outputDesc->isDuplicated()) {
+        muteWaitMs = setOutputDevice(outputDesc->mOutput1->mId, device, force, delayMs);
+        muteWaitMs += setOutputDevice(outputDesc->mOutput2->mId, device, force, delayMs);
+        return muteWaitMs;
+    }
+    // no need to proceed if new device is not AUDIO_DEVICE_NONE and not supported by current
+    // output profile
+    if ((device != AUDIO_DEVICE_NONE) &&
+            ((device & outputDesc->mProfile->mSupportedDevices) == 0)) {
+        return 0;
+    }
+
+    // filter devices according to output selected
+    device = (audio_devices_t)(device & outputDesc->mProfile->mSupportedDevices);
+
+    audio_devices_t prevDevice = outputDesc->mDevice;
+
+    ALOGV("setOutputDevice() prevDevice %04x", prevDevice);
+
+    if (device != 0) {
+        outputDesc->mDevice = device;
+    }
+    muteWaitMs = checkDeviceMuteStrategies(outputDesc, prevDevice, delayMs);
+
+    // Do not change the routing if:
+    //  - the requested device is 0
+    //  - the requested device is the same as current device and force is not specified.
+    // Doing this check here allows the caller to call setOutputDevice() without conditions
+    if (device == 0) {
+        ALOGV("setOutputDevice() setting null device for output %d", output);
+        return muteWaitMs;
+    }
+
+    ALOGV("setOutputDevice() changing device");
+    // do the routing
+    param.addInt(String8(AudioParameter::keyRouting), (int)device);
+    mpClientInterface->setParameters(output, param.toString(), delayMs);
+
+    // update stream volumes according to new device
+    applyStreamVolumes(output, device, delayMs);
+
+    return muteWaitMs;
+}
+
+audio_devices_t AudioPolicyManager::getDeviceForVolume(audio_devices_t device)
+{
+    if (device == 0) {
+        // this happens when forcing a route update and no track is active on an output.
+        // In this case the returned category is not important.
+        device =  AUDIO_DEVICE_OUT_SPEAKER;
+    } else if (AudioSystem::popCount(device) > 1) {
+        // Multiple device selection is either:
+        //  - speaker + one other device: give priority to speaker in this case.
+        //  - one A2DP device + another device: happens with duplicated output. In this case
+        // retain the device on the A2DP output as the other must not correspond to an active
+        // selection if not the speaker.
+        if (device & AUDIO_DEVICE_OUT_SPEAKER) {
+            device = AUDIO_DEVICE_OUT_SPEAKER;
+        }
+#ifdef QCOM_FM_ENABLED
+        else if (device & AUDIO_DEVICE_OUT_FM) {
+            device = AUDIO_DEVICE_OUT_FM;
+        }
+#endif
+        else if((device & AUDIO_DEVICE_OUT_WIRED_HEADSET) != 0) {
+            device = AUDIO_DEVICE_OUT_WIRED_HEADSET;
+        }
+        else {
+            device = (audio_devices_t)(device & AUDIO_DEVICE_OUT_ALL_A2DP);
+        }
+    }
+
+    ALOGW_IF(AudioSystem::popCount(device) != 1,
+            "getDeviceForVolume() invalid device combination: %08x",
+            device);
+
+    return device;
+}
+
+status_t AudioPolicyManager::checkAndSetVolume(int stream, int index, audio_io_handle_t output, audio_devices_t device, int delayMs, bool force)
+{
+    // do not change actual stream volume if the stream is muted
+    if (mOutputs.valueFor(output)->mMuteCount[stream] != 0) {
+        ALOGVV("checkAndSetVolume() stream %d muted count %d",
+              stream, mOutputs.valueFor(output)->mMuteCount[stream]);
+        return NO_ERROR;
+    }
+
+    // do not change in call volume if bluetooth is connected and vice versa
+    if ((stream == AudioSystem::VOICE_CALL && mForceUse[AudioSystem::FOR_COMMUNICATION] == AudioSystem::FORCE_BT_SCO) ||
+        (stream == AudioSystem::BLUETOOTH_SCO && mForceUse[AudioSystem::FOR_COMMUNICATION] != AudioSystem::FORCE_BT_SCO)) {
+        ALOGV("checkAndSetVolume() cannot set stream %d volume with force use = %d for comm",
+             stream, mForceUse[AudioSystem::FOR_COMMUNICATION]);
+        return INVALID_OPERATION;
+    }
+
+    float volume = computeVolume(stream, index, output, device);
+    // We actually change the volume if:
+    // - the float value returned by computeVolume() changed
+    // - the force flag is set
+    if (volume != mOutputs.valueFor(output)->mCurVolume[stream] 
+#ifdef QCOM_FM_ENABLED
+            || (stream == AudioSystem::FM) 
+#endif
+            || force) {
+        mOutputs.valueFor(output)->mCurVolume[stream] = volume;
+        ALOGVV("checkAndSetVolume() for output %d stream %d, volume %f, delay %d", output, stream, volume, delayMs);
+        if (stream == AudioSystem::VOICE_CALL ||
+            stream == AudioSystem::DTMF ||
+            stream == AudioSystem::BLUETOOTH_SCO) {
+            // offset value to reflect actual hardware volume that never reaches 0
+            // 1% corresponds roughly to first step in VOICE_CALL stream volume setting (see AudioService.java)
+            volume = 0.01 + 0.99 * volume;
+            // Force VOICE_CALL to track BLUETOOTH_SCO stream volume when bluetooth audio is
+            // enabled
+            if (stream == AudioSystem::BLUETOOTH_SCO) {
+                mpClientInterface->setStreamVolume(AudioSystem::VOICE_CALL, volume, output, delayMs);
+            }
+        }
+
+        mpClientInterface->setStreamVolume((AudioSystem::stream_type)stream, volume, output, delayMs);
+    }
+
+    if (stream == AudioSystem::VOICE_CALL ||
+        stream == AudioSystem::BLUETOOTH_SCO) {
+        float voiceVolume;
+        // Force voice volume to max for bluetooth SCO as volume is managed by the headset
+        if (stream == AudioSystem::VOICE_CALL) {
+            voiceVolume = (float)index/(float)mStreams[stream].mIndexMax;
+        } else {
+            voiceVolume = 1.0;
+        }
+
+        if ((voiceVolume != mLastVoiceVolume && output == mPrimaryOutput) 
+#ifdef QCOM_FM_ENABLED
+	    && (!(mAvailableOutputDevices & AudioSystem::DEVICE_OUT_FM))
+#endif
+            ) {
+            mpClientInterface->setVoiceVolume(voiceVolume, delayMs);
+            mLastVoiceVolume = voiceVolume;
+        }
+#ifdef QCOM_FM_ENABLED
+    } else if ((stream == AudioSystem::FM) && (mAvailableOutputDevices & AudioSystem::DEVICE_OUT_FM)) {
+        float fmVolume = -1.0;
+        fmVolume = (float)index/(float)mStreams[stream].mIndexMax;
+        if (fmVolume >= 0 && output == mPrimaryOutput) {
+            mpClientInterface->setFmVolume(fmVolume, delayMs);
+            mLastVoiceVolume = fmVolume;
+        }
+#endif
+      }
+    return NO_ERROR;
+}
+
+void AudioPolicyManager::handleNotificationRoutingForStream(AudioSystem::stream_type stream) {
+    switch(stream) {
+    case AudioSystem::MUSIC:
+        checkOutputForStrategy(STRATEGY_SONIFICATION_RESPECTFUL);
+        updateDevicesAndOutputs();
+        break;
+    default:
+        break;
+    }
+}
+
+}; // namespace android
diff --git a/audio/AudioPolicyManager.h b/audio/AudioPolicyManager.h
new file mode 100644
index 0000000..32bb778
--- /dev/null
+++ b/audio/AudioPolicyManager.h
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (C) 2012, Code Aurora Forum. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#include <stdint.h>
+#include <sys/types.h>
+#include <cutils/config_utils.h>
+#include <cutils/misc.h>
+#include <utils/Timers.h>
+#include <utils/Errors.h>
+#include <utils/KeyedVector.h>
+#include <hardware_legacy/AudioPolicyManagerBase.h>
+
+
+namespace android_audio_legacy {
+
+enum fm_modes{
+   FM_DIGITAL=1,
+   FM_ANALOG,
+   FM_NONE
+};
+
+class AudioPolicyManager: public AudioPolicyManagerBase
+{
+
+public:
+                AudioPolicyManager(AudioPolicyClientInterface *clientInterface)
+                : AudioPolicyManagerBase(clientInterface),fmMode(FM_NONE){}
+
+        virtual ~AudioPolicyManager() {}
+
+        virtual audio_io_handle_t getOutput(AudioSystem::stream_type stream,
+                                            uint32_t samplingRate = 0,
+                                            uint32_t format = AudioSystem::FORMAT_DEFAULT,
+                                            uint32_t channels = 0,
+                                            AudioSystem::output_flags flags =
+                                                    AudioSystem::OUTPUT_FLAG_INDIRECT,
+                                            const audio_offload_info_t *offloadInfo = NULL);
+
+        virtual void releaseOutput(audio_io_handle_t output);
+
+        virtual status_t setDeviceConnectionState(audio_devices_t device,
+                                                           AudioSystem::device_connection_state state,
+                                                           const char *device_address);
+
+        virtual audio_devices_t getDeviceForVolume(audio_devices_t device);
+
+        virtual uint32_t  checkDeviceMuteStrategies(AudioOutputDescriptor *outputDesc,
+                                            audio_devices_t prevDevice,
+                                            uint32_t delayMs);
+        virtual void setForceUse(AudioSystem::force_use usage, AudioSystem::forced_config config);
+protected:
+        virtual audio_devices_t getDeviceForStrategy(routing_strategy strategy, bool fromCache = true);
+
+        fm_modes fmMode;
+
+#ifdef WITH_A2DP
+        // true is current platform supports suplication of notifications and ringtones over A2DP output
+        //virtual bool a2dpUsedForSonification() const { return true; }
+#endif
+        // when a device is connected, checks if an open output can be routed
+        // to this device. If none is open, tries to open one of the available outputs.
+        // Returns an output suitable to this device or 0.
+        // when a device is disconnected, checks if an output is not used any more and
+        // returns its handle if any.
+        // transfers the audio tracks and effects from one output thread to another accordingly.
+        status_t checkOutputsForDevice(audio_devices_t device,
+                                       AudioSystem::device_connection_state state,
+                                       SortedVector<audio_io_handle_t>& outputs);
+
+        virtual AudioPolicyManagerBase::IOProfile* getProfileForDirectOutput(
+                                                     audio_devices_t device,
+                                                     uint32_t samplingRate,
+                                                     uint32_t format,
+                                                     uint32_t channelMask,
+                                                     audio_output_flags_t flags);
+
+
+        bool    isCompatibleProfile(AudioPolicyManagerBase::IOProfile *profile,
+                                    audio_devices_t device,
+                                    uint32_t samplingRate,
+                                    uint32_t format,
+                                    uint32_t channelMask,
+                                    audio_output_flags_t flags);
+        // check that volume change is permitted, compute and send new volume to audio hardware
+        status_t checkAndSetVolume(int stream, int index, audio_io_handle_t output, audio_devices_t device, int delayMs = 0, bool force = false);
+        // select input device corresponding to requested audio source
+        virtual audio_devices_t getDeviceForInputSource(int inputSource);
+
+        virtual uint32_t setOutputDevice(audio_io_handle_t output,
+                        audio_devices_t device,
+                        bool force = false,
+                        int delayMs = 0);
+        virtual status_t startOutput(audio_io_handle_t output,
+                                AudioSystem::stream_type stream,
+                                int session = 0);
+        virtual status_t stopOutput(audio_io_handle_t output,
+                               AudioSystem::stream_type stream,
+                               int session = 0);
+        virtual void setFmMode(fm_modes mode) {  fmMode = mode; }
+        virtual fm_modes getFMMode() const {  return fmMode; }
+
+private:
+        // updates device caching and output for streams that can influence the
+        //    routing of notifications
+        void handleNotificationRoutingForStream(AudioSystem::stream_type stream);
+};
+};
diff --git a/audio/HardwarePinSwitching.c b/audio/HardwarePinSwitching.c
new file mode 100644
index 0000000..3966f1c
--- /dev/null
+++ b/audio/HardwarePinSwitching.c
@@ -0,0 +1,240 @@
+/*
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *            notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *            notice, this list of conditions and the following disclaimer in the
+ *            documentation and/or other materials provided with the distribution.
+ *        * Neither the name of Code Aurora nor
+ *            the names of its contributors may be used to endorse or promote
+ *            products derived from this software without specific prior written
+ *            permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <HardwarePinSwitching.h>
+#include <stdint.h>
+#include <sys/types.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <dlfcn.h>
+#include <fcntl.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+
+#define LOG_TAG "BTFMPinSwitching"
+#include <utils/Log.h>
+//#define DEBUG_CHK 1
+
+#define BT_PCM_BCLK_MODE  0x88
+#define BT_PCM_DIN_MODE   0x89
+#define BT_PCM_DOUT_MODE  0x8A
+#define BT_PCM_SYNC_MODE  0x8B
+#define FM_I2S_SD_MODE    0x8E
+#define FM_I2S_WS_MODE    0x8F
+#define FM_I2S_SCK_MODE   0x90
+#define I2C_PIN_CTL       0x15
+#define I2C_NORMAL        0x40
+
+
+#define MARIMBA_ADDR                  (0x0C)
+#define ARRAY_SIZE(a)   (sizeof(a) / sizeof(*a))
+
+#define LINE_LEN 80
+#define FM_DEVICE_PATH "/dev/i2c-1"
+
+
+/*==============================================================
+FUNCTION:  do_rdwr
+==============================================================*/
+
+static int do_rdwr(int fd, struct i2c_msg *msgs, int nmsgs) {
+   struct i2c_rdwr_ioctl_data msgset;
+      msgset.msgs = msgs;
+      msgset.nmsgs = nmsgs;
+
+   if (NULL == msgs || nmsgs <= 0) {
+      return -1;
+   }
+
+   if (ioctl(fd, I2C_RDWR, &msgset) < 0) {
+      return -1;
+   }
+
+   return 0;
+}
+/*==============================================================
+FUNCTION:  marimba_read
+=============================================================*/
+static int marimba_read(int fd, unsigned char offset, unsigned char* buf, int count)
+{
+
+        unsigned char offset_data[] =  {offset};
+        struct i2c_msg msgs[2];
+        msgs[0].addr = MARIMBA_ADDR;
+        msgs[0].flags = 0;
+        msgs[0].buf = (__u8*)offset_data;
+        msgs[0].len = ARRAY_SIZE(offset_data);
+        msgs[1].addr = MARIMBA_ADDR;
+        msgs[1].flags = I2C_M_RD;
+        msgs[1].buf = (__u8*)buf;
+        msgs[1].len = count;
+
+        return do_rdwr(fd, msgs, ARRAY_SIZE(msgs));
+}
+/*==============================================================
+FUNCTION:  marimba_write
+==============================================================*/
+/**
+* This function provides bus interface to write to the Marimba chip
+*
+* @return  int - negative number on failure.
+*
+*/
+static int marimba_write
+(
+        int fd,
+        unsigned char offset,
+        const unsigned char* buf,
+        unsigned char len
+)
+{
+        unsigned char offset_data[((1 + len) * sizeof(unsigned char))];
+        struct i2c_msg msgs[1];
+              msgs[0].addr = MARIMBA_ADDR;
+              msgs[0].flags = 0;
+              msgs[0].buf = (__u8*)offset_data;
+              msgs[0].len = (1 + len) * sizeof(*offset_data);
+
+        if (NULL == offset_data) {
+                return -1;
+        }
+
+        offset_data[0] = offset;
+        memcpy(offset_data + 1, buf, len);
+
+        return do_rdwr(fd, msgs, ARRAY_SIZE(msgs));
+}
+
+/*==============================================================
+FUNCTION:  switch_pins
+==============================================================*/
+/**
+* This function provides interface to change the mode of operation
+* from I2S mode  to AUX PCM or vice versa. This function programs the
+* wcn2243 registers to TRISTATE or ON mode.
+*
+* @return  int - negative number on failure.
+*
+*/
+static int switch_pins( int fd, int nPath )
+{
+    unsigned char value =0;
+    unsigned char reg =0;
+    int retval = -1;
+    unsigned char set = I2C_PIN_CTL; // SET PIN CTL mode
+    unsigned char unset = I2C_NORMAL; // UNSET PIN CTL MODE
+    if(nPath == MODE_FM ) {
+        // as we need to switch path to FM we need to move
+        // BT AUX PCM lines to PIN CONTROL mode then move
+        // FM to normal mode.
+        for( reg = BT_PCM_BCLK_MODE; reg <= BT_PCM_SYNC_MODE; reg++ ) {
+#ifdef DEBUG_CHK
+            retval = marimba_read(fd, reg,&value, 1);
+            ALOGD("value read is:%d\n",value);
+#endif
+            retval = marimba_write(fd, reg, &set,1);
+            if (retval < 0) {
+                goto err_all;
+            }
+        }
+        for( reg = FM_I2S_SD_MODE; reg <= FM_I2S_SCK_MODE; reg++ ) {
+#ifdef DEBUG_CHK
+            retval = marimba_read(fd, reg,&value, 1);
+            ALOGD("value read is:%d\n",value);
+#endif
+            retval = marimba_write(fd, reg, &unset,1);
+            if (retval < 0) {
+               goto err_all;
+            }
+        }
+    } else {
+        // as we need to switch path to AUXPCM we need to move
+        // FM I2S lines to PIN CONTROL mode then move
+        // BT AUX_PCM to normal mode.
+        for( reg = FM_I2S_SD_MODE; reg <= FM_I2S_SCK_MODE; reg++ ) {
+#ifdef DEBUG_CHK
+            retval = marimba_read(fd, reg,&value, 1);
+            ALOGD("value read is:%d\n",value);
+#endif
+            retval = marimba_write(fd, reg, &set,1);
+            if (retval < 0) {
+               goto err_all;
+            }
+        }
+        for( reg = BT_PCM_BCLK_MODE; reg <= BT_PCM_SYNC_MODE; reg++ ) {
+#ifdef DEBUG_CHK
+            retval = marimba_read(fd, reg,&value, 1);
+            ALOGD("value read is:%d\n",value);
+#endif
+            retval = marimba_write(fd, reg, &unset,1);
+            if (retval < 0) {
+                goto err_all;
+            }
+        }
+    }
+    ALOGD("switch pin called with : %d\n",nPath);
+    return 0;
+
+err_all:
+        return retval;
+}
+
+/*==============================================================
+FUNCTION:  switch_mode
+==============================================================*/
+/**
+* This function provides interface to change the mode of operation
+* from I2S mode to AUX PCM or vice versa. This function programs the
+* wcn2243 registers to TRISTATE or ON mode.
+*
+* @return  int - negative number on failure.
+*
+*/
+extern int switch_mode( int nMode ) {
+    int i2cfd = -1, rc= -1 ;
+#ifdef REG_KERNEL_UPDATE
+    //media server doesnt have permissions to update
+    return 0;
+#endif
+#ifdef WITH_QCOM_FM
+    i2cfd = open(FM_DEVICE_PATH, O_RDWR);
+    if( i2cfd >= 0) {
+        rc = switch_pins(i2cfd, nMode);
+        close(i2cfd);
+    }
+    if( 0 != rc ) {
+        ALOGE("switch mode failed with error:%d",rc);
+    }
+#else
+    ALOGE("switch mode failed because QCOM_FM feature is not available");
+#endif
+    return rc;
+}
diff --git a/audio/HardwarePinSwitching.h b/audio/HardwarePinSwitching.h
new file mode 100644
index 0000000..0522dc3
--- /dev/null
+++ b/audio/HardwarePinSwitching.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *            notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *            notice, this list of conditions and the following disclaimer in the
+ *            documentation and/or other materials provided with the distribution.
+ *        * Neither the name of Code Aurora nor
+ *            the names of its contributors may be used to endorse or promote
+ *            products derived from this software without specific prior written
+ *            permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef ANDROID_HARDWARE_PIN_SWITCHING_H
+#define ANDROID_HARDWARE_PIN_SWITCHING_H
+
+
+
+#define MODE_FM    0
+#define MODE_BTSCO 1
+
+
+int switch_mode( int nMode );
+
+
+
+#endif // ANDROID_HARDWARE_PIN_SWITCHING_H
diff --git a/audio/audio_hw_hal.cpp b/audio/audio_hw_hal.cpp
new file mode 100644
index 0000000..de72305
--- /dev/null
+++ b/audio/audio_hw_hal.cpp
@@ -0,0 +1,766 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ * Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "audio.primary.msm7627a"
+//#define LOG_NDEBUG 0
+
+#include <stdint.h>
+
+#include <hardware/hardware.h>
+#include <system/audio.h>
+#include <hardware/audio.h>
+
+#include <hardware_legacy/AudioHardwareInterface.h>
+#include <hardware_legacy/AudioSystemLegacy.h>
+
+namespace android_audio_legacy {
+
+extern "C" {
+
+struct qcom_audio_module {
+    struct audio_module module;
+};
+
+struct qcom_audio_device {
+    struct audio_hw_device device;
+
+    struct AudioHardwareInterface *hwif;
+};
+
+struct qcom_stream_out {
+    struct audio_stream_out stream;
+
+    AudioStreamOut *qcom_out;
+};
+
+struct qcom_stream_in {
+    struct audio_stream_in stream;
+
+    AudioStreamIn *qcom_in;
+};
+
+enum {
+    HAL_API_REV_1_0,
+    HAL_API_REV_2_0,
+    HAL_API_REV_NUM
+} hal_api_rev;
+static uint32_t audio_device_conv_table[][HAL_API_REV_NUM] =
+{
+    /* output devices */
+    { AudioSystem::DEVICE_OUT_EARPIECE, AUDIO_DEVICE_OUT_EARPIECE },
+    { AudioSystem::DEVICE_OUT_SPEAKER, AUDIO_DEVICE_OUT_SPEAKER },
+    { AudioSystem::DEVICE_OUT_WIRED_HEADSET, AUDIO_DEVICE_OUT_WIRED_HEADSET },
+    { AudioSystem::DEVICE_OUT_WIRED_HEADPHONE, AUDIO_DEVICE_OUT_WIRED_HEADPHONE },
+    { AudioSystem::DEVICE_OUT_BLUETOOTH_SCO, AUDIO_DEVICE_OUT_BLUETOOTH_SCO },
+    { AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_HEADSET, AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET },
+    { AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_CARKIT, AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT },
+    { AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP, AUDIO_DEVICE_OUT_BLUETOOTH_A2DP },
+    { AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES, AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES },
+    { AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER, AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER },
+    { AudioSystem::DEVICE_OUT_AUX_DIGITAL, AUDIO_DEVICE_OUT_AUX_DIGITAL },
+    { AudioSystem::DEVICE_OUT_ANLG_DOCK_HEADSET, AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET },
+    { AudioSystem::DEVICE_OUT_DGTL_DOCK_HEADSET, AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET },
+    { AudioSystem::DEVICE_OUT_DEFAULT, AUDIO_DEVICE_OUT_DEFAULT },
+    /* input devices */
+    { AudioSystem::DEVICE_IN_COMMUNICATION, AUDIO_DEVICE_IN_COMMUNICATION },
+    { AudioSystem::DEVICE_IN_AMBIENT, AUDIO_DEVICE_IN_AMBIENT },
+    { AudioSystem::DEVICE_IN_BUILTIN_MIC, AUDIO_DEVICE_IN_BUILTIN_MIC },
+    { AudioSystem::DEVICE_IN_BLUETOOTH_SCO_HEADSET, AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET },
+    { AudioSystem::DEVICE_IN_WIRED_HEADSET, AUDIO_DEVICE_IN_WIRED_HEADSET },
+    { AudioSystem::DEVICE_IN_AUX_DIGITAL, AUDIO_DEVICE_IN_AUX_DIGITAL },
+    { AudioSystem::DEVICE_IN_VOICE_CALL, AUDIO_DEVICE_IN_VOICE_CALL },
+    { AudioSystem::DEVICE_IN_BACK_MIC, AUDIO_DEVICE_IN_BACK_MIC },
+    { AudioSystem::DEVICE_IN_DEFAULT, AUDIO_DEVICE_IN_DEFAULT },
+};
+
+static uint32_t convert_audio_device(uint32_t from_device, int from_rev, int to_rev)
+{
+    const uint32_t k_num_devices = sizeof(audio_device_conv_table)/sizeof(uint32_t)/HAL_API_REV_NUM;
+    uint32_t to_device = AUDIO_DEVICE_NONE;
+    uint32_t in_bit = 0;
+
+    if (from_rev != HAL_API_REV_1_0) {
+        in_bit = from_device & AUDIO_DEVICE_BIT_IN;
+        from_device &= ~AUDIO_DEVICE_BIT_IN;
+    }
+
+    while (from_device) {
+        uint32_t i = 31 - __builtin_clz(from_device);
+        uint32_t cur_device = (1 << i) | in_bit;
+
+        for (i = 0; i < k_num_devices; i++) {
+            if (audio_device_conv_table[i][from_rev] == cur_device) {
+                to_device |= audio_device_conv_table[i][to_rev];
+                break;
+            }
+        }
+        from_device &= ~cur_device;
+    }
+    return to_device;
+}
+
+/** audio_stream_out implementation **/
+static uint32_t out_get_sample_rate(const struct audio_stream *stream)
+{
+    const struct qcom_stream_out *out =
+        reinterpret_cast<const struct qcom_stream_out *>(stream);
+    return out->qcom_out->sampleRate();
+}
+
+static int out_set_sample_rate(struct audio_stream *stream, uint32_t rate)
+{
+    struct qcom_stream_out *out =
+        reinterpret_cast<struct qcom_stream_out *>(stream);
+
+    ALOGE("(%s:%d) %s: Implement me!", __FILE__, __LINE__, __func__);
+    /* TODO: implement this */
+    return 0;
+}
+
+static size_t out_get_buffer_size(const struct audio_stream *stream)
+{
+    const struct qcom_stream_out *out =
+        reinterpret_cast<const struct qcom_stream_out *>(stream);
+    return out->qcom_out->bufferSize();
+}
+
+static audio_channel_mask_t out_get_channels(const struct audio_stream *stream)
+{
+    const struct qcom_stream_out *out =
+        reinterpret_cast<const struct qcom_stream_out *>(stream);
+    return (audio_channel_mask_t) out->qcom_out->channels();
+}
+
+static audio_format_t out_get_format(const struct audio_stream *stream)
+{
+    const struct qcom_stream_out *out =
+        reinterpret_cast<const struct qcom_stream_out *>(stream);
+    return (audio_format_t)out->qcom_out->format();
+}
+
+static int out_set_format(struct audio_stream *stream, audio_format_t format)
+{
+    struct qcom_stream_out *out =
+        reinterpret_cast<struct qcom_stream_out *>(stream);
+    ALOGE("(%s:%d) %s: Implement me!", __FILE__, __LINE__, __func__);
+    /* TODO: implement me */
+    return 0;
+}
+
+static int out_standby(struct audio_stream *stream)
+{
+    struct qcom_stream_out *out =
+        reinterpret_cast<struct qcom_stream_out *>(stream);
+    return out->qcom_out->standby();
+}
+
+static int out_dump(const struct audio_stream *stream, int fd)
+{
+    const struct qcom_stream_out *out =
+        reinterpret_cast<const struct qcom_stream_out *>(stream);
+    Vector<String16> args;
+    return out->qcom_out->dump(fd, args);
+}
+
+static int out_set_parameters(struct audio_stream *stream, const char *kvpairs)
+{
+    struct qcom_stream_out *out =
+        reinterpret_cast<struct qcom_stream_out *>(stream);
+    int val;
+    String8 s8 = String8(kvpairs);
+    AudioParameter parms = AudioParameter(String8(kvpairs));
+
+    if (parms.getInt(String8(AUDIO_PARAMETER_STREAM_ROUTING), val) == NO_ERROR) {
+        val = convert_audio_device(val, HAL_API_REV_2_0, HAL_API_REV_1_0);
+        parms.remove(String8(AUDIO_PARAMETER_STREAM_ROUTING));
+        parms.addInt(String8(AUDIO_PARAMETER_STREAM_ROUTING), val);
+        s8 = parms.toString();
+    }
+    return out->qcom_out->setParameters(s8);
+}
+
+static char * out_get_parameters(const struct audio_stream *stream, const char *keys)
+{
+    const struct qcom_stream_out *out =
+        reinterpret_cast<const struct qcom_stream_out *>(stream);
+    String8 s8;
+    int val;
+    s8 = out->qcom_out->getParameters(String8(keys));
+    AudioParameter parms = AudioParameter(s8);
+    if (parms.getInt(String8(AUDIO_PARAMETER_STREAM_ROUTING), val) == NO_ERROR) {
+        val = convert_audio_device(val, HAL_API_REV_1_0, HAL_API_REV_2_0);
+        parms.remove(String8(AUDIO_PARAMETER_STREAM_ROUTING));
+        parms.addInt(String8(AUDIO_PARAMETER_STREAM_ROUTING), val);
+        s8 = parms.toString();
+    }
+    return strdup(s8.string());
+}
+
+static uint32_t out_get_latency(const struct audio_stream_out *stream)
+{
+    const struct qcom_stream_out *out =
+        reinterpret_cast<const struct qcom_stream_out *>(stream);
+    return out->qcom_out->latency();
+}
+
+static int out_set_volume(struct audio_stream_out *stream, float left,
+                          float right)
+{
+    struct qcom_stream_out *out =
+        reinterpret_cast<struct qcom_stream_out *>(stream);
+    return out->qcom_out->setVolume(left, right);
+}
+
+static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
+                         size_t bytes)
+{
+    struct qcom_stream_out *out =
+        reinterpret_cast<struct qcom_stream_out *>(stream);
+    return out->qcom_out->write(buffer, bytes);
+}
+
+static int out_get_render_position(const struct audio_stream_out *stream,
+                                   uint32_t *dsp_frames)
+{
+    const struct qcom_stream_out *out =
+        reinterpret_cast<const struct qcom_stream_out *>(stream);
+    return out->qcom_out->getRenderPosition(dsp_frames);
+}
+
+static int out_set_observer(const struct audio_stream_out *stream,
+                                   void *observer)
+{
+    const struct qcom_stream_out *out =
+        reinterpret_cast<const struct qcom_stream_out *>(stream);
+    return out->qcom_out->setObserver(observer);
+}
+
+static int out_get_buffer_info(const struct audio_stream_out *stream,
+                                   buf_info ** buf)
+{
+    const struct qcom_stream_out *out =
+        reinterpret_cast<const struct qcom_stream_out *>(stream);
+    return out->qcom_out->getBufferInfo(buf);
+}
+
+static int out_is_buffer_available(const struct audio_stream_out *stream,
+                                   int *isAvail)
+{
+    const struct qcom_stream_out *out =
+        reinterpret_cast<const struct qcom_stream_out *>(stream);
+    return out->qcom_out->isBufferAvailable(isAvail);
+}
+
+static status_t out_start(struct audio_stream_out *stream)
+{
+    struct qcom_stream_out *out =
+        reinterpret_cast<struct qcom_stream_out *>(stream);
+    return out->qcom_out->start();
+}
+
+static status_t out_pause(struct audio_stream_out *stream)
+{
+    struct qcom_stream_out *out =
+        reinterpret_cast<struct qcom_stream_out *>(stream);
+    return out->qcom_out->pause();
+}
+
+static status_t out_flush(struct audio_stream_out *stream)
+{
+    struct qcom_stream_out *out =
+        reinterpret_cast<struct qcom_stream_out *>(stream);
+    return out->qcom_out->flush();
+}
+
+static status_t out_stop(struct audio_stream_out *stream)
+{
+    struct qcom_stream_out *out =
+        reinterpret_cast<struct qcom_stream_out *>(stream);
+    return out->qcom_out->stop();
+}
+
+static int out_add_audio_effect(const struct audio_stream *stream, effect_handle_t effect)
+{
+    return 0;
+}
+
+static int out_remove_audio_effect(const struct audio_stream *stream, effect_handle_t effect)
+{
+    return 0;
+}
+
+static int out_get_next_write_timestamp(const struct audio_stream_out *stream,
+                                        int64_t *timestamp)
+{
+    const struct qcom_stream_out *out =
+        reinterpret_cast<const struct qcom_stream_out *>(stream);
+    return out->qcom_out->getNextWriteTimestamp(timestamp);
+}
+
+/** audio_stream_in implementation **/
+static uint32_t in_get_sample_rate(const struct audio_stream *stream)
+{
+    const struct qcom_stream_in *in =
+        reinterpret_cast<const struct qcom_stream_in *>(stream);
+    return in->qcom_in->sampleRate();
+}
+
+static int in_set_sample_rate(struct audio_stream *stream, uint32_t rate)
+{
+    struct qcom_stream_in *in =
+        reinterpret_cast<struct qcom_stream_in *>(stream);
+
+    ALOGE("(%s:%d) %s: Implement me!", __FILE__, __LINE__, __func__);
+    /* TODO: implement this */
+    return 0;
+}
+
+static size_t in_get_buffer_size(const struct audio_stream *stream)
+{
+    const struct qcom_stream_in *in =
+        reinterpret_cast<const struct qcom_stream_in *>(stream);
+    return in->qcom_in->bufferSize();
+}
+
+static audio_channel_mask_t in_get_channels(const struct audio_stream *stream)
+{
+    const struct qcom_stream_in *in =
+        reinterpret_cast<const struct qcom_stream_in *>(stream);
+    return (audio_channel_mask_t) in->qcom_in->channels();
+}
+
+static audio_format_t in_get_format(const struct audio_stream *stream)
+{
+    const struct qcom_stream_in *in =
+        reinterpret_cast<const struct qcom_stream_in *>(stream);
+    return (audio_format_t)in->qcom_in->format();
+}
+
+static int in_set_format(struct audio_stream *stream, audio_format_t format)
+{
+    struct qcom_stream_in *in =
+        reinterpret_cast<struct qcom_stream_in *>(stream);
+    ALOGE("(%s:%d) %s: Implement me!", __FILE__, __LINE__, __func__);
+    /* TODO: implement me */
+    return 0;
+}
+
+static int in_standby(struct audio_stream *stream)
+{
+    struct qcom_stream_in *in = reinterpret_cast<struct qcom_stream_in *>(stream);
+    return in->qcom_in->standby();
+}
+
+static int in_dump(const struct audio_stream *stream, int fd)
+{
+    const struct qcom_stream_in *in =
+        reinterpret_cast<const struct qcom_stream_in *>(stream);
+    Vector<String16> args;
+    return in->qcom_in->dump(fd, args);
+}
+
+static int in_set_parameters(struct audio_stream *stream, const char *kvpairs)
+{
+    struct qcom_stream_in *in =
+        reinterpret_cast<struct qcom_stream_in *>(stream);
+    int val;
+    AudioParameter parms = AudioParameter(String8(kvpairs));
+    String8 s8 = String8(kvpairs);
+
+    if (parms.getInt(String8(AUDIO_PARAMETER_STREAM_ROUTING), val) == NO_ERROR) {
+        val = convert_audio_device(val, HAL_API_REV_2_0, HAL_API_REV_1_0);
+        parms.remove(String8(AUDIO_PARAMETER_STREAM_ROUTING));
+        parms.addInt(String8(AUDIO_PARAMETER_STREAM_ROUTING), val);
+        s8 = parms.toString();
+    }
+    return in->qcom_in->setParameters(s8);
+}
+
+static char * in_get_parameters(const struct audio_stream *stream,
+                                const char *keys)
+{
+    const struct qcom_stream_in *in =
+        reinterpret_cast<const struct qcom_stream_in *>(stream);
+    String8 s8;
+    int val;
+    s8 = in->qcom_in->getParameters(String8(keys));
+    AudioParameter parms = AudioParameter(s8);
+    if (parms.getInt(String8(AUDIO_PARAMETER_STREAM_ROUTING), val) == NO_ERROR) {
+        val = convert_audio_device(val, HAL_API_REV_1_0, HAL_API_REV_2_0);
+        parms.remove(String8(AUDIO_PARAMETER_STREAM_ROUTING));
+        parms.addInt(String8(AUDIO_PARAMETER_STREAM_ROUTING), val);
+        s8 = parms.toString();
+    }
+    return strdup(s8.string());
+}
+
+static int in_set_gain(struct audio_stream_in *stream, float gain)
+{
+    struct qcom_stream_in *in =
+        reinterpret_cast<struct qcom_stream_in *>(stream);
+    return in->qcom_in->setGain(gain);
+}
+
+static ssize_t in_read(struct audio_stream_in *stream, void* buffer,
+                       size_t bytes)
+{
+    struct qcom_stream_in *in =
+        reinterpret_cast<struct qcom_stream_in *>(stream);
+    return in->qcom_in->read(buffer, bytes);
+}
+
+static uint32_t in_get_input_frames_lost(struct audio_stream_in *stream)
+{
+    struct qcom_stream_in *in =
+        reinterpret_cast<struct qcom_stream_in *>(stream);
+    return in->qcom_in->getInputFramesLost();
+}
+
+static int in_add_audio_effect(const struct audio_stream *stream, effect_handle_t effect)
+{
+    const struct qcom_stream_in *in =
+        reinterpret_cast<const struct qcom_stream_in *>(stream);
+    return in->qcom_in->addAudioEffect(effect);
+}
+
+static int in_remove_audio_effect(const struct audio_stream *stream, effect_handle_t effect)
+{
+    const struct qcom_stream_in *in =
+        reinterpret_cast<const struct qcom_stream_in *>(stream);
+    return in->qcom_in->removeAudioEffect(effect);
+}
+
+/** audio_hw_device implementation **/
+static inline struct qcom_audio_device * to_ladev(struct audio_hw_device *dev)
+{
+    return reinterpret_cast<struct qcom_audio_device *>(dev);
+}
+
+static inline const struct qcom_audio_device * to_cladev(const struct audio_hw_device *dev)
+{
+    return reinterpret_cast<const struct qcom_audio_device *>(dev);
+}
+
+static int adev_init_check(const struct audio_hw_device *dev)
+{
+    const struct qcom_audio_device *qadev = to_cladev(dev);
+
+    return qadev->hwif->initCheck();
+}
+
+static int adev_set_voice_volume(struct audio_hw_device *dev, float volume)
+{
+    struct qcom_audio_device *qadev = to_ladev(dev);
+    return qadev->hwif->setVoiceVolume(volume);
+}
+
+static int adev_set_master_volume(struct audio_hw_device *dev, float volume)
+{
+    struct qcom_audio_device *qadev = to_ladev(dev);
+    return qadev->hwif->setMasterVolume(volume);
+}
+
+static int adev_get_master_volume(struct audio_hw_device *dev, float *volume) {
+
+    struct qcom_audio_device *qadev = to_ladev(dev);
+    return qadev->hwif->getMasterVolume(volume);
+}
+#ifdef QCOM_FM_ENABLED
+static int adev_set_fm_volume(struct audio_hw_device *dev, float volume)
+{
+    struct qcom_audio_device *qadev = to_ladev(dev);
+    return qadev->hwif->setFmVolume(volume);
+}
+#endif
+
+static int adev_set_mode(struct audio_hw_device *dev, audio_mode_t mode)
+{
+    struct qcom_audio_device *qadev = to_ladev(dev);
+    return qadev->hwif->setMode((int)mode);
+}
+
+static int adev_set_mic_mute(struct audio_hw_device *dev, bool state)
+{
+    struct qcom_audio_device *qadev = to_ladev(dev);
+    return qadev->hwif->setMicMute(state);
+}
+
+static int adev_get_mic_mute(const struct audio_hw_device *dev, bool *state)
+{
+    const struct qcom_audio_device *qadev = to_cladev(dev);
+    return qadev->hwif->getMicMute(state);
+}
+
+static int adev_set_parameters(struct audio_hw_device *dev, const char *kvpairs)
+{
+    struct qcom_audio_device *qadev = to_ladev(dev);
+    return qadev->hwif->setParameters(String8(kvpairs));
+}
+
+static char * adev_get_parameters(const struct audio_hw_device *dev,
+                                  const char *keys)
+{
+    const struct qcom_audio_device *qadev = to_cladev(dev);
+    String8 s8;
+
+    s8 = qadev->hwif->getParameters(String8(keys));
+    return strdup(s8.string());
+}
+
+static size_t adev_get_input_buffer_size(const struct audio_hw_device *dev,
+                                         const struct audio_config *config)
+{
+    const struct qcom_audio_device *qadev = to_cladev(dev);
+    uint8_t channelCount = popcount(config->channel_mask);
+    return qadev->hwif->getInputBufferSize(config->sample_rate,config->format,channelCount);
+}
+
+
+static int adev_open_output_stream(struct audio_hw_device *dev,
+                                   audio_io_handle_t handle,
+                                   audio_devices_t devices,
+                                   audio_output_flags_t flags,
+                                   struct audio_config *config,
+                                   struct audio_stream_out **stream_out)
+{
+    struct qcom_audio_device *qadev = to_ladev(dev);
+    status_t status;
+    struct qcom_stream_out *out;
+    int ret;
+
+    out = (struct qcom_stream_out *)calloc(1, sizeof(*out));
+    if (!out)
+        return -ENOMEM;
+
+    devices = convert_audio_device(devices, HAL_API_REV_2_0, HAL_API_REV_1_0);
+    status = static_cast<audio_output_flags_t> (flags);
+
+    out->qcom_out = qadev->hwif->openOutputStream(devices, (int *) &config->format,
+                                                    &config->channel_mask,
+                                                    &config->sample_rate,
+                                                    &status);
+    if (!out->qcom_out) {
+        ret = status;
+        goto err_open;
+    }
+
+    out->stream.common.get_sample_rate = out_get_sample_rate;
+    out->stream.common.set_sample_rate = out_set_sample_rate;
+    out->stream.common.get_buffer_size = out_get_buffer_size;
+    out->stream.common.get_channels = out_get_channels;
+    out->stream.common.get_format = out_get_format;
+    out->stream.common.set_format = out_set_format;
+    out->stream.common.standby = out_standby;
+    out->stream.common.dump = out_dump;
+    out->stream.common.set_parameters = out_set_parameters;
+    out->stream.common.get_parameters = out_get_parameters;
+    out->stream.common.add_audio_effect = out_add_audio_effect;
+    out->stream.common.remove_audio_effect = out_remove_audio_effect;
+    out->stream.get_latency = out_get_latency;
+    out->stream.set_volume = out_set_volume;
+    out->stream.write = out_write;
+    out->stream.get_render_position = out_get_render_position;
+    out->stream.get_next_write_timestamp = out_get_next_write_timestamp;
+    out->stream.start = out_start;
+    out->stream.pause = out_pause;
+    out->stream.flush = out_flush;
+    out->stream.stop = out_stop;
+    out->stream.set_observer = out_set_observer;
+    out->stream.get_buffer_info = out_get_buffer_info;
+    out->stream.is_buffer_available = out_is_buffer_available;
+
+    *stream_out = &out->stream;
+    return 0;
+
+err_open:
+    free(out);
+    *stream_out = NULL;
+    return ret;
+}
+
+static void adev_close_output_stream(struct audio_hw_device *dev,
+                                     struct audio_stream_out* stream)
+{
+    struct qcom_audio_device *qadev = to_ladev(dev);
+    struct qcom_stream_out *out = reinterpret_cast<struct qcom_stream_out *>(stream);
+
+    qadev->hwif->closeOutputStream(out->qcom_out);
+    free(out);
+}
+
+/** This method creates and opens the audio hardware input stream */
+static int adev_open_input_stream(struct audio_hw_device *dev,
+                                  audio_io_handle_t handle,
+                                  audio_devices_t devices,
+                                  struct audio_config *config,
+                                  struct audio_stream_in **stream_in)
+{
+    struct qcom_audio_device *qadev = to_ladev(dev);
+    status_t status;
+    struct qcom_stream_in *in;
+    int ret;
+
+    in = (struct qcom_stream_in *)calloc(1, sizeof(*in));
+    if (!in)
+        return -ENOMEM;
+
+devices = convert_audio_device(devices, HAL_API_REV_2_0, HAL_API_REV_1_0);
+    in->qcom_in = qadev->hwif->openInputStream(devices, (int *)&config->format,
+                                    &config->channel_mask,
+                                    &config->sample_rate,
+                                    &status,
+                                    (AudioSystem::audio_in_acoustics)0);
+    if (!in->qcom_in) {
+        ret = status;
+        goto err_open;
+    }
+
+    in->stream.common.get_sample_rate = in_get_sample_rate;
+    in->stream.common.set_sample_rate = in_set_sample_rate;
+    in->stream.common.get_buffer_size = in_get_buffer_size;
+    in->stream.common.get_channels = in_get_channels;
+    in->stream.common.get_format = in_get_format;
+    in->stream.common.set_format = in_set_format;
+    in->stream.common.standby = in_standby;
+    in->stream.common.dump = in_dump;
+    in->stream.common.set_parameters = in_set_parameters;
+    in->stream.common.get_parameters = in_get_parameters;
+    in->stream.common.add_audio_effect = in_add_audio_effect;
+    in->stream.common.remove_audio_effect = in_remove_audio_effect;
+    in->stream.set_gain = in_set_gain;
+    in->stream.read = in_read;
+    in->stream.get_input_frames_lost = in_get_input_frames_lost;
+
+    *stream_in = &in->stream;
+    return 0;
+
+err_open:
+    free(in);
+    *stream_in = NULL;
+    return ret;
+}
+
+static void adev_close_input_stream(struct audio_hw_device *dev,
+                               struct audio_stream_in *stream)
+{
+    struct qcom_audio_device *qadev = to_ladev(dev);
+    struct qcom_stream_in *in =
+        reinterpret_cast<struct qcom_stream_in *>(stream);
+
+    qadev->hwif->closeInputStream(in->qcom_in);
+    free(in);
+}
+
+static int adev_dump(const struct audio_hw_device *dev, int fd)
+{
+    const struct qcom_audio_device *qadev = to_cladev(dev);
+    Vector<String16> args;
+
+    return qadev->hwif->dumpState(fd, args);
+}
+
+static int qcom_adev_close(hw_device_t* device)
+{
+    struct audio_hw_device *hwdev =
+                        reinterpret_cast<struct audio_hw_device *>(device);
+    struct qcom_audio_device *qadev = to_ladev(hwdev);
+
+    if (!qadev)
+        return 0;
+
+    if (qadev->hwif)
+        delete qadev->hwif;
+
+    free(qadev);
+    return 0;
+}
+
+static int qcom_adev_open(const hw_module_t* module, const char* name,
+                            hw_device_t** device)
+{
+    struct qcom_audio_device *qadev;
+    int ret;
+
+    if (strcmp(name, AUDIO_HARDWARE_INTERFACE) != 0)
+        return -EINVAL;
+
+    qadev = (struct qcom_audio_device *)calloc(1, sizeof(*qadev));
+    if (!qadev)
+        return -ENOMEM;
+
+    qadev->device.common.tag = HARDWARE_DEVICE_TAG;
+    qadev->device.common.version = AUDIO_DEVICE_API_VERSION_2_0;
+    qadev->device.common.module = const_cast<hw_module_t*>(module);
+    qadev->device.common.close = qcom_adev_close;
+
+    qadev->device.init_check = adev_init_check;
+    qadev->device.set_voice_volume = adev_set_voice_volume;
+    qadev->device.set_master_volume = adev_set_master_volume;
+    qadev->device.get_master_volume = adev_get_master_volume;
+#ifdef QCOM_FM_ENABLED
+    qadev->device.set_fm_volume = adev_set_fm_volume;
+#endif
+    qadev->device.set_mode = adev_set_mode;
+    qadev->device.set_mic_mute = adev_set_mic_mute;
+    qadev->device.get_mic_mute = adev_get_mic_mute;
+    qadev->device.set_parameters = adev_set_parameters;
+    qadev->device.get_parameters = adev_get_parameters;
+    qadev->device.get_input_buffer_size = adev_get_input_buffer_size;
+    qadev->device.open_output_stream = adev_open_output_stream;
+    qadev->device.close_output_stream = adev_close_output_stream;
+    qadev->device.open_input_stream = adev_open_input_stream;
+    qadev->device.close_input_stream = adev_close_input_stream;
+    qadev->device.dump = adev_dump;
+
+    qadev->hwif = createAudioHardware();
+    if (!qadev->hwif) {
+        ret = -EIO;
+        goto err_create_audio_hw;
+    }
+
+    *device = &qadev->device.common;
+
+    return 0;
+
+err_create_audio_hw:
+    free(qadev);
+    return ret;
+}
+
+static struct hw_module_methods_t qcom_audio_module_methods = {
+        open: qcom_adev_open
+};
+
+struct qcom_audio_module HAL_MODULE_INFO_SYM = {
+    module: {
+        common: {
+            tag: HARDWARE_MODULE_TAG,
+            module_api_version:  AUDIO_DEVICE_API_VERSION_1_0,
+            hal_api_version: HARDWARE_HAL_API_VERSION,
+            id: AUDIO_HARDWARE_MODULE_ID,
+            name: "QCOM Audio HW HAL",
+            author: "Code Aurora Forum",
+            methods: &qcom_audio_module_methods,
+            dso : NULL,
+            reserved : {0},
+        },
+    },
+};
+
+}; // extern "C"
+
+}; // namespace android
diff --git a/audio/audio_policy.conf b/audio/audio_policy.conf
new file mode 100644
index 0000000..de5ba88
--- /dev/null
+++ b/audio/audio_policy.conf
@@ -0,0 +1,77 @@
+#
+# Audio policy configuration for generic device builds (goldfish audio HAL - emulator)
+#
+
+# Global configuration section: lists input and output devices always present on the device
+# as well as the output device selected by default.
+# Devices are designated by a string that corresponds to the enum in audio.h
+
+global_configuration {
+  attached_output_devices AUDIO_DEVICE_OUT_SPEAKER|AUDIO_DEVICE_OUT_EARPIECE
+  default_output_device AUDIO_DEVICE_OUT_SPEAKER
+  attached_input_devices AUDIO_DEVICE_IN_BUILTIN_MIC|AUDIO_DEVICE_IN_VOICE_CALL
+}
+
+# audio hardware module section: contains descriptors for all audio hw modules present on the
+# device. Each hw module node is named after the corresponding hw module library base name.
+# For instance, "primary" corresponds to audio.primary.<device>.so.
+# The "primary" module is mandatory and must include at least one output with
+# AUDIO_OUTPUT_FLAG_PRIMARY flag.
+# Each module descriptor contains one or more output profile descriptors and zero or more
+# input profile descriptors. Each profile lists all the parameters supported by a given output
+# or input stream category.
+# The "channel_masks", "formats", "devices" and "flags" are specified using strings corresponding
+# to enums in audio.h and audio_policy.h. They are concatenated by use of "|" without space or "\n".
+
+audio_hw_modules {
+  primary {
+    outputs {
+      primary {
+        sampling_rates 44100|48000
+        channel_masks AUDIO_CHANNEL_OUT_STEREO
+        formats AUDIO_FORMAT_PCM_16_BIT
+        devices AUDIO_DEVICE_OUT_SPEAKER|AUDIO_DEVICE_OUT_EARPIECE|AUDIO_DEVICE_OUT_WIRED_HEADSET|AUDIO_DEVICE_OUT_WIRED_HEADPHONE|AUDIO_DEVICE_OUT_ALL_SCO|AUDIO_DEVICE_OUT_AUX_DIGITAL|AUDIO_DEVICE_OUT_FM|AUDIO_DEVICE_OUT_FM_TX
+        flags AUDIO_OUTPUT_FLAG_PRIMARY
+      }
+      voipout {
+        sampling_rates 8000|16000
+        channel_masks AUDIO_CHANNEL_OUT_MONO
+        formats AUDIO_FORMAT_PCM_16_BIT|AUDIO_FORMAT_AMR_NB|AUDIO_FORMAT_AMR_WB|AUDIO_FORMAT_QCELP|AUDIO_FORMAT_EVRC|AUDIO_FORMAT_EVRCB|AUDIO_FORMAT_EVRCWB
+        devices AUDIO_DEVICE_OUT_EARPIECE|AUDIO_DEVICE_OUT_SPEAKER|AUDIO_DEVICE_OUT_WIRED_HEADSET|AUDIO_DEVICE_OUT_WIRED_HEADPHONE
+        flags AUDIO_OUTPUT_FLAG_DIRECT|AUDIO_OUTPUT_FLAG_VOIP_RX
+      }
+      lpa {
+        sampling_rates 8000|11025|12000|16000|22050|24000|32000|44100|48000
+        channel_masks AUDIO_CHANNEL_OUT_STEREO|AUDIO_CHANNEL_OUT_MONO
+        formats AUDIO_FORMAT_PCM_16_BIT
+        devices AUDIO_DEVICE_OUT_SPEAKER|AUDIO_DEVICE_OUT_EARPIECE|AUDIO_DEVICE_OUT_WIRED_HEADSET|AUDIO_DEVICE_OUT_WIRED_HEADPHONE|AUDIO_DEVICE_OUT_ALL_SCO|AUDIO_DEVICE_OUT_AUX_DIGITAL
+        flags AUDIO_OUTPUT_FLAG_DIRECT|AUDIO_OUTPUT_FLAG_LPA
+      }
+    }
+    inputs {
+      primary {
+        sampling_rates 8000|11025|12000|16000|22050|24000|32000|44100|48000
+        channel_masks AUDIO_CHANNEL_IN_MONO|AUDIO_CHANNEL_IN_STEREO|AUDIO_CHANNEL_IN_VOICE_CALL_MONO|AUDIO_CHANNEL_IN_VOICE_DNLINK_MONO|AUDIO_CHANNEL_IN_VOICE_UPLINK_MONO
+        formats AUDIO_FORMAT_PCM_16_BIT|AUDIO_FORMAT_AMR_NB|AUDIO_FORMAT_EVRC|AUDIO_FORMAT_QCELP
+        devices AUDIO_DEVICE_IN_BUILTIN_MIC|AUDIO_DEVICE_IN_WIRED_HEADSET|AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET|AUDIO_DEVICE_IN_AUX_DIGITAL|AUDIO_DEVICE_IN_VOICE_CALL|AUDIO_DEVICE_IN_FM_RX
+      }
+      voipin {
+        sampling_rates 8000|16000
+        channel_masks AUDIO_CHANNEL_IN_MONO
+        formats AUDIO_FORMAT_PCM_16_BIT|AUDIO_FORMAT_AMR_NB|AUDIO_FORMAT_AMR_WB|AUDIO_FORMAT_QCELP|AUDIO_FORMAT_EVRC|AUDIO_FORMAT_EVRCB|AUDIO_FORMAT_EVRCWB
+        devices AUDIO_DEVICE_IN_COMMUNICATION
+      }
+    }
+  }
+ a2dp {
+    outputs {
+      primary {
+        sampling_rates 48000
+        channel_masks AUDIO_CHANNEL_OUT_STEREO
+        formats AUDIO_FORMAT_PCM_16_BIT
+        devices AUDIO_DEVICE_OUT_ALL_A2DP
+        flags AUDIO_OUTPUT_FLAG_PRIMARY
+      }
+    }
+  }
+}
diff --git a/audio/audio_policy_hal.cpp b/audio/audio_policy_hal.cpp
new file mode 100644
index 0000000..ba0cede
--- /dev/null
+++ b/audio/audio_policy_hal.cpp
@@ -0,0 +1,516 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ * Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "audio_policy.msm7627a"
+//#define LOG_NDEBUG 0
+
+#include <stdint.h>
+
+#include <hardware/hardware.h>
+#include <system/audio.h>
+#include <system/audio_policy.h>
+#include <hardware/audio_policy.h>
+
+#include <hardware_legacy/AudioPolicyInterface.h>
+#include <hardware_legacy/AudioSystemLegacy.h>
+
+#include "AudioPolicyCompatClient.h"
+
+namespace android_audio_legacy {
+
+extern "C" {
+
+struct qcom_ap_module {
+    struct audio_policy_module module;
+};
+
+struct qcom_ap_device {
+    struct audio_policy_device device;
+};
+
+struct qcom_audio_policy {
+    struct audio_policy policy;
+
+    void *service;
+    struct audio_policy_service_ops *aps_ops;
+    AudioPolicyCompatClient *service_client;
+    AudioPolicyInterface *apm;
+};
+
+static inline struct qcom_audio_policy * to_qap(struct audio_policy *pol)
+{
+    return reinterpret_cast<struct qcom_audio_policy *>(pol);
+}
+
+static inline const struct qcom_audio_policy * to_cqap(const struct audio_policy *pol)
+{
+    return reinterpret_cast<const struct qcom_audio_policy *>(pol);
+}
+
+
+static int ap_set_device_connection_state(struct audio_policy *pol,
+                                          audio_devices_t device,
+                                          audio_policy_dev_state_t state,
+                                          const char *device_address)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    return qap->apm->setDeviceConnectionState(
+                    device,
+                    (AudioSystem::device_connection_state)state,
+                    device_address);
+}
+
+static audio_policy_dev_state_t ap_get_device_connection_state(
+                                            const struct audio_policy *pol,
+                                            audio_devices_t device,
+                                            const char *device_address)
+{
+    const struct qcom_audio_policy *qap = to_cqap(pol);
+    return (audio_policy_dev_state_t)qap->apm->getDeviceConnectionState(
+                    device,
+                    device_address);
+}
+
+static void ap_set_phone_state(struct audio_policy *pol, audio_mode_t state)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    qap->apm->setPhoneState((int) state);
+}
+
+    /* indicate a change in ringer mode */
+    /* force using a specific device category for the specified usage */
+static void ap_set_force_use(struct audio_policy *pol,
+                          audio_policy_force_use_t usage,
+                          audio_policy_forced_cfg_t config)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    qap->apm->setForceUse((AudioSystem::force_use)usage,
+                          (AudioSystem::forced_config)config);
+}
+
+    /* retreive current device category forced for a given usage */
+static audio_policy_forced_cfg_t ap_get_force_use(
+                                               const struct audio_policy *pol,
+                                               audio_policy_force_use_t usage)
+{
+    const struct qcom_audio_policy *qap = to_cqap(pol);
+    return (audio_policy_forced_cfg_t)qap->apm->getForceUse(
+                          (AudioSystem::force_use)usage);
+}
+
+/* if can_mute is true, then audio streams that are marked ENFORCED_AUDIBLE
+ * can still be muted. */
+static void ap_set_can_mute_enforced_audible(struct audio_policy *pol,
+                                             bool can_mute)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    qap->apm->setSystemProperty("ro.camera.sound.forced", can_mute ? "0" : "1");
+}
+
+static int ap_init_check(const struct audio_policy *pol)
+{
+    const struct qcom_audio_policy *qap = to_cqap(pol);
+    return qap->apm->initCheck();
+}
+
+#ifdef QCOM_TUNNEL_LPA_ENABLED
+static audio_io_handle_t ap_get_session(struct audio_policy *pol,
+                                       audio_stream_type_t stream,
+                                       audio_format_t format,
+                                       audio_policy_output_flags_t flags,
+                                       int sessionId,
+                                       uint32_t samplingRate,
+                                       uint32_t channels)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+
+    ALOGV("%s: tid %d", __func__, gettid());
+    return qap->apm->getSession((AudioSystem::stream_type)stream,
+                               format, (AudioSystem::output_flags)flags,
+                               sessionId,
+                               samplingRate,
+                               channels);
+}
+
+static void ap_pause_session(struct audio_policy *pol, audio_io_handle_t output,
+                          audio_stream_type_t stream)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    qap->apm->pauseSession(output, (AudioSystem::stream_type)stream);
+}
+
+static void ap_resume_session(struct audio_policy *pol, audio_io_handle_t output,
+                          audio_stream_type_t stream)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    qap->apm->resumeSession(output, (AudioSystem::stream_type)stream);
+}
+
+static void ap_release_session(struct audio_policy *pol, audio_io_handle_t output)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    qap->apm->releaseSession(output);
+}
+#endif
+
+static audio_io_handle_t ap_get_output(struct audio_policy *pol,
+                                       audio_stream_type_t stream,
+                                       uint32_t sampling_rate,
+                                       audio_format_t format,
+                                       audio_channel_mask_t channelMask,
+                                       audio_output_flags_t flags,
+                                       const audio_offload_info_t *info)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+
+    ALOGV("%s: tid %d", __func__, gettid());
+    return qap->apm->getOutput((AudioSystem::stream_type)stream,
+                               sampling_rate,(int)  format, channelMask,
+                               (AudioSystem::output_flags)flags, info);
+}
+
+static int ap_start_output(struct audio_policy *pol, audio_io_handle_t output,
+                           audio_stream_type_t stream, int session)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    return qap->apm->startOutput(output, (AudioSystem::stream_type)stream,
+                                 session);
+}
+
+static int ap_stop_output(struct audio_policy *pol, audio_io_handle_t output,
+                          audio_stream_type_t stream, int session)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    return qap->apm->stopOutput(output, (AudioSystem::stream_type)stream,
+                                session);
+}
+
+static void ap_release_output(struct audio_policy *pol,
+                              audio_io_handle_t output)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    qap->apm->releaseOutput(output);
+}
+
+static audio_io_handle_t ap_get_input(struct audio_policy *pol, audio_source_t inputSource,
+                                      uint32_t sampling_rate,
+                                      audio_format_t format,
+                                      audio_channel_mask_t channelMask,
+                                      audio_in_acoustics_t acoustics)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    return qap->apm->getInput((int) inputSource, sampling_rate,(int) format, channelMask,
+                              (AudioSystem::audio_in_acoustics)acoustics);
+}
+
+static int ap_start_input(struct audio_policy *pol, audio_io_handle_t input)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    return qap->apm->startInput(input);
+}
+
+static int ap_stop_input(struct audio_policy *pol, audio_io_handle_t input)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    return qap->apm->stopInput(input);
+}
+
+static void ap_release_input(struct audio_policy *pol, audio_io_handle_t input)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    qap->apm->releaseInput(input);
+}
+
+static void ap_init_stream_volume(struct audio_policy *pol,
+                                  audio_stream_type_t stream, int index_min,
+                                  int index_max)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    qap->apm->initStreamVolume((AudioSystem::stream_type)stream, index_min,
+                               index_max);
+}
+
+static int ap_set_stream_volume_index(struct audio_policy *pol,
+                                      audio_stream_type_t stream,
+                                      int index)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    return qap->apm->setStreamVolumeIndex((AudioSystem::stream_type)stream,
+                                          index,
+                                          AUDIO_DEVICE_OUT_DEFAULT);
+}
+
+static int ap_get_stream_volume_index(const struct audio_policy *pol,
+                                      audio_stream_type_t stream,
+                                      int *index)
+{
+    const struct qcom_audio_policy *qap = to_cqap(pol);
+    return qap->apm->getStreamVolumeIndex((AudioSystem::stream_type)stream,
+                                          index,
+                                          AUDIO_DEVICE_OUT_DEFAULT);
+}
+
+static uint32_t ap_get_strategy_for_stream(const struct audio_policy *pol,
+                                           audio_stream_type_t stream)
+{
+    const struct qcom_audio_policy *qap = to_cqap(pol);
+    return qap->apm->getStrategyForStream((AudioSystem::stream_type)stream);
+}
+
+static int ap_set_stream_volume_index_for_device(struct audio_policy *pol,
+                                      audio_stream_type_t stream,
+                                      int index,
+                                      audio_devices_t device)
+{
+   const struct qcom_audio_policy *qap = to_cqap(pol);
+   return qap->apm->setStreamVolumeIndex((AudioSystem::stream_type)stream,
+                                          index,
+                                          device);
+}
+
+static int ap_get_stream_volume_index_for_device(const struct audio_policy *pol,
+                                      audio_stream_type_t stream,
+                                      int *index,
+                                      audio_devices_t device)
+{
+   const struct qcom_audio_policy *qap = to_cqap(pol);
+   return qap->apm->getStreamVolumeIndex((AudioSystem::stream_type)stream,
+                                          index,
+                                          AUDIO_DEVICE_OUT_DEFAULT);
+}
+
+static audio_devices_t ap_get_devices_for_stream(const struct audio_policy *pol,
+                                       audio_stream_type_t stream)
+{
+    const struct qcom_audio_policy *qap = to_cqap(pol);
+    return qap->apm->getDevicesForStream((AudioSystem::stream_type)stream);
+}
+
+static audio_io_handle_t ap_get_output_for_effect(struct audio_policy *pol,
+                                           const struct effect_descriptor_s *desc)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    return qap->apm->getOutputForEffect(desc);
+}
+
+static int ap_register_effect(struct audio_policy *pol,
+                              const struct effect_descriptor_s *desc,
+                              audio_io_handle_t io,
+                              uint32_t strategy,
+                              int session,
+                              int id)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    return qap->apm->registerEffect(desc, io, strategy, session, id);
+}
+
+static int ap_unregister_effect(struct audio_policy *pol, int id)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    return qap->apm->unregisterEffect(id);
+}
+
+static int ap_set_effect_enabled(struct audio_policy *pol, int id, bool enabled)
+{
+    struct qcom_audio_policy *qap = to_qap(pol);
+    return qap->apm->setEffectEnabled(id, enabled);
+}
+
+static bool ap_is_stream_active(const struct audio_policy *pol,
+                                audio_stream_type_t stream,
+                                uint32_t in_past_ms)
+{
+    const struct qcom_audio_policy *qap = to_cqap(pol);
+    return qap->apm->isStreamActive((int) stream, in_past_ms);
+}
+
+static bool ap_is_stream_active_remotely(const struct audio_policy *pol, audio_stream_type_t stream,
+                                uint32_t in_past_ms)
+{
+    const struct qcom_audio_policy *qap = to_cqap(pol);
+    return qap->apm->isStreamActiveRemotely((int) stream, in_past_ms);
+}
+
+static bool ap_is_source_active(const struct audio_policy *pol, audio_source_t source)
+{
+    const struct qcom_audio_policy *qap = to_cqap(pol);
+    return qap->apm->isSourceActive(source);
+}
+
+static int ap_dump(const struct audio_policy *pol, int fd)
+{
+    const struct qcom_audio_policy *qap = to_cqap(pol);
+    return qap->apm->dump(fd);
+}
+
+static bool ap_is_offload_supported(const struct audio_policy *pol,
+                                    const audio_offload_info_t *info)
+{
+    const struct qcom_audio_policy *qap = to_cqap(pol);
+    return qap->apm->isOffloadSupported(*info);
+}
+
+static int create_qcom_ap(const struct audio_policy_device *device,
+                            struct audio_policy_service_ops *aps_ops,
+                            void *service,
+                            struct audio_policy **ap)
+{
+    struct qcom_audio_policy *qap;
+    int ret;
+
+    if (!service || !aps_ops)
+        return -EINVAL;
+
+    qap = (struct qcom_audio_policy *)calloc(1, sizeof(*qap));
+    if (!qap)
+        return -ENOMEM;
+
+    qap->policy.set_device_connection_state = ap_set_device_connection_state;
+    qap->policy.get_device_connection_state = ap_get_device_connection_state;
+    qap->policy.set_phone_state = ap_set_phone_state;
+    qap->policy.set_force_use = ap_set_force_use;
+    qap->policy.get_force_use = ap_get_force_use;
+    qap->policy.set_can_mute_enforced_audible =
+        ap_set_can_mute_enforced_audible;
+    qap->policy.init_check = ap_init_check;
+    qap->policy.get_output = ap_get_output;
+#ifdef QCOM_TUNNEL_LPA_ENABLED
+    qap->policy.get_session = ap_get_session;
+    qap->policy.pause_session = ap_pause_session;
+    qap->policy.resume_session = ap_resume_session;
+    qap->policy.release_session = ap_release_session;
+#endif
+    qap->policy.start_output = ap_start_output;
+    qap->policy.stop_output = ap_stop_output;
+    qap->policy.release_output = ap_release_output;
+    qap->policy.get_input = ap_get_input;
+    qap->policy.start_input = ap_start_input;
+    qap->policy.stop_input = ap_stop_input;
+    qap->policy.release_input = ap_release_input;
+    qap->policy.init_stream_volume = ap_init_stream_volume;
+    qap->policy.set_stream_volume_index = ap_set_stream_volume_index;
+    qap->policy.get_stream_volume_index = ap_get_stream_volume_index;
+    qap->policy.set_stream_volume_index_for_device = ap_set_stream_volume_index_for_device;
+    qap->policy.get_stream_volume_index_for_device = ap_get_stream_volume_index_for_device;
+    qap->policy.get_strategy_for_stream = ap_get_strategy_for_stream;
+    qap->policy.get_devices_for_stream = ap_get_devices_for_stream;
+    qap->policy.get_output_for_effect = ap_get_output_for_effect;
+    qap->policy.register_effect = ap_register_effect;
+    qap->policy.unregister_effect = ap_unregister_effect;
+    qap->policy.set_effect_enabled = ap_set_effect_enabled;
+    qap->policy.is_stream_active = ap_is_stream_active;
+    qap->policy.is_stream_active_remotely = ap_is_stream_active_remotely;
+    qap->policy.is_source_active = ap_is_source_active;
+    qap->policy.dump = ap_dump;
+    qap->policy.is_offload_supported = ap_is_offload_supported;
+
+    qap->service = service;
+    qap->aps_ops = aps_ops;
+    qap->service_client =
+        new AudioPolicyCompatClient(aps_ops, service);
+    if (!qap->service_client) {
+        ret = -ENOMEM;
+        goto err_new_compat_client;
+    }
+
+    qap->apm = createAudioPolicyManager(qap->service_client);
+    if (!qap->apm) {
+        ret = -ENOMEM;
+        goto err_create_apm;
+    }
+
+    *ap = &qap->policy;
+    return 0;
+
+err_create_apm:
+    delete qap->service_client;
+err_new_compat_client:
+    free(qap);
+    *ap = NULL;
+    return ret;
+}
+
+static int destroy_qcom_ap(const struct audio_policy_device *ap_dev,
+                             struct audio_policy *ap)
+{
+    struct qcom_audio_policy *qap = to_qap(ap);
+
+    if (!qap)
+        return 0;
+
+    if (qap->apm)
+        destroyAudioPolicyManager(qap->apm);
+    if (qap->service_client)
+        delete qap->service_client;
+    free(qap);
+    return 0;
+}
+
+static int qcom_ap_dev_close(hw_device_t* device)
+{
+    if (device)
+        free(device);
+    return 0;
+}
+
+static int qcom_ap_dev_open(const hw_module_t* module, const char* name,
+                                    hw_device_t** device)
+{
+    struct qcom_ap_device *dev;
+
+    if (strcmp(name, AUDIO_POLICY_INTERFACE) != 0)
+        return -EINVAL;
+
+    dev = (struct qcom_ap_device *)calloc(1, sizeof(*dev));
+    if (!dev)
+        return -ENOMEM;
+
+    dev->device.common.tag = HARDWARE_DEVICE_TAG;
+    dev->device.common.version = 0;
+    dev->device.common.module = const_cast<hw_module_t*>(module);
+    dev->device.common.close = qcom_ap_dev_close;
+    dev->device.create_audio_policy = create_qcom_ap;
+    dev->device.destroy_audio_policy = destroy_qcom_ap;
+
+    *device = &dev->device.common;
+
+    return 0;
+}
+
+static struct hw_module_methods_t qcom_ap_module_methods = {
+        open: qcom_ap_dev_open
+};
+
+struct qcom_ap_module HAL_MODULE_INFO_SYM = {
+    module: {
+        common: {
+            tag: HARDWARE_MODULE_TAG,
+            version_major: 1,
+            version_minor: 0,
+            id: AUDIO_POLICY_HARDWARE_MODULE_ID,
+            name: "QCOM Audio Policy HAL",
+            author: "Code Aurora Forum",
+            methods: &qcom_ap_module_methods,
+            dso : NULL,
+            reserved : {0},
+        },
+    },
+};
+
+}; // extern "C"
+
+}; // namespace android_audio_legacy
